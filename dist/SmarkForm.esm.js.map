{"version":3,"file":"SmarkForm.esm.js","sources":["../src/lib/events.js","../src/lib/legacy.js","../src/lib/component.js","../src/lib/hotkeys.js","../src/types/trigger.type.js","../src/lib/helpers.js","../src/types/label.type.js","../src/decorators/foldable.deco.js","../src/decorators/export_to_target.deco.js","../src/decorators/import_from_target.deco.js","../src/types/form.type.js","../src/types/list.decorators/smartdisabling.deco.js","../src/decorators/mutex.deco.js","../src/types/list.decorators/sortable.deco.js","../src/types/list.type.js","../src/types/input.type.js","../src/types/number.type.js","../src/types/date.type.js","../src/types/radio.type.js","../src/types/color.type.js","../src/main.js"],"sourcesContent":["// lib/events.js\n// =============\n\nconst sym_local_events = Symbol(\"Events\");\nconst sym_all_events = Symbol(\"allEvents\");\nconst re_actionEvHandler = /^on(?:Before|After)Action_/;\nconst re_localEvHandler = /^onLocal_/;\nconst re_allEvHandler = /^onAll_/;\n\nfunction registerEvHandler(evList, evType, evHandler) {\n    const me = this;\n    if (! evList.has(evType)) evList.set(evType, []);\n    evList.get(evType).push(evHandler.bind(me));\n    return me; // Make chainable.\n};\n\nexport const events = function events_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class eventEnebledTarget extends target {\n            constructor(target, optionsSrc, ...args) {\n\n                // Capture before/after action event hanlers through\n                // onBeforeAction_xxx / onAfterAction_xxx options\n                // ...and onLocal_xxx / onAll_xxx regular event handlers.\n                const options = {};\n                const onOptionCallbacks = [];\n                for (\n                    const [key, value]\n                    of Object.entries(optionsSrc)\n                ) if (key.match(re_actionEvHandler)) {\n                    onOptionCallbacks.push([key.substring(2), value, \"onLocal\"])\n                } else if (key.match(re_localEvHandler)) {\n                    onOptionCallbacks.push([key.substring(8), value, \"onLocal\"])\n                } else if (key.match(re_allEvHandler)) {\n                    onOptionCallbacks.push([key.substring(6), value, \"onAll\"])\n                } else {\n                    // Threat the rest as regular options:\n                    options[key] = value;\n                };\n\n                // Call original constructor:\n                super(target, options, ...args);\n\n                // Events enhancing:\n                const me = this;\n                const ImRoot = Object.is(me, me.root);\n                me[sym_local_events] = new Map();\n                if (ImRoot) me.root[sym_all_events] = new Map();\n                me.onLocal = registerEvHandler.bind(me, me[sym_local_events]);\n                me.onAll = registerEvHandler.bind(me.root, me.root[sym_all_events]);\n                me.on = me.onLocal; // Handy and readable alias for local events.\n\n                // Setup action handlers provided through options:\n                for (\n                    const [evt, handler, listenLevel]\n                    of onOptionCallbacks\n                ) me[listenLevel](evt, handler);\n\n            };\n            async emit(evType, evData) {\n                const me = this;\n                const handlers = [ // Local handlers, then global ones:\n                    ...(me[sym_local_events].get(evType) || []),\n                    ...(me.root[sym_all_events].get(evType) || []),\n                ];\n                let defaultPrevented = false;\n                if (handlers.length) {\n                    let propagationStopped = false;\n                    evData.preventDefault = () => defaultPrevented = true;\n                    evData.stopPropagation = () => propagationStopped = true;\n                    for (const handler of handlers) {\n                        if (propagationStopped) break;\n                        await handler(evData);\n                    };\n                };\n                return ! defaultPrevented;\n            };\n        };\n    };\n};\n\n","// src/lib/legacy.js\n// =================\n\nexport default {\n    disEnhance(me) {\n\n        // Prevent <form>'s default behaviour:\n        if (me.targetNode.tagName.toLowerCase()) {\n            me.targetNode.addEventListener('submit', function(event) {\n\n                // Avoid form's regular submission:\n                event.preventDefault();\n\n                // More work may be needed to be done here (let's give it some\n                // more thought...)\n\n            });\n        };\n\n    },\n};\n","// lib/component.js\n// ================\nconst componentTypes = {};\n\nimport {events} from \"./events.js\";\nimport legacy from \"./legacy.js\";\n\nconst sym_smart = Symbol(\"smart_component\");\nconst re_valid_typename_chars = /^[a-z0-9_]+$/i;\nconst re_has_wildcards = /[\\*\\?]/;\nconst wild2regex = wname => new RegExp(//{{{\n    \"^\"\n    + wname\n        .replace(/\\*+/g, \".*\")\n        .replace(/\\?/g, \".\")\n    + \"$\"\n);//}}}\n\nconst errors = {\n    renderError: class renderError extends Error {//{{{\n        constructor(code, message, path) {\n            super(`RenderError(${path}): ${message}`);\n            this.code = code;\n            this.path = path;\n            this.stack = this.stack\n                .split(\"\\n\")\n                .slice(2)\n                .join(\"\\n\")\n            ;\n        };\n    },//}}}\n};\n\nfunction inferType(node, parentComponent) {//{{{\n    switch (node.tagName.toLowerCase()) {\n        case \"ul\":\n        case \"ol\":\n        case \"table\":\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n            return \"list\";\n        case \"input\":\n            const type = String(node.getAttribute(\"type\")||\"\").toLowerCase();\n            if (parentComponent.isSingleton) return parentComponent.options.type;\n            switch(type) {\n                case \"number\":\n                case \"date\":\n                case \"radio\":\n                case \"color\":\n                    return type;\n            };\n        case \"textarea\":\n        case \"select\":\n            return \"input\";\n        case \"label\":\n            return \"label\";\n        default:\n            //if (parentComponent.options.type == \"list\") return \"form\";\n        case \"form\":\n            return \"form\";\n    };\n};//}}}\n\n@events\nexport class SmarkComponent {\n    constructor(//{{{\n        targetNode\n        , {\n            property_name = \"smark\",\n            ...options\n        } = {}\n        , parent\n    ) {\n        const me = this;\n\n        me.validName = (function nameGenerator() {//{{{\n            let counter = 0;\n            return function(...names){\n                for (\n                    let n0 of names\n                ) if (\n                    typeof n0 == \"string\"\n                ) {\n                    n0 = n0.trim();\n                    if (n0.length) return n0;\n                };\n                return 'UNNAMED'+(++counter);\n            };\n        })();//}}}\n\n        me.actions = {};\n        me.property_name = property_name;\n        me.selector = `[data-${me.property_name}]`;\n        me.types = componentTypes;\n        me.targetNode = targetNode;\n        me.options = options;\n        me.setNodeOptions(me.targetNode, me.options);\n\n        me.parent = parent;\n        if (! me.parent instanceof SmarkComponent) throw me.renderError(\n            'INVALID_PARENT'\n            , `Smark Components must have valid Smark Component parent.`\n        );\n        me.root = (\n            me.parent === null ? me\n            : me.parent.root\n        );\n\n        // Parents iterator:\n        me.parents = {};\n        me.parents[Symbol.iterator] = function* () {\n            let current = me;\n            while (current) {\n                yield current;\n                current = current.parent;\n            };\n        };\n\n        // Calculate prefix or disable autoId:\n        const autoId = me.inherittedOption(\"autoId\", false);\n        me.genId = (\n            autoId === false ? false\n                // Do not auto-generate IDs.\n            : autoId === true ? p => p.replace(/\\//g, \"_\")\n                // Use \"_path_in_underscore_style\".\n            : typeof autoId == \"string\" ? p => autoId+p.replace(/\\//g, \"_\")\n                // Use \"prefix\" + \"_path_in_underscore_style\".\n            : typeof autoId == \"function\" ? autoId\n                // Use fn(path) custom style.\n            : false\n                // Failback to disabled.\n        );\n\n        me.onRenderedTasks = [];\n\n        let setRendered;\n        me.renderedSync = false;\n        me.rendered = new Promise(resolve => setRendered = resolve);\n\n        me.children = {};\n        me.targetNode[sym_smart] = me;\n\n        (async ()=>{\n            await me.render();\n            for (\n                const task of me.onRenderedTasks\n            ) await task();\n            me.onRenderedTasks = null;\n            setRendered(true);\n            setTimeout(()=>me.renderedSync = true, 1);\n        })();\n        if (me.options.onRendered) me.onRendered(me.options.onRendered);\n\n    };//}}}\n    onRendered(cbk) {//{{{\n        const me = this;\n        if (me.onRenderedTasks) {\n            me.onRenderedTasks.push(cbk.bind(me));\n        } else {\n            cbk.bind(me)();\n        };\n    };//}}}\n    getNodeOptions(node, defaultOptions) {//{{{\n        const me = this;\n        const optionsSrc = (\n            node.dataset[me.property_name] || \"\"\n        ).trim() || null;\n        const options = {\n            ...defaultOptions,\n            ...(()=>{\n                try {\n                    const opt = JSON.parse(optionsSrc);\n                    if (typeof opt != \"object\") throw new Error(\"NO_OBJECT\");\n                    return opt;\n                } catch (err) {\n                    return (\n                        optionsSrc.match(re_valid_typename_chars) ? {type: optionsSrc}\n                        : {}\n                    );\n                };\n            })(),\n        };\n        if (! options.action && ! options.type) options.type = inferType(node, me);\n        me.setNodeOptions(node, options);\n        return options;\n    };//}}}\n    setNodeOptions(node, options) {//{{{\n        const me = this;\n        node.dataset[me.property_name] = JSON.stringify(options);\n    };//}}}\n    async enhance(node, defaultOptions) {//{{{\n        const me = this;\n\n        // Sanityze and store options:{{{\n        let options = me.getNodeOptions(node, defaultOptions);\n        //}}}\n\n        // Prevent default behaviours:{{{\n        legacy.disEnhance(me);\n        //}}}\n\n        // Classify:{{{\n        if (options.action) {\n            if (! options.type) options.type = \"trigger\"; // Make type optional for triggers.\n            if (options.type != \"trigger\") throw me.renderError(\n                \"ACTION_IN_NON_TRIGGER\"\n                , `\"action\" property is only allowed for \"trigger\" components but \"${options.type}\" type specified.`\n            );\n        } else if (typeof options.type != \"string\") {\n            throw me.renderError(\n                \"NO_TYPE_PROVIDED\"\n                , `Invalid SmarkForm item: type is mandatory for non trigger components.`\n            );\n        };\n        //}}}\n\n        // Enhance:{{{\n        const ctrl = me.types[options.type];\n        if (! ctrl) throw me.renderError(\n            \"UNKNOWN_TYPE\"\n            , `Unimplemented SmarkForm component controller: ${options.type}`,\n        );\n        return new ctrl (\n            node\n            , options\n            , me\n        );\n        //}}}\n\n    };//}}}\n    getComponent(target) {//{{{\n        const me = this;\n        return (\n            target[sym_smart]\n            || target.parentElement?.closest(me.selector)[sym_smart]\n            || null\n        );\n    };//}}}\n    getPath() {//{{{\n        const me = this;\n        return (\n            [...me.parents].map(p=>p.name)\n            .reverse()\n            .join(\"/\") // Root parent being \"\" => Starting \"/\".\n            || \"/\" // No join (0 parents => root node)\n        );\n    };//}}}\n    find(path=\"\") { // {{{\n        let base=this;\n        if (path[0] == \"/\") while (base.parent) base = base.parent;\n        const parts = path\n            .split(\"/\")\n            .filter(x=>x)\n        ;\n\n        // (Recursive) Multi-match search (path with '*' wildcards):\n        // (Returns array of components)\n        const firstWildcardPos = parts.findIndex(p=>p.match(re_has_wildcards));\n        if (firstWildcardPos >= 0) {\n            const re_pattern = wild2regex(parts[firstWildcardPos]);\n            const pivotPath = parts.slice(0, firstWildcardPos).join(\"/\");\n            const restPath = parts.slice(firstWildcardPos + 1).join(\"/\");\n            const pivot = base.find(pivotPath);\n            const pivotChilds = Object.entries(pivot.children);\n            return pivotChilds\n                .filter(([name,child])=>child && name.match(re_pattern))\n                .map(([,child])=>child.find(restPath))\n                .flat(Infinity)\n            ;\n        };\n\n        // Straight search (wildcardless path)\n        // (Returns single component)\n        return parts.reduce(\n            ((current, name)=>(\n                current === undefined ? null\n                : name == \"..\" ? current.parent\n                : current.children[name]\n            ))\n            , base\n        )\n    ;\n    };//}}}\n    inherittedOption(optName, defaultValue) {//{{{\n        const me = this;\n        for (\n            const p of me.parents\n        ) if (\n            p.options[optName] !== undefined\n        ) return p.options[optName];\n        return defaultValue;\n    };//}}}\n    moveTo(){//{{{\n        const me = this;\n        if (! me.targetNode.id) me.targetNode.id = me.getPath();\n        document.location.hash = me.targetNode.id;\n        // Avoid noisy url hash \"randomish\" effect:\n        window.history.pushState({}, undefined,window.location.pathname);\n            // Like 'document.location.hash = \"\"' but without leaving leading\n            // hash character.\n    };//}}}\n    getTriggers(actionNames = \"\") {//{{{\n        const me = this;\n        const myCurrentActions = [];\n        const actionKeys = new Set([actionNames]\n            .flat()\n            .map(String)\n            .filter(x=>x)\n        );\n        const returnAll = actionKeys.has(\"*\");\n        for (\n            const tgg\n            of [...me.root.targetNode.querySelectorAll(me.selector)]\n                .map(target=>target[sym_smart])\n                .filter(x=>x) // Ignore not yet rendered.\n        ) {\n            const options = tgg.getTriggerArgs()\n            if (! options) continue; // Not a trigger\n            if (! Object.is(options.context, me)) continue;\n            if (\n                returnAll\n                || actionKeys.has(options.action)\n            ) myCurrentActions.push(tgg);\n        };\n        return myCurrentActions;\n    };//}}}\n    updateId() {//{{{\n        const me = this;\n        if (me.genId === false) return; // Abort if disabled.\n        const newId = me.genId(me.getPath());\n        if (me.targetNode.id != newId) {\n            me.targetNode.id = newId;\n            for (\n                const child\n                of Object.values(me.children)\n            ) child.updateId();\n        };\n        return me.targetNode.id\n    };//}}}\n    focus() {//{{{\n        const me = this;\n        for (const fname in me.children) {\n            return me.children[fname].focus();\n        };\n        if (me.targetFieldNode) me.targetFieldNode.focus();\n    };//}}}\n    getTriggerArgs() {}; // Let's easily filter out non trigger compoenents.\n    // Error types:\n    renderError(code, message) {//{{{\n        const me = this;\n        return new errors.renderError(code, message, me.getPath());\n    };//}}}\n};\n\nexport class SmarkField extends SmarkComponent {\n    constructor(...args){\n        super(...args);\n        this._isField = true;\n        if (! Object.is(this, this.root)) {\n            this.name = this.validName(\n                this.options.name\n                , this.targetNode.getAttribute(\"name\")\n            );\n            if (this.options.hasOwnProperty(\"value\")) {\n                if (this.targetNode.getAttribute(\"value\") !== null) { // Conflict\n                    throw me.renderError(\n                        'VALUE_CONFLICT'\n                        , `Initial value specied both as \"value\" option and HTML \"value\" attribute.`\n                    );\n                };\n                this.targetNode.setAttribute(\"value\", this.options.value);\n            };\n        };\n    };\n};\n\nexport function createType(name, controller) {//{{{\n    if (componentTypes[name] !== undefined) throw new Error(\n        `Duplicate component type definition: ${name}`\n    );\n    if (! (controller.prototype instanceof SmarkComponent)) throw new Error(\n        `Bad component type implementation for: ${name}`\n    );\n    componentTypes[name] = controller;\n};//}}}\n\n","// lib/hotkeys.js\n// ==============\n\nexport class hotKeys_handler {\n    constructor(form) {\n        const me = this;\n        me.form = form;\n        me.revealed = null;\n        me.form.targetNode.addEventListener(\n            \"keydown\"\n            , me.onKeydown.bind(me)\n            , true\n        );\n        me.form.targetNode.addEventListener(\n            \"keyup\"\n            , me.onKeyup.bind(me)\n            , true\n        );\n        me.form.targetNode.addEventListener(\n            \"focusout\"\n            , me.onFocusout.bind(me)\n            , true\n        );\n        me.form.targetNode.addEventListener(\n            \"focusin\"\n            , me.onFocusin.bind(me)\n            , true\n        );\n    };\n    onKeydown(ev) {\n        const me = this;\n        if (ev.key == \"Control\") {\n            me.reveal(ev.target); // Activate and reveal.\n        } else if (ev.ctrlKey) {\n            const targettedTrigger = me.revealed.find(\n                t=>t.options.hotkey == ev.key\n            );\n            if (targettedTrigger) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                targettedTrigger.targetNode.click();\n            };\n        };\n    };\n    onKeyup(ev) {\n        const me = this;\n        if (ev.key == \"Control\") {\n            me.reveal(false); // Deactivate\n        };\n    };\n    onFocusout(ev) {\n        const me = this;\n        if (me.revealed !== null) {\n            me.reveal(); // Unreveal, keep activated.\n        };\n    };\n    onFocusin(ev) {\n        const me = this;\n        if (me.revealed !== null) {\n            me.reveal(ev.target); // Update revealed triggers\n        };\n    };\n    reveal(target) {\n        const me = this;\n\n        // Conceal previous target triggers' hotkeys if any:\n        if (me.revealed !== null) {\n            for (const t of me.revealed) {\n                t.targetNode.removeAttribute(\"data-hotkey\");\n            };\n            me.revealed.length = 0;\n        };\n\n        if (target === false) {\n            me.revealed = null; // Deactivate hot keys\n        };\n\n        if (target) {\n\n            // Reveal new target triggers' hotkeys:\n            const component = me.form.getComponent(target);\n            const activeContexts = [component, ...component.parents];\n            const activeContextsSet = new Set(activeContexts);\n\n            const candidateTriggers = activeContexts\n                .map((c, lv)=>(\n                    c.getTriggers('*')    // All triggers.\n                    .map(tg=>({\n                        tg,\n                        lv,   // Ancestor level.\n                        args: tg.getTriggerArgs() || {},\n                        hotkey: String(tg.options.hotkey || \"\"),\n                    }))\n                ))\n                .flat()\n                .filter(({args, hotkey})=>(\n                    hotkey.length\n                    && activeContextsSet.has(args.context)\n                ))\n                .sort((ta,tb)=>(\n                    activeContextsSet.has(tb.args.target)\n                    - activeContextsSet.has(ta.args.target)\n                    - tb.lv\n                    + ta.lv\n                ))\n            ;\n\n            const usedKeys = new Set();\n            me.revealed = [];\n\n            for (const candidate of candidateTriggers) {\n                if (usedKeys.has(candidate.hotkey)) continue; // Used by more preferent tg.\n                if (! candidate.tg.targetNode.disabled) {\n                    candidate.tg.targetNode.setAttribute(\"data-hotkey\", candidate.hotkey);\n                };\n                // (UX): Perform the following even if disabled for behavioral\n                // consistency...\n                usedKeys.add(candidate.hotkey); // ...don't activate others in place.\n                me.revealed.push(candidate.tg); // ...keep preventing event propagation.\n            };\n\n        };\n\n    };\n};\n","// types/trigger.type.js\n// =====================\nimport {SmarkComponent} from \"../lib/component.js\";\n\nconst beforeEvent = Symbol(\"beforeEventName\");\nconst afterEvent = Symbol(\"afterEventName\");\n\nexport const action = function action_decorator(targetMtd, {kind, name, addInitializer}) {\n    if (kind == \"method\") addInitializer(function registerAction() {\n        this.actions[name] = targetMtd.bind(this);\n        this.actions[name][beforeEvent] = `BeforeAction_${name}`;\n        this.actions[name][afterEvent] = `AfterAction_${name}`;\n    });\n};\n\n\nexport class trigger extends SmarkComponent {\n    constructor(node, options, ...args){\n        delete options.name; // Triggers are always unnamed.\n        return super(node, options, ...args);\n    };\n    render(){\n        const me = this;\n        me.parent.onRendered(()=>{\n            const triggerArgs = me.getTriggerArgs();\n            if (\n                typeof triggerArgs.context?.onTriggerRender == \"function\"\n            ) triggerArgs.context.onTriggerRender(triggerArgs);\n        });\n    };\n    disable() {//{{{\n        const me = this;\n        me.targetNode.disabled = true;\n    };//}}}\n    enable() {//{{{\n        const me = this;\n        me.targetNode.disabled = false;\n    };//}}}\n    getTriggerArgs() {//{{{\n        const me = this;\n        const parents = [...me.parents];\n        const {\n            // property: local variable\n            action: actionSpec,\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n        if (! actionSpec) return; // Not a trigger component.\n\n        // Allow binding triggers to specific component types:\n        // (Syntax \"type:action\")\n        let [actionName, targetType] = actionSpec.split(\":\").reverse();\n\n        const context = (\n            contextPath ? me.parent.find(contextPath)\n            : parents.find(p=>{\n                if (targetType && p.options.type != targetType) return false;\n                if (typeof p.actions[actionName] != \"function\") return false;\n                return true;\n            })\n        );\n\n        const target = (\n            targetPath ? context.find(targetPath) // Explicit target (context relative)\n            : contextPath ? null // Explicit context path => don't mind component position\n            : (\n                parents\n                    .slice(1) // Skip self\n                    .find(p=>p.parent?.targetNode.isSameNode(context?.targetNode))\n                || null\n            )\n        );\n\n        return {\n            action: actionName,\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n\nexport async function onTriggerClick(ev) {\n    const me = this;\n    const triggerComponent = me.getComponent(ev.target);\n    const options = triggerComponent.getTriggerArgs();\n    if (! options) return; // Not a trigger.\n    const {context, action} = options;\n    const mtd = context?.actions[action]\n    if (\n        typeof mtd != \"function\"\n    ) throw me.renderError(\n        \"UNKNOWN_ACTION\"\n        , `Unknown action ${action}`\n        + (context ? ` for ${context.options.type}` : \"\")\n    );\n    if (await me.emit(mtd[beforeEvent], options)) {\n        const data = await mtd(options);\n        me.emit(mtd[afterEvent], {...options, data});\n    };\n};\n\n\n","\"use strict\";\nexport function getRoots(target, selector){//{{{\n    const parent = target.parentNode;\n    const isTop = (\n        parent === null ? n => n === null\n        : n=>(n===null)||n.isSameNode(target)\n    );\n    return [\n        ...target.querySelectorAll(selector)\n    ].filter(\n        e=>isTop(e.parentNode.closest(selector))\n    );\n};//}}}\n\nexport function makeRoom(element, pixels) {//{{{\n    let parent = element.parentNode;\n    const direction = (\n        pixels >= 0 ? 1\n        : -1\n    );\n    while (parent) {\n        // Check if parent has vertical scroll bar\n        if (parent.scrollHeight > parent.clientHeight * direction) {\n            // Get the maximum amount that can be scrolled in this parent\n            var maxScroll = parent.scrollHeight - parent.clientHeight * direction;\n\n            // If desired amount is less than maximum scroll, perform scroll\n            if (pixels <= maxScroll * direction) {\n                parent.scrollTop += pixels;\n                return;\n            } else {\n              // If desired amount is greater than maximum scroll,\n              // scroll to maximum and subtract it from desired amount\n              parent.scrollTop = maxScroll;\n              pixels -= maxScroll;\n            };\n        };\n        parent = parent.parentNode;\n    };\n};//}}}\n\nexport function randomId() {//{{{\n    return Math.random().toString(36).substring(2);\n};//}}}\n\nexport function parseJSON(str) {//{{{\n    try {\n        return JSON.parse(str);\n    } catch (err) {};\n};//}}}\n","// types/label.type.js\n// ===================\nimport {SmarkComponent} from \"../lib/component.js\";\nimport {randomId} from \"../lib/helpers.js\";\n\n// TODO:\n// =====\n//\n//   ðŸš€ Add support for (smarkform) fields contained in the label.\n//      ðŸ‘‰ Now we can just not enhance the label (<label>Bla bla bla<input\n//         data-smark></label>) and it will (in this case natively) work.\n//      ðŸ‘‰ ...but this does not allow us to use other SmarkForm fields such as\n//         forms and lists (since they can contain more than one native field\n//         which is not allowed by <label> tag.\n//      ðŸ’¡ But we can use different tag (with {data-smark=\"label\"}) and just\n//         create the native <label> tag around the text.\n//\n//   ðŸš€ Implement \"text templating\" feature.\n//      ðŸ‘‰ This should allow to include contextual data in the text of the\n//         label.\n//      âš¡ For example, list item position for list items...\n//\n\nexport class label extends SmarkComponent {\n    constructor(node, {allow_select = false, ...options}, ...args){\n        delete options.name; // Labels are always unnamed.\n        return super(node, {allow_select, ...options}, ...args);\n    };\n    render(){\n        const me = this;\n        me.parent.onRendered(()=>{\n            const labelArgs = me.getLabelArgs();\n            const {targetFieldNode} = labelArgs.target || {};\n            if (targetFieldNode) { // Apply only to native inputs (scalars)\n                if (! targetFieldNode.id) { // Ensure targetted field has an Id\n                    targetFieldNode.id = randomId();\n                };\n                me.targetNode.setAttribute(\"for\", targetFieldNode.id);\n            };\n            if (! me.options.allow_select) {\n                // Make labels non-selectable unless \"allow_select\" option\n                // is set  to true.\n                me.targetNode.style[\"user-select\"] = \"none\";\n            };\n        });\n    };\n    getLabelArgs() {//{{{\n        const me = this;\n        const parents = [...me.parents];\n        let context, target;\n\n        const {\n            // property: local variable\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n\n        if (! contextPath && ! targetPath) {\n            // Guess ;-)\n            context = me.parent;\n            const candidates = context.targetNode.querySelectorAll(me.selector);\n            let found = false;\n            for (const childName in candidates) {\n                if (found) {\n                    let targetComponent = me.getComponent(candidates[childName]);\n                    if (targetComponent?._isField) {\n                        // FIXME : Dig deeper in case of non native field tags\n                        // (forms, lists, singletons...)\n                        // It may require to await for rendering or even listen\n                        // to events (lists with minItems = 0);\n                        target = targetComponent;\n                        break;\n                    };\n                } else if (\n                    Object.is(candidates[childName], me.targetNode)\n                ) {\n                    found = true;;\n                };\n            };\n        } else {\n            context = (\n                contextPath ? me.parent.find(contextPath)\n                : me.parent\n            );\n            target = (\n                targetPath ? context.find(targetPath) // Explicit target (context relative)\n                : context\n            );\n        };\n\n        return {\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n","\nimport {action} from \"../types/trigger.type.js\";\n\nexport const foldable = function foldable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class foldableTarget extends target {\n            render(...args) {//{{{\n                const retv = super.render(...args);\n                const me = this;\n                me.root.onRendered(()=>{\n                    me.fold({operation: (\n                        !! me.options.folded ? \"fold\"\n                        : \"unfold\"\n                    )});\n                });\n                return retv;\n            };//}}}\n            @action\n            fold({//{{{\n                operation = \"toggle\", // Values: \"fold\" / \"unfold\" / \"toggle\"\n            } = {}) {\n                const me = this;\n                const wasFolded = me.targetNode.style.display == \"none\";\n                const isFolded = (\n                    operation == \"fold\" ? true\n                    : operation == \"unfold\" ? false\n                    : ! wasFolded\n                );\n                me.targetNode.style.display = (\n                    isFolded ? \"none\"\n                    : me.originalDisplayProp\n                );\n\n                me.getTriggers(\"fold\").forEach(tgg => {\n                    const {foldedClass, unfoldedClass} = tgg.options;\n                    if (foldedClass) tgg.targetNode.classList[\n                        isFolded ? \"add\"\n                        : \"remove\"\n                    ](foldedClass);\n                    if (unfoldedClass) tgg.targetNode.classList[\n                        isFolded ? \"remove\"\n                        : \"add\"\n                    ](unfoldedClass);\n                });\n\n                me.getTriggers([\"addItem\", \"removeItem\"]).map(\n                    isFolded ? tgg => tgg.disable()\n                    : tgg => tgg.enable()\n                );\n            };//}}}\n        };\n    };\n};\n","// src/decorators/export_to_target.deco.js\n// =======================================\n\nexport const export_to_target = function export_to_target_decorator(method, {kind}) {\n    if (kind == \"method\") {\n        return async function export_mtd({target, ...options}={}) {\n            const me = this;\n            const value = await method.call(me, options);\n            try {\n                await target.import({data: value});\n            } catch (error) {\n                // target not provided or invalid\n            };\n            return value;\n        };\n    };\n};\n","// src/decorators/import_from_target.deco.js\n// =========================================\n\nexport const import_from_target = function import_from_target_decorator(method, {kind}) {\n    if (kind == \"method\") {\n        return async function import_mtd({target, data, ...options}={}) {\n            const me = this;\n            try {\n                data = await target.export();\n            } catch (error) {\n                // target not provided or invalid\n            };\n            return await method.call(me, {data, ...options});\n        };\n    };\n};\n","// types/form.type.js\n// ==================\n\nimport {SmarkField} from \"../lib/component.js\";\nimport {action} from \"./trigger.type.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {getRoots, parseJSON} from \"../lib/helpers.js\";\n\n@foldable\nexport class form extends SmarkField {\n    async render() {//{{{\n        const me = this;\n        me.originalDisplayProp = me.targetNode.style.display;\n        // Enhance childs:\n        for (\n            const node\n            of getRoots(me.targetNode, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            if (!! newItem?._isField) {\n                if (me.children[newItem.name] !== undefined) throw me.renderError(\n                    'REPEATED_FIELD_NAME'\n                    , `Field name '${newItem.name}' used more than once in this form level.`\n                );\n                me.children[newItem.name] = newItem;\n                newItem.updateId();\n            };\n        };\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        const me = this;\n        return Object.fromEntries(\n            await Promise.all(Object.entries(me.children).map(\n                async ([key, child])=>[key, await child.export()]\n            ))\n        );\n    };//}}}\n    @action\n    @import_from_target\n    async import({data = {}, focus = true} = {}) {//{{{\n        const me = this;\n        const dataConstructor = Object(data).constructor;\n        if (\n            dataConstructor !== {}.constructor // Not a plain object\n            && ! (data = parseJSON(data))      // Neither a (valid) JSON string\n        ) throw me.renderError(\n            'FORM_NOT_PLAIN_OBJECT'\n            , `Expected plain object or vailid JSON for form import, ${dataConstructor.name} given.`\n        );\n        const retv = Object.fromEntries(\n            await Promise.all(\n                Object.entries(me.children).map(\n                    async ([key, target]) => {\n                        // Could have used target.then(...) but, event\n                        // components' import() method SHOULD be async, it\n                        // would have failed in case it's not.\n                        // Forcing it to be async is not possible because\n                        // transpilers would break this check.\n                        // ...and, IMHO, this approach is better than a dirty\n                        // Promise.resolve(...)\n                        const value = await target.import({data: data[key], focus});\n                        return [key, value];\n                    }\n                )\n            )\n        );\n        if (focus) me.focus();\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of Object.values(me.children)\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async clear({focus} = {}) {//{{{\n        const me = this;\n        return await me.import({data: {}, focus});\n    };//}}}\n};\n","// types/list.decorators/smartdisabling.deco.js\n// ============================================\n\nasync function updateTriggers(context) {\n    await context.rendered;\n    for (const tg of context.getTriggers([\"removeItem\", \"addItem\"])) {\n        tg.targetNode.disabled = (\n            tg.options.action == \"removeItem\" ? (\n                context.children.length <= context.min_items\n                && tg.options.failback != \"clear\" // Unless clearing function\n            )\n            : context.children.length >= context.max_items\n        );\n    };\n};\n\nexport const smartdisabling = function list_smartdisabling_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class smartdisablingClass extends target {\n            async render(...args) {//{{{\n                const retv = await super.render(...args);\n                const me = this;\n                setTimeout(()=>updateTriggers(me), 1);\n                    // FIXME (Why do we need to delay it?)\n                    // Even more: Why it is even needed with min_items >= 1??\n\n                return retv;\n            };//}}}\n        };\n    } else if (kind == \"method\") {\n        return async function smartdisablingMethod(...args) {\n            const me = this;\n            const retv = await target.call(me, ...args);\n            updateTriggers(me);\n            return retv;\n        };\n    };\n};\n","\nconst sym_mux = Symbol(\"smart_mutex\");\n\nclass Mutex {\n    constructor() {\n        this.mtx = Promise.resolve();\n    };\n    lock() {\n        // Sync operation:\n        let nextResolve;\n        const nextMtx = new Promise(resolve => {\n            nextResolve = () => resolve();\n        });\n        const currMtx = this.mtx;\n        this.mtx = nextMtx;\n        // Async behaviour:\n        return currMtx.then(function unlock() {\n            return nextResolve\n        });\n    };\n}\n\nexport const mutex = function method_mutex_decorator(muxName) {\n    return function mutex_decorator(target, {kind}) {\n        if (kind == \"method\") {\n            return async function muxed_target(...args) {\n                const me = this;\n                if (! me[sym_mux]) me[sym_mux] = {};\n                if (! me[sym_mux][muxName]) me[sym_mux][muxName] = new Mutex();\n                const unlock = await me[sym_mux][muxName].lock(); // Await previous muxed call (if any)\n                let err, retv;\n                try {\n                    retv = await target.call(me, ...args);\n                } catch (error) {\n                    err = error;\n                };\n                unlock();\n                if (err) throw err;\n                return retv;\n            };\n\n        };\n    };\n};\n","// types/list.decorators/sortable.deco.js\n// ======================================\n\nimport {mutex} from \"../../decorators/mutex.deco.js\";\n\nexport const sortable = function list_sortable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class sortableTarget extends target {\n            async render(...args) {//{{{\n                const retv = await super.render(...args);\n                const me = this;\n\n                me.sortable = !! me.options.sortable;\n                me.templates.item.setAttribute(\"draggable\", me.sortable);\n                me.children.forEach(c=>c.targetNode.setAttribute(\"dragable\", me.sortable));\n                if (me.sortable) {\n                    let dragSource = null;\n                    let dragDest = null;\n                    me.targetNode.addEventListener(\"dragstart\", e => {\n                        if (dragSource === null) {\n                            dragSource = e.target\n                            e.stopPropagation();\n                        } else {\n                            // Single dragging at a time.\n                            e.preventDefault();\n                        };\n                    });\n                    me.targetNode.addEventListener(\"dragover\", e => e.preventDefault());\n                    me.targetNode.addEventListener(\"drop\", e => {\n                        if (! dragSource) return; // Already dropped\n                        let target = e.target;\n                        while (\n                            target.parentElement\n                            && target.parentElement != dragSource.parentElement\n                        ) target = target.parentElement;\n                        dragDest = target;\n                    });\n                    me.targetNode.addEventListener(\"dragend\", async () => {\n                        if (dragDest)  await me.move({\n                            from: me.getComponent(dragSource),\n                            to: me.getComponent(dragDest),\n                        });\n                        dragSource = null;\n                        dragDest = null;\n                    });\n                };\n\n                return retv;\n            };//}}}\n            @mutex(\"list_mutating\")\n            async move(options = {}) {//{{{\n                const me = this;\n                let {\n                    from,\n                    to,\n                } = options;\n\n                // // FIXME: Avoid nested sortables to interact.\n                // console.log({from, to}); // <--- See this!!!\n\n                //\n                // TODO: Convert to action!!!\n                //\n                if (\n                    to === null // Dropped outside\n                    || from === null // (Shouldn't happen)\n                ) return;\n                const fromi = Number(from?.name);\n                const toi = Number(to?.name);\n                if (fromi == toi) {\n                    return;\n                } else if (fromi < toi) {\n                    const newChunk = [\n                        ...me.children.slice(fromi + 1, toi + 1),\n                        me.children[fromi],\n                    ];\n                    me.children.splice(fromi, toi - fromi + 1, ...newChunk);\n                } else if (fromi > toi) {\n                    const newChunk = [\n                        me.children[fromi],\n                        ...me.children.slice(toi, fromi),\n                    ];\n                    me.children.splice(toi, fromi - toi + 1, ...newChunk);\n                };\n                const inc = fromi < toi ? 1 : -1;\n                const moveMethod = inc > 0 ? \"after\" : \"before\";\n                to.targetNode[moveMethod](from.targetNode);\n                me.renum();\n            };//}}}\n        };\n    };\n};\n","// types/list.type.js\n// ==================\n\n// TODO:\n// =====\n//\n// ðŸ‘‰ Keep first item in place:\n//    -------------------------\n//     \n//    For lists allowing 0 items, make first element disabled and not visible\n//    instead of completely removing from DOM.\n//\n//    This would avoid lots of visual layout issues.\n//\n\n\nimport {SmarkField} from \"../lib/component.js\";\nimport {smartdisabling} from \"./list.decorators/smartdisabling.deco.js\";\nimport {action} from \"./trigger.type.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {sortable} from \"./list.decorators/sortable.deco.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {mutex} from \"../decorators/mutex.deco.js\";\nimport {makeRoom, parseJSON} from \"../lib/helpers.js\";\n\n\n// Helpers:\n// --------\n\nfunction makeNonNavigable(target) {//{{{\n    if (\n        // Tabindex not explicitly defined:\n        target.getAttribute(\"tabindex\") === null\n    ) {\n        target.setAttribute(\"tabindex\", \"-1\");\n    };\n};//}}}\n\n\n\n// List component type:\n// --------------------\n\n@foldable\n@sortable\n@smartdisabling\nexport class list extends SmarkField {\n    async render () {//{{{\n        const me = this;\n        me.originalDisplayProp = me.targetNode.style.display;\n\n        me.min_items = Math.max(0,\n            typeof me.options.min_items == \"number\" ? me.options.min_items\n            : 1\n        );\n        me.max_items = Math.max(me.min_items,\n            typeof me.options.max_items == \"number\" ? me.options.max_items\n            : Infinity\n        );\n        me.children = [];\n        me.templates = {};\n        for (const child of [...me.targetNode.children]) {\n            const {role = \"item\"} = parseJSON(child.getAttribute(\"data-smark\")) || {};\n            switch (role) {\n                case \"empty_list\":\n                ///case \"header\":\n                case \"separator\":\n                case \"last_separator\":\n                ///case \"padding\":\n                ///case \"footer\":\n                    child.setAttribute(\"data-role\", role);\n                case \"item\": // (Default)\n                    if (me.templates[role] !== undefined) throw me.renderError(\n                        'LIST_DUPLICATE_TEMPLATE'\n                        , `Repated list template role ${role}`\n                    );\n                    me.templates[role] = child;\n                    me.templates[role].remove();\n                break;\n            };\n        };\n        if (! me.templates.last_separator) {\n            me.templates.last_separator = me.templates.separator; // (If any)\n        };\n        if (me.targetNode.children.length) {\n            const {role = \"item\"} = parseJSON(\n                me.targetNode.children[0].getAttribute(\"data-smark\")\n            ) || {};\n            throw me.renderError(\n                'LIST_UNKNOWN_TEMPLATE_ROLE'\n                , `Unknown list template role ${role}`\n            );\n        };\n        if (\n            me.templates.item.querySelector(\"[id]\") !== null // Contains IDs\n        ) throw me.renderError(\n            'LIST_CONTAINS_ID'\n            , `List components are not allowed to contain elements with 'id' attribute`\n        );\n        const tplOptions = me.getNodeOptions(\n            me.templates.item\n            , {\n                type: me.options.of, // Allow to specify items type from list declaration.\n            }\n        );\n        if (\n            me.options.of\n            && tplOptions.type != me.options.of\n        ) throw me.renderError(\n            'LIST_ITEM_TYPE_MISSMATCH'\n            , `List item type missmatch`\n        );\n\n        // onRendered tweaks:\n        me.root.onRendered(async ()=>{\n            for(let i=0; i<me.min_items; i++) await me.addItem();\n\n            // Initialize \"count\" actions and reinject empty_list template:\n            if (me.min_items == 0) me.renum();\n\n            // Let screen readers know lists may change.\n            me.targetNode.setAttribute(\"aria-live\", \"polite\");\n            me.targetNode.setAttribute(\"aria-atomic\", \"true\");\n        });\n        return;\n    };//}}}\n    onTriggerRender({action, origin, context, ...rest}) {//{{{\n        switch (action) {\n            case \"addItem\":\n            case \"removeItem\":\n                if (\n                    // Placed inside\n                    (1 + [...origin.parents].findIndex(p=>Object.is(p, context)))\n                    && origin.options.hotkey\n                ) {\n                    // Skip them in keyboard navigation.\n                    makeNonNavigable(origin.targetNode);\n                };\n                break;\n        };\n    };//}}}\n    @mutex(\"list_mutating\")\n    @action\n    @export_to_target\n    async export() {//{{{\n        const me = this;\n        const list = [];\n        const emptyChilds = [];\n        const stripEmpties = ! me.inherittedOption(\"exportEmpties\", false);\n        for (const child of me.children) {\n            if (stripEmpties && await child.isEmpty()) {\n                if (list.length < me.min_items) emptyChilds.push(child);\n                continue;\n            };\n            list.push(await child.export())\n        };\n        for (let i=0; list.length < me.min_items; i++) {\n            list.push(await emptyChilds[i].export());\n        };\n        return list;\n    };//}}}\n    @action\n    @import_from_target\n    async import({data = [], focus} = {}) {//{{{\n        const me = this;\n        // Auto-update in case of scalar to array template upgrade:\n        if (! (data instanceof Array)) data = [data];\n        // Load data:\n        for (\n            let i = 0;\n            i < Math.min(data.length, me.max_items); // Limit to allowed items\n            i++\n        ) {\n            if (me.children.length <= i) await me.addItem(); // Make room on demand\n            await me.children[i].import({data: data[i], focus});\n        };\n        // Remove extra items if possible (over min_items):\n        for (\n            let i = Math.max(data.length, me.min_items);\n            i < me.children.length;\n        ) await me.removeItem();\n        // Report if data doesn't fit:\n        if (data.length > me.max_items) {\n            me.emit(\"error\", {\n                code: 'LIST_IMPORT_OVERFLOW',\n                message: `Trying to import array greater than list's max_items. Data beyond max_items ignored.`,\n                context: me,\n                data,\n                options: me.options,\n            });\n        };\n        // Clear items over imported data if min_items is greater:\n        for (\n            let i = data.length;\n            i < me.children.length; // (Due to min_items)\n            i++\n        ) me.children[i].clear();\n        if (focus) me.focus();\n        return; // await me.export();\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    @smartdisabling\n    async addItem(options = {}) {//{{{\n        const me = this;\n        // Parameters checking and resolution:{{{\n        let {\n            action,\n            origin = null, // (Internal call)\n            context = me,  // (Internal call)\n            target,\n            position = \"after\",\n            autoscroll,   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n            failback,\n        } = options;\n        if (position != \"after\" && position != \"before\") throw me.renderError(\n            'LIST_WRONG_ADDITEM_POSITION'\n            , `Invalid value for addItem() position property: ${position}`\n        );\n        if (me.children.length >= me.max_items) {\n            switch (failback) {\n                case \"none\":\n                    break;\n                case \"throw\":\n                default:\n                    me.emit(\"error\", {\n                        code: 'LIST_MAX_ITEMS_REACHED',\n                        message: `Cannot add items over max_items boundary`,\n                        options,\n                    });\n            };\n            return;\n        };\n        if (me.children.length && ! target) target = ( // Auto target:\n            position == \"before\" ?  me.children[0] // Insert at the beginning\n            : me.children[me.children.length - 1]  // Append at the end\n        );\n        //}}}\n        // DOM element creation:{{{\n        const newItemTarget = me.templates.item.cloneNode(true);\n        //}}}\n        // addItem event emitting:{{{\n        const onRenderedCbks = [];\n            // Allow for handy callback instead of two separate event handlers\n        await me.emit(\"addItem\", {\n                action,\n                origin,\n                context,\n                target,  // <--- Effective target.\n                position,\n                newItemTarget,\n                options, // <- Original options (including target)\n                onRendered: cbk => onRenderedCbks.push(cbk),\n        });\n        //}}}\n        // Child component creation and insertion:{{{\n        let newItem;\n        if (! me.children.length) {\n            me.targetNode.appendChild(newItemTarget);\n            newItem = await me.enhance(newItemTarget, {type: \"form\", name: 0});\n            await newItem.rendered;\n            me.children.push(newItem);\n            newItem.name = 0;\n        } else {\n            me.children = (await Promise.all(\n                me.children.map(async (child, i)=>{\n                    if (! child.targetNode.isSameNode(target.targetNode)) return child;\n                    if (position == \"after\") {\n                        child.targetNode.after(newItemTarget);\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        return [child, newItem]; // Right order, flatted later...\n                    } else {\n                        child.targetNode.before(newItemTarget);\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        return [newItem, child]; // Right order, flatted later...\n                    };\n                })\n            ))\n                .flat()\n            ;\n        };\n        me.renum();\n        //}}}\n        // Autoscroll handling:{{{\n        if (autoscroll == \"elegant\" && !! newItem) {\n            makeRoom(newItem.targetNode, - newItem.offsetHeight);\n        } else {\n            const moveTarget = (\n                ! newItem ? null\n                : autoscroll == \"self\" ? newItem\n                : autoscroll == \"parent\" ? newItem.parent\n                : null\n            );\n            if (moveTarget) moveTarget.moveTo();\n        };\n        //}}}\n        // Execute \"onRendered\" callbacks:{{{\n        onRenderedCbks.forEach(cbk=>cbk(newItem));\n        //}}}\n        if (me.renderedSync) newItem.focus();\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    @smartdisabling\n    async removeItem(options = {}) {//{{{\n        const me = this;\n        let {\n            action,\n            origin = null, // (Internal call)\n            context = me,  // (Internal call)\n            target,\n            autoscroll,   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n            keep_non_empty,\n            failback,\n        } = options;\n        if (! target) {\n            if (keep_non_empty) for (\n                const t of [...me.children]\n                .reverse() // Pick last first\n            ) if (await t.isEmpty()) {\n                target = t;\n                break;\n            };\n            if (! target) {\n                target = me.children[me.children.length - 1];\n                keep_non_empty = false;\n                // Allow non empty removal as last chance if no target\n                // specified.\n            };\n        };\n        const targets = (\n            target instanceof Array ? target\n            : [target]\n        );\n        for (const currentTarget of [...targets].reverse()) {\n            if (me.children.length <= me.min_items) {\n                switch (failback) {\n                    case \"none\":\n                        break;\n                    case \"clear\":\n                        await currentTarget.clear();\n                        return;\n                    case \"throw\":\n                    default:\n                        me.emit(\"error\", {\n                            code: 'LIST_MIN_ITEMS_REACHED',\n                            message: `Cannot remove items under min_items boundary`,\n                            options,\n                        });\n                        return;\n                };\n            };\n            if (keep_non_empty && ! await currentTarget.isEmpty()) continue;\n            let oldItem = null;\n            let newFocusPosition = null;\n            const newChildren = me.children\n                .filter((child, i, all)=>{\n                    if (child.targetNode.isSameNode(currentTarget.targetNode)) {\n                        if (autoscroll == \"elegant\") {\n                            makeRoom(child.targetNode, child.targetNode.offsetHeight);\n                        } else {\n                            const moveTarget = (\n                                autoscroll == \"self\" ? child\n                                : autoscroll == \"parent\" ? child.parent\n                                : null\n                            );\n                            if (moveTarget) moveTarget.moveTo();\n                        };\n\n                        oldItem = child;\n\n                        newFocusPosition = (\n                            (all.length -i > 1) ? newFocusPosition = i // More above\n                            : i == 0 ? null           // No items left\n                            : i - 1                   // Removing last item\n                        );\n\n                        return false;\n                    };\n                    return true;\n                })\n            ;\n            // removeItem event emitting:{{{\n            const onRemovedCbks = [];\n                // Allow for handy callback instead of two separate event handlers\n            await me.emit(\"removeItem\", {\n                action,\n                origin,\n                context,\n                target: currentTarget,  // <--- Effective target.\n                oldItem,                 // Child going to be removed.\n                oldItemTarget: oldItem.targetNode, // Its target (analogous to addItem event).\n                options,\n                onRemoved: cbk => onRemovedCbks.push(cbk),\n            });\n            //}}}\n\n            oldItem.targetNode.remove();\n            me.children = newChildren;\n            me.renum();\n\n            // Execute \"onRemoved\" callbacks:{{{\n            onRemovedCbks.forEach(cbk=>cbk());\n            //}}}\n\n            if (newFocusPosition !== null) {\n                me.children[newFocusPosition].focus();\n            };\n\n        };\n\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of me.children\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async clear({focus} = {}) {//{{{\n        const me = this;\n        return await me.import({data: [], focus});\n    };//}}}\n    @action\n    count({delta = 0} = {}) {//{{{\n        // Return number of children.\n        // But also it's sole existence allow reinjecting contents to it.\n        const me = this;\n        return me.children.length + Number(delta);\n    };//}}}\n    @action\n    position({target, offset = 1} = {}) {//{{{\n        return Number(target?.name) + Number(offset);\n    };//}}}\n    renum(){//{{{\n        const me = this;\n\n        // Update child index:\n        for (const i in me.children) {\n            me.children[i].name = i;\n            me.children[i].updateId();\n        };\n\n        // Handle separators:\n        if (\n            !! me.templates.separator\n            || !! me.templates.last_separator\n        ) for (const i in me.children) {\n\n            const isLastNode = i >= me.children.length - 1;\n            const sepRole = (\n                i <= 0 ? null\n                : isLastNode ? \"last_separator\"\n                : \"separator\"\n            );\n\n            const currentNode = me.children[i].targetNode;\n            const prevNode = currentNode.previousElementSibling;\n            const prevNode_role = prevNode && prevNode.getAttribute(\"data-role\");\n            if (prevNode_role !== sepRole) {\n                if (!! prevNode_role) prevNode.remove();\n                const sepTemplate = me.templates[sepRole];\n                if (!! sepRole && !! sepTemplate) currentNode.parentElement.insertBefore(sepTemplate.cloneNode(true), currentNode);\n            };\n            if (isLastNode) { // LastItem\n                const nextNode = currentNode.nextElementSibling;\n                if (!! nextNode) nextNode.remove();\n            };\n\n        };\n\n        // Handle empty_list template:\n        if (me.templates.empty_list) {\n            if (me.children.length) {\n                me.templates.empty_list.remove(); // (from DOM)\n            } else {\n                me.targetNode.appendChild(me.templates.empty_list);\n            };\n        };\n\n        me.getTriggers(\"position\").forEach(tgg=>{\n            const me = this;\n            const args = tgg.getTriggerArgs();\n            tgg.targetNode.innerText = me.position(args);\n        });\n        me.getTriggers(\"count\").forEach(tgg=>{\n            const me = this;\n            const args = tgg.getTriggerArgs();\n            tgg.targetNode.innerText = me.count(args);\n        });\n    };//}}}\n};\n","// types/input.type.js\n// ===================\nimport {form} from \"./form.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nexport class input extends form {\n    async render() {//{{{\n        const me = this;\n        me.isSingleton = ! (\n            me.targetNode.tagName === \"INPUT\"\n            || me.targetNode.tagName === \"SELECT\"\n            || me.targetNode.tagName === \"TEXTAREA\"\n        );\n        me.isCheckbox = (\n            ! me.isSingleton\n            && String(me.targetNode.type).toLowerCase() == \"checkbox\"\n        );\n        if (me.isSingleton) {\n            await super.render();\n            const sons = Object.values(me.children);\n            if (sons.length != 1) throw me.renderError(\n                'NOT_A_SINGLETON'\n                , `Singleton forms are only allowed to contain exactly one`\n                + ` data field but ${sons.length} found.`\n            );\n            const son = sons[0];\n            if (me.options.type !== son.options.type) throw me.renderError(\n                'SINGLETON_TYPE_MISMATCH'\n                , `Singleton type (${me.options.type})`\n                + ` does not match child field type (${son.options.type}).`\n            );\n            me.targetFieldNode = son.targetNode;\n        } else {\n            me.targetFieldNode = me.targetNode;\n        };\n        return;\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        const me = this;\n        return (\n            me.isSingleton ? Object.values(await super.export())[0]\n            : me.isCheckbox ? !!me.targetNode.checked\n            : me.targetNode.value\n        );\n    };//}}}\n    @action\n    @import_from_target\n    async import({data = \"\", focus = true} = {}) {//{{{\n        const me = this;\n        if (\n            typeof data === \"object\"\n            && me.options.type === \"input\" // Not in a derivated field types\n        ) {\n            const isTextarea = me.targetFieldNode.tagName.toUpperCase() === \"TEXTAREA\";\n            data = (\n                isTextarea ? JSON.stringify(data, null, 4) // Pretty print\n                : JSON.stringify(data) // Compact print\n            );\n        };\n        if (me.isSingleton) {\n            return await super.import({data: Object.fromEntries(\n                [[Object.keys(me.children)[0], data]]\n            ), focus});\n        } else if (me.isCheckbox) {\n            me.targetNode.checked = !! data;\n        } else {\n            me.targetNode.value = data;\n        };\n        if (focus) me.focus();\n        return me.targetNode.value;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = (\n            me.isCheckbox ? \"\" // Do not consider checkboxes.\n            : await me.export()\n        );\n        return ! value.trim().length;\n            // Native input's value type is always a string.\n    };//}}}\n    @action\n    async clear({focus} = {}) {//{{{\n        const me = this;\n        await me.import({focus});\n    };//}}}\n};\n","// types/number.type.js\n// ====================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nexport class number extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"number\").toLowerCase() != \"number\"\n        ) throw me.renderError(\n            'NOT_A_NUMBER_FIELD'\n            , `Number inputs require an INPUT tag of type \"number\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"number\"; // Autofill\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        return (\n            data.length && ! isNaN(data) ? Number(data)\n            : null\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import({data = null, focus = true} = {}) {//{{{\n        const me = this;\n        const typename = typeof data;\n        if (me.isSingleton) return await super.import({data, focus}); // Overload only inner field\n        const retv =  await super.import({data:(\n            typename == \"number\" ? data\n            : typename == \"string\"\n                && data.length\n                && ! isNaN(data)\n                ? Number(data)\n            : null\n        ), focus});\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n","// types/date.type.js\n// ==================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nconst re_timePart = /T.*/;\nfunction parseDateStr(str) {//{{{\n    // Accept \"YYYYMMDD\":\n    if (str.length == 8) return new Date([\n        str.substring(0, 4),\n        str.substring(4, 6),\n        str.substring(6, 8),\n    ].join(\"-\"));\n\n    // Accept \"YYYY-MM-DD\" (like date inputs)\n    // > new Date(\"2023-11-30\")\n    // 2023-11-30T00:00:00.000Z\n    // ...but don't accept if not zero-padded:\n    // > new Date(\"2023-11-3\")\n    // 2023-11-02T23:00:00.000Z\n    if (\n        str.length == 10\n        && str[4] == \"-\"\n        && str[7] == \"-\"\n    ) return new Date(str);\n\n    // Also don't accept other locale dependant formats:\n    // > new Date(\"11/30/2023\")\n    // 2023-11-29T23:00:00.000Z\n\n    return NaN;\n};//}}}\nfunction ISODate(value) {//{{{\n    return value.toISOString().replace(re_timePart, \"\");\n};//}}}\nexport class date extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"date\").toLowerCase() != \"date\"\n        ) throw me.renderError(\n            'NOT_A_DATE_FIELD'\n            , `Date inputs require an INPUT tag of type \"date\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"date\"; // Autofill\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        if (! data.length) return null;\n        const value = parseDateStr(data);\n        return (\n            isNaN(value) ? null\n            : ISODate(value)\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import({data = null, focus = true} = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await super.import({data, focus}); // Overload only inner field\n        const value = (\n            data instanceof Date ? data // Accept Date instance\n            : typeof data == \"number\" ? new Date(data) // Accept epoch\n            : ! data || (typeof data != \"string\") ? NaN // Reject nullish\n            : parseDateStr(data) // Handle strings\n        );\n        const retv = await super.import({data:(\n            isNaN(value) ? null\n            : ISODate(value)\n        ), focus});\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n","// types/radio.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {randomId} from \"../lib/helpers.js\";\nexport class radio extends input {\n    constructor(...args) {\n        super(...args);\n        const me = this;\n        const singleton = me.parent.children[me.name];\n        if (singleton) {\n            me.targetNode.setAttribute(\"name\", singleton.sharedNodeName);\n            singleton.radioButtons.push(me.targetNode);\n            return {}; // Not a field.\n        } else {\n            // Provide unique name for DOM navigation to work properly:\n            me.sharedNodeName = randomId();\n            me.targetNode.setAttribute(\"name\", me.sharedNodeName);\n            me.radioButtons = [\n                me.targetNode\n            ];\n        };\n        return me;\n    };\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"radio\").toLowerCase() != \"radio\"\n        ) throw me.renderError(\n            'NOT_A_RADIO_FIELD'\n            , `Radio inputs require an INPUT tag of type \"radio\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"radio\"; // Autofill\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        return this.radioButtons.find(r=>r.checked)?.value || null;\n    };//}}}\n    @action\n    @import_from_target\n    async import({data = null, focus = true} = {}) {//{{{\n        const selected = this.radioButtons.find(r=>r.value === data);\n        if (selected) selected.checked = true;\n        if (focus) this.focus();\n    };//}}}\n    async isEmpty() {//{{{\n        return ! (1 + this.radioButtons.findIndex(r=>r.checked));\n    };//}}}\n};\n\n","// types/color.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {parseJSON} from \"../lib/helpers.js\";\nconst re_color = /^#([a-f0-9]{3}){1,2}$/i;\nconst disabled_style = `\n    opacity: .5;\n    background: repeating-linear-gradient(\n            45deg,\n            black,\n            black 10px,\n            white 10px,\n            white 20px\n        ),\n        black;\n    background-blend-mode: difference;\n`;\nexport class color extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n\n        if (me.isSingleton) return; // (Only for real field)\n\n        // Check targetField's type attribute:\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"color\").toLowerCase() != \"color\"\n        ) throw me.renderError(\n            'NOT_A_COLOR_FIELD'\n            , `Color inputs require an INPUT tag of type \"color\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"color\"; // Autofill\n\n        // Iniitialize me.isDefined flag:\n        const valueAttr = me.targetFieldNode.getAttribute(\"value\");\n        me.isDefined = (\n            valueAttr !== null         // value property not defined\n            && valueAttr.trim() !== \"\" // value property defined (string)\n        );\n\n        // Remember original \"style\" attribute and update if appropriate:\n        me.defaultStyleAttr = me.targetFieldNode.getAttribute(\"style\") + \";\";\n        if (! me.isDefined) me.targetFieldNode.setAttribute(\n            \"style\"\n            , me.defaultStyleAttr + disabled_style\n        );\n\n        // Handle me.isDefined set:\n        const resetDefined = ev=>{\n            if (\n                ev.code    !== \"Enter\"\n                && ev.Code !== \"Space\"\n                && ev.code !== undefined // ev.type must be \"click\" or \"change\"\n                    // && ev.type !== \"click\" // Click event\n                    // && ev.type !== \"change\" // Change event\n            ) return;\n            me.isDefined = true;\n            me.targetFieldNode.setAttribute(\"style\", me.defaultStyleAttr);\n        };\n        me.targetFieldNode.addEventListener(\"keydown\", resetDefined);\n        me.targetFieldNode.addEventListener(\"click\", resetDefined);\n        me.targetFieldNode.addEventListener(\"change\", resetDefined);\n\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        let data = await super.export(...args);\n        if (! me.isSingleton) data = (\n            me.isDefined && data.match(re_color) ? data.toLowerCase()\n            : null\n        );\n        return data;\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import({data = null, focus = true} = {}) {//{{{\n        const me = this;\n        if (\n            ! me.isSingleton // Only for real field\n        ) {\n            if (\n                data === null              // Explicit null value\n                || ! data.match(re_color)  // Invalid color value\n            ) {\n                me.isDefined = false;\n                me.targetFieldNode.setAttribute(\n                    \"style\"\n                    , me.defaultStyleAttr + disabled_style\n                );\n            } else {\n                me.isDefined = true;\n                me.targetFieldNode.setAttribute(\"style\", me.defaultStyleAttr);\n            };\n        };\n        const value = await super.import({data, focus});\n        return (\n            me.isDefined ? value\n            : null\n        );\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n\n","// SmarkForm.js\n// ============\n\nimport {createType} from \"./lib/component.js\";\nimport {hotKeys_handler} from \"./lib/hotkeys.js\";\n\n// Import core component types and event handlers:\nimport {trigger, onTriggerClick} from \"./types/trigger.type.js\";\nimport {label} from \"./types/label.type.js\";\nimport {form} from \"./types/form.type.js\";\nimport {list} from \"./types/list.type.js\";\nimport {input} from \"./types/input.type.js\";\nimport {number} from \"./types/number.type.js\";\nimport {date} from \"./types/date.type.js\";\nimport {radio} from \"./types/radio.type.js\";\nimport {color} from \"./types/color.type.js\";\n\n\n// Load core component types:\nfor (const [name, controller] of Object.entries({\n    trigger,\n    label,\n    form,\n    list,\n    input,\n    number,\n    date,\n    radio,\n    color,\n})) createType(name,controller);\n\n\nclass SmarkForm extends form {\n    constructor(\n        targetNode\n        , {\n            customActions = {},\n            ...formOptions\n        } = {}\n    ) {\n        const options = {\n            ...formOptions,\n            name: \"\",\n            type: \"form\",\n        };\n        super(\n            targetNode\n            , options\n            , null // (Root has no parent)\n        );\n        const me = this;\n        me.setNodeOptions(me.targetNode, options);\n        me.actions = {\n            ...me.actions,\n            ...Object.fromEntries(\n                Object.entries(customActions)\n                    .map(([name, ctrl])=>[name, ctrl.bind(me)])\n            ),\n        };\n        me.targetNode.addEventListener(\n            \"click\"\n            , onTriggerClick.bind(me)\n            , true\n        );\n        new hotKeys_handler(me);\n    };\n    async render() {\n        const me = this;\n        me.targetNode.setAttribute(\"aria-busy\", \"true\");\n        await super.render();\n        me.targetNode.setAttribute(\"aria-busy\", \"false\");\n    };\n};\n\nSmarkForm.createType = createType;\n\nexport default SmarkForm;\n\n"],"names":["sym_local_events","Symbol","sym_all_events","re_actionEvHandler","re_localEvHandler","re_allEvHandler","registerEvHandler","evList","evType","evHandler","me","this","has","set","get","push","bind","events","events_decorator","target","_ref","kind","eventEnebledTarget","constructor","optionsSrc","options","onOptionCallbacks","key","value","Object","entries","match","substring","_len","arguments","length","args","Array","_key","super","ImRoot","is","root","Map","onLocal","onAll","on","evt","handler","listenLevel","emit","evData","handlers","defaultPrevented","propagationStopped","preventDefault","stopPropagation","legacy","disEnhance","targetNode","tagName","toLowerCase","addEventListener","event","componentTypes","sym_smart","re_valid_typename_chars","re_has_wildcards","wild2regex","wname","RegExp","replace","errors","renderError","Error","code","message","path","concat","stack","split","slice","join","inferType","node","parentComponent","type","String","getAttribute","isSingleton","_SmarkComponent","SmarkComponent","undefined","property_name","_objectWithoutProperties","_excluded","parent","validName","nameGenerator","counter","names","n0","trim","actions","selector","types","setNodeOptions","parents","iterator","current","autoId","inherittedOption","setRendered","genId","p","onRenderedTasks","renderedSync","rendered","Promise","resolve","children","render","task","setTimeout","onRendered","cbk","getNodeOptions","defaultOptions","dataset","_objectSpread","opt","JSON","parse","err","action","stringify","enhance","ctrl","getComponent","_target$parentElement","parentElement","closest","getPath","map","name","reverse","find","base","parts","filter","x","firstWildcardPos","findIndex","re_pattern","pivotPath","restPath","pivot","pivotChilds","_ref2","child","_ref3","flat","Infinity","reduce","optName","defaultValue","moveTo","id","document","location","hash","window","history","pushState","pathname","getTriggers","actionNames","myCurrentActions","actionKeys","Set","returnAll","tgg","querySelectorAll","getTriggerArgs","context","updateId","newId","values","focus","fname","targetFieldNode","_SmarkComponent2","_initClass","_applyDecs","c","SmarkField","_isField","hasOwnProperty","setAttribute","createType","controller","prototype","hotKeys_handler","form","revealed","onKeydown","onKeyup","onFocusout","onFocusin","ev","reveal","ctrlKey","targettedTrigger","t","hotkey","click","removeAttribute","component","activeContexts","activeContextsSet","candidateTriggers","lv","tg","sort","ta","tb","usedKeys","candidate","disabled","add","beforeEvent","afterEvent","action_decorator","targetMtd","addInitializer","registerAction","trigger","_triggerArgs$context","triggerArgs","onTriggerRender","disable","enable","_me$options","actionSpec","contextPath","targetPath","otherOptions","actionName","targetType","_p$parent","isSameNode","origin","async","onTriggerClick","triggerComponent","mtd","data","getRoots","isTop","parentNode","n","e","makeRoom","element","pixels","direction","scrollHeight","clientHeight","maxScroll","scrollTop","randomId","Math","random","toString","parseJSON","str","label","allow_select","labelArgs","getLabelArgs","style","_excluded2","candidates","found","childName","targetComponent","foldable","foldable_decorator","_foldableTarget","_initProto","foldableTarget","retv","fold","operation","folded","wasFolded","display","isFolded","originalDisplayProp","forEach","foldedClass","unfoldedClass","classList","export_to_target","export_to_target_decorator","method","export_mtd","call","import","error","import_from_target","import_from_target_decorator","import_mtd","export","_form","newItem","fromEntries","all","dataConstructor","await","isEmpty","clear","updateTriggers","min_items","failback","max_items","_form2","smartdisabling","list_smartdisabling_decorator","smartdisablingClass","smartdisablingMethod","sym_mux","Mutex","mtx","lock","nextResolve","nextMtx","currMtx","then","unlock","mutex","method_mutex_decorator","muxName","mutex_decorator","muxed_target","sortable","list_sortable_decorator","_sortableTarget","_moveDecs","sortableTarget","templates","item","dragSource","dragDest","move","from","to","fromi","Number","toi","newChunk","splice","inc","moveMethod","renum","_list","makeNonNavigable","_exportDecs","_addItemDecs","_removeItemDecs","list","max","role","remove","last_separator","separator","querySelector","tplOptions","of","i","addItem","emptyChilds","stripEmpties","min","removeItem","position","autoscroll","newItemTarget","cloneNode","onRenderedCbks","after","before","appendChild","offsetHeight","moveTarget","keep_non_empty","targets","currentTarget","oldItem","newFocusPosition","newChildren","onRemovedCbks","oldItemTarget","onRemoved","count","delta","offset","isLastNode","sepRole","currentNode","prevNode","previousElementSibling","prevNode_role","sepTemplate","insertBefore","nextNode","nextElementSibling","empty_list","innerText","_list2","input","isCheckbox","sons","son","checked","isTextarea","toUpperCase","keys","_input","number","targetTag","isNaN","typename","_number","re_timePart","parseDateStr","Date","NaN","ISODate","toISOString","date","_date","radio","singleton","sharedNodeName","radioButtons","_this$radioButtons$fi","r","selected","_radio","re_color","disabled_style","color","valueAttr","isDefined","defaultStyleAttr","resetDefined","Code","_color","SmarkForm","customActions","formOptions"],"mappings":"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"}