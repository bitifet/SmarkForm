{"version":3,"file":"SmarkForm.esm.js","sources":["../src/lib/helpers.js","../src/lib/events.js","../src/lib/legacy.js","../src/lib/component.js","../src/lib/hotkeys.js","../src/types/trigger.type.js","../src/types/label.type.js","../src/decorators/foldable.deco.js","../src/decorators/export_to_target.deco.js","../src/decorators/import_from_target.deco.js","../src/types/form.type.js","../src/types/list.decorators/smartdisabling.deco.js","../src/decorators/mutex.deco.js","../src/types/list.type.js","../src/types/list.decorators/sortable.deco.js","../src/types/input.type.js","../src/types/number.type.js","../src/types/date.type.js","../src/types/radio.type.js","../src/types/color.type.js","../src/main.js"],"sourcesContent":["\"use strict\";\nexport function getRoots(target, selector){//{{{\n    const parent = target.parentNode;\n    const isTop = (\n        parent === null ? n => n === null\n        : n=>(n===null)||n.isSameNode(target)\n    );\n    return [\n        ...target.querySelectorAll(selector)\n    ].filter(\n        e=>isTop(e.parentNode.closest(selector))\n    );\n};//}}}\n\nexport function makeRoom(element, pixels) {//{{{\n    let parent = element.parentNode;\n    const direction = (\n        pixels >= 0 ? 1\n        : -1\n    );\n    while (parent) {\n        // Check if parent has vertical scroll bar\n        if (parent.scrollHeight > parent.clientHeight * direction) {\n            // Get the maximum amount that can be scrolled in this parent\n            var maxScroll = parent.scrollHeight - parent.clientHeight * direction;\n\n            // If desired amount is less than maximum scroll, perform scroll\n            if (pixels <= maxScroll * direction) {\n                parent.scrollTop += pixels;\n                return;\n            } else {\n              // If desired amount is greater than maximum scroll,\n              // scroll to maximum and subtract it from desired amount\n              parent.scrollTop = maxScroll;\n              pixels -= maxScroll;\n            };\n        };\n        parent = parent.parentNode;\n    };\n};//}}}\n\nexport function randomId() {//{{{\n    return Math.random().toString(36).substring(2);\n};//}}}\n\nexport function parseJSON(str) {//{{{\n    try {\n        return JSON.parse(str);\n    } catch (err) {};\n};//}}}\n\nexport function createArrayPuller(parentStore) {//{{{\n    // Create an object that populates arrays to each accessed property\n    const arrayStore = {};\n    for (const prop in parentStore) {\n        arrayStore[prop] = [...parentStore[prop]]; // Copy existing arrays\n        // This allows to remove inherited properties individually if needed\n    }\n    // Dynamically create an array per each accessed property:\n    Object.defineProperty(arrayStore, '_dynamic', {\n      get() {\n        return new Proxy(this, {\n          get(target, prop) {\n            if (prop in target) {\n              return target[prop];\n            }\n            target[prop] = [];\n            return target[prop];\n          }\n        });\n      }\n    });\n    return arrayStore._dynamic;\n};//}}}\n\nexport function replaceWrongNode(targetNode, error) {// {{{\n    // Create the outer <div> element\n    const errorNode = document.createElement('div');\n    errorNode.setAttribute('title', error.message);\n    errorNode.setAttribute('style', \"display: inline-block; padding: .5em 1em; background: red; color: yellow; border-radius: 50% 0%\");\n    // Add the text with the error code\n    errorNode.appendChild(document.createTextNode(error.code));\n    // Create the inner clicable button\n    const clicableNode = document.createElement('span');\n    clicableNode.setAttribute('title', 'Log the error again');\n    clicableNode.setAttribute('style', 'cursor: pointer; font-weight: bold; background-color: white; color: red; border-radius: 50%; padding: 0 4px; margin-left: 8px;');\n    clicableNode.textContent = 'â†§';\n    clicableNode.addEventListener('click', () => {\n        console.error(error);\n    });\n    errorNode.appendChild(clicableNode);\n    // Replace the targetNode with the errorNode\n    targetNode.replaceWith(errorNode);\n};// }}}\n\n","// lib/events.js\n// =============\n\nconst sym_local_events = Symbol(\"Events\");\nconst sym_all_events = Symbol(\"allEvents\");\nconst re_actionEvHandler = /^on(?:Before|After)Action_/;\nconst re_localEvHandler = /^onLocal_/;\nconst re_allEvHandler = /^onAll_/;\n\nimport {createArrayPuller} from \"./helpers.js\";\n\nconst supportedFieldEventTypes = [\n    \"keydown\", \"keyup\", \"keypress\",\n    \"beforeinput\", \"input\", \"change\",\n    \"focus\", \"blur\",\n    \"click\", \"dblclick\", \"contextmenu\",\n    \"mousedown\", \"mouseup\", \"mousemove\", \"mouseenter\", \"mouseleave\", \"mouseover\", \"mouseout\",\n    \"focusin\", \"focusout\",\n\n    // \"select\", \"dragstart\", \"dragend\", \"dragover\", \"dragenter\", \"dragleave\", \"drop\",\n    // \"touchstart\", \"touchend\", \"touchmove\", \"touchcancel\",\n    // \"wheel\", \"scroll\", \"resize\",\n    // \"copy\", \"cut\", \"paste\",\n];\n\nfunction registerEvHandler(evList, evType, evHandler) {\n    const me = this;\n    if (! evList.has(evType)) evList.set(evType, []);\n    evList.get(evType).push(evHandler.bind(me));\n    return me; // Make chainable.\n};\n\n\nexport const events = function events_decorator(targetComponentType, {kind}) {\n    if (kind == \"class\") {\n        return class eventEnabledTarget extends targetComponentType {\n            constructor(target, optionsSrc, ...args) {// {{{\n\n                // Capture before/after action event hanlers through\n                // onBeforeAction_xxx / onAfterAction_xxx options\n                // ...and onLocal_xxx / onAll_xxx regular event handlers.\n                const options = {};\n                const onOptionCallbacks = [];\n                for (\n                    const [key, value]\n                    of Object.entries(optionsSrc)\n                ) if (key.match(re_actionEvHandler)) {\n                    onOptionCallbacks.push([key.substring(2), value, \"onLocal\"])\n                } else if (key.match(re_localEvHandler)) {\n                    onOptionCallbacks.push([key.substring(8), value, \"onLocal\"])\n                } else if (key.match(re_allEvHandler)) {\n                    onOptionCallbacks.push([key.substring(6), value, \"onAll\"])\n                } else {\n                    // Threat the rest as regular options:\n                    options[key] = value;\n                };\n\n                // Call original constructor:\n                super(target, options, ...args);\n\n                // Events enhancing:\n                const me = this;\n                me[sym_local_events] = new Map();\n                me[sym_all_events] = new Map();\n                me.onLocal = registerEvHandler.bind(me, me[sym_local_events]);\n                me.onAll = registerEvHandler.bind(me, me[sym_all_events]);\n                me.on = me.onAll; // Handy alias for listening all events.\n\n                // Create event hooks object:\n                me.eventHooks = createArrayPuller(super.eventHooks);\n                    // eventHooks are eventHandlers provided by the component type.\n                    // They are processed after regular events if not default prevented.\n\n                // Field events redirection:\n                if (\n                    // Do it only once and from root component target:\n                    Object.is(me, me.root)\n                ) {\n                    for (const evType of supportedFieldEventTypes) {\n                        me.targetNode.addEventListener(evType, ev=>{\n                            const targetComponent = me.getComponent(ev.target);\n                            const evData = {\n                                type: evType,\n                                originalEvent: ev,\n                                context: targetComponent,\n                                preventDefault: ev.preventDefault.bind(ev),\n                                stopPropagation: ev.stopPropagation.bind(ev),\n                                stopImmediatePropagation: ev.stopImmediatePropagation.bind(ev),\n                            };\n                            targetComponent.emit(evType, evData);\n                        }, true); // Use capture phase\n                    };\n                };\n\n                // Setup action handlers provided through options:\n                for (\n                    const [evt, handler, listenLevel]\n                    of onOptionCallbacks\n                ) me[listenLevel](evt, handler);\n\n            };// }}}\n            async emit(evType, evData, preventable = true) {// {{{\n                const me = this;\n                let propagationStopped = false;\n                let immediatePropagationStopped = false;\n                const event = {\n                    ...evData,\n                    type: evType,\n                    defaultPrevented: false,\n                };\n                if (preventable) {\n                    event.preventDefault = () => event.defaultPrevented = true;\n                    event.stopPropagation = () => propagationStopped = true;\n                    event.stopImmediatePropagation = () => immediatePropagationStopped = true;\n                };\n                // Event target phase:\n                const targetHandlers = [ // Local handlers, then global ones:\n                    ...(me[sym_local_events].get(evType) || []),\n                    ...(me[sym_all_events].get(evType) || []),\n                ];\n                for (const handler of targetHandlers) {\n                    if (immediatePropagationStopped) break;\n                    await handler(evData);\n                };\n                // Events bubbling phase:\n                for (const parent of me.parents) {\n                    if (propagationStopped) break;\n                    const parentHandlers = parent[sym_all_events].get(evType) || [];\n                    for (const handler of parentHandlers) {\n                        if (immediatePropagationStopped) break;\n                        await handler(evData);\n                    };\n                }\n                // Event hooks (default behavior hooks)::\n                for (const eventHook of me.eventHooks[evType]) {\n                    // WARNING: eventHooks are called inconditionally!\n                    // They should check if event.defaultPrevented is set by themselves.\n                    // This may seem counter-intuitive and unhandy, but it will allow, for instance,\n                    // to implement a fake default prevention to \"change\" events (which are not natively cancelable) by restoring previous value.\n                    await eventHook(evData);\n                };\n                return ! event.defaultPrevented;\n            };// }}}\n        };\n    };\n};\n\n","// src/lib/legacy.js\n// =================\n\nexport default {\n    disEnhance(me) {\n\n        // Prevent <form>'s default behaviour:\n        if (me.targetNode.tagName.toLowerCase()) {\n            me.targetNode.addEventListener('submit', function(event) {\n\n                // Avoid form's regular submission:\n                event.preventDefault();\n\n                // More work may be needed to be done here (let's give it some\n                // more thought...)\n\n            });\n        };\n\n    },\n};\n","// lib/component.js\n// ================\nconst componentTypes = {};\n\nimport {events} from \"./events.js\";\nimport legacy from \"./legacy.js\";\nimport {replaceWrongNode} from \"./helpers.js\";\n\nconst sym_smart = Symbol(\"smart_component\");\nconst re_valid_typename_chars = /^[a-z0-9_]+$/i;\nconst re_has_wildcards = /[\\*\\?]/;\nconst wild2regex = wname => new RegExp(//{{{\n    \"^\"\n    + wname\n        .replace(/\\*+/g, \".*\")\n        .replace(/\\?/g, \".\")\n    + \"$\"\n);//}}}\n\nconst errors = {\n    renderError: class renderError extends Error {//{{{\n        constructor(code, message, path) {\n            super(`RenderError(${path}): ${message}`);\n            this.code = code;\n            this.path = path;\n            this.stack = this.stack\n                .split(\"\\n\")\n                .slice(2)\n                .join(\"\\n\")\n            ;\n        };\n    },//}}}\n};\n\nfunction inferType(node, parentComponent) {//{{{\n    switch (node.tagName.toLowerCase()) {\n        case \"ul\":\n        case \"ol\":\n        case \"table\":\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n            return \"list\";\n        case \"input\":\n            const type = String(node.getAttribute(\"type\")||\"\").toLowerCase();\n            if (parentComponent.isSingleton) return parentComponent.options.type;\n            switch(type) {\n                case \"number\":\n                case \"date\":\n                case \"radio\":\n                case \"color\":\n                    return type;\n            };\n        case \"textarea\":\n        case \"select\":\n            return \"input\";\n        case \"label\":\n            return \"label\";\n        default:\n            //(implicit)//if (parentComponent.options.type == \"list\") return \"form\";\n        case \"form\":\n            return \"form\";\n    };\n};//}}}\n\n@events\nexport class SmarkComponent {\n    constructor(//{{{\n        targetNode\n        , {\n            property_name = \"smark\",\n            ...options\n        } = {}\n        , parent\n    ) {\n        const me = this;\n\n        me.validName = (function nameGenerator() {//{{{\n            let counter = 0;\n            return function(...names){\n                if (me.parent.isSingleton) return \"\";\n                    // Singleton target components are unnamed.\n                for (\n                    let n0 of names\n                ) if (\n                    typeof n0 == \"string\"\n                ) {\n                    n0 = n0.trim();\n                    if (n0.length) return n0;\n                };\n                return 'UNNAMED'+(++counter);\n            };\n        })();//}}}\n\n        me.actions = {};\n        me.property_name = property_name;\n        me.selector = `[data-${me.property_name}]`;\n        me.types = componentTypes;\n        me.targetNode = targetNode;\n        me.options = options;\n        me.setNodeOptions(me.targetNode, me.options);\n\n        me.parent = parent;\n        if (! me.parent instanceof SmarkComponent) throw me.renderError(\n            'INVALID_PARENT'\n            , `Smark Components must have valid Smark Component parent.`\n        );\n        me.root = (\n            me.parent === null ? me\n            : me.parent.root\n        );\n\n        // Parents iterator:\n        me.parents = {};\n        me.parents[Symbol.iterator] = function* () {\n            let current = me.parent;\n            while (current) {\n                yield current;\n                current = current.parent;\n            };\n        };\n\n        // Calculate prefix or disable autoId:\n        const autoId = me.inheritedOption(\"autoId\", false);\n        me.genId = (\n            autoId === false ? false\n                // Do not auto-generate IDs.\n            : autoId === true ? p => p.replace(/\\//g, \"_\")\n                // Use \"_path_in_underscore_style\".\n            : typeof autoId == \"string\" ? p => autoId+p.replace(/\\//g, \"_\")\n                // Use \"prefix\" + \"_path_in_underscore_style\".\n            : typeof autoId == \"function\" ? autoId\n                // Use fn(path) custom style.\n            : false\n                // Failback to disabled.\n        );\n\n        me.onRenderedTasks = [];\n\n        let setRendered;\n        me.renderedSync = false;\n        me.rendered = new Promise(resolve => setRendered = resolve);\n\n        me.children = {};\n        me.targetNode[sym_smart] = me;\n\n        (async ()=>{\n            await me.render();\n            for (\n                const task of me.onRenderedTasks\n            ) await task();\n            me.onRenderedTasks = null;\n            setRendered(true);\n            setTimeout(()=>me.renderedSync = true, 1);\n            await me.emit(\"afterRender\", {\n                context: me\n            }, false);\n        })();\n        if (me.options.onRendered) me.onRendered(me.options.onRendered);\n\n    };//}}}\n    async unrender() {\n        const me = this;\n        await me.emit(\"beforeUnrender\", {\n            context: me\n        }, false);\n        me.targetNode.remove();\n    };\n    onRendered(cbk) {//{{{\n        const me = this;\n        if (me.onRenderedTasks) {\n            me.onRenderedTasks.push(cbk.bind(me));\n        } else {\n            cbk.bind(me)();\n        };\n    };//}}}\n    getNodeOptions(node, defaultOptions) {//{{{\n        const me = this;\n        const optionsSrc = (\n            node.dataset[me.property_name] || \"\"\n        ).trim() || null;\n        const options = {\n            ...defaultOptions,\n            ...(()=>{\n                try {\n                    const opt = JSON.parse(optionsSrc);\n                    if (typeof opt != \"object\") throw new Error(\"NO_OBJECT\");\n                    return opt;\n                } catch (err) {\n                    return (\n                        optionsSrc.match(re_valid_typename_chars) ? {type: optionsSrc}\n                        : {}\n                    );\n                };\n            })(),\n        };\n        if (! options.action && ! options.type) options.type = inferType(node, me);\n        me.setNodeOptions(node, options);\n        return options;\n    };//}}}\n    setNodeOptions(node, options) {//{{{\n        const me = this;\n        node.dataset[me.property_name] = JSON.stringify(options);\n    };//}}}\n    async enhance(node, defaultOptions) {//{{{\n        const me = this;\n\n        // Sanityze and store options:{{{\n        let options = me.getNodeOptions(node, defaultOptions);\n        //}}}\n\n        // Prevent default behaviours:{{{\n        legacy.disEnhance(me);\n        //}}}\n\n        // Classify:{{{\n        if (options.action) {\n            if (! options.type) options.type = \"trigger\"; // Make type optional for triggers.\n            if (options.type != \"trigger\") throw me.renderError(\n                \"ACTION_IN_NON_TRIGGER\"\n                , `\"action\" property is only allowed for \"trigger\" components but \"${options.type}\" type specified.`\n            );\n        } else if (typeof options.type != \"string\") {\n            throw me.renderError(\n                \"NO_TYPE_PROVIDED\"\n                , `Invalid SmarkForm item: type is mandatory for non trigger components.`\n            );\n        };\n        //}}}\n\n        // Enhance:{{{\n        const ctrl = me.types[options.type];\n        if (! ctrl) throw me.renderError(\n            \"UNKNOWN_TYPE\"\n            , `Unimplemented SmarkForm component controller: ${options.type}`,\n        );\n        return new ctrl (\n            node\n            , options\n            , me\n        );\n        //}}}\n\n    };//}}}\n    getComponent(target) {//{{{\n        const me = this;\n        return (\n            target[sym_smart]\n            || target.parentElement?.closest(me.selector)[sym_smart]\n            || null\n        );\n    };//}}}\n    getPath() {//{{{\n        const me = this;\n        const ancestors = [...me.parents].map(p=>p.name).reverse();\n        if (me.name) ancestors.push(me.name); // Compute parent path inside labels (or singletons?).\n        return ancestors.join(\"/\") || \"/\";\n    };//}}}\n    find(path=\"\") { // {{{\n        const me = this;\n        let base = me;\n        while ( // Always detect real fields in singletons, labels and triggers.\n            ! base.name\n            && base.parent !== null // Not root form\n        ) {\n            base = base.parent;\n        };\n        path = String(path); // Allow numbers (arrays simply won't match).\n        if (path[0] == \"/\") while (base.parent) base = base.parent;\n        const parts = path\n            .split(\"/\")\n            .filter(x=>x)\n        ;\n        // (Recursive) Multi-match search (path with '*' wildcards):\n        // (Returns array of components)\n        const firstWildcardPos = parts.findIndex(p=>p.match(re_has_wildcards));\n        if (firstWildcardPos >= 0) {\n            const re_pattern = wild2regex(parts[firstWildcardPos]);\n            const pivotPath = parts.slice(0, firstWildcardPos).join(\"/\");\n            const restPath = parts.slice(firstWildcardPos + 1).join(\"/\");\n            const pivot = base.find(pivotPath);\n            const pivotChilds = Object.entries(pivot.children);\n            return pivotChilds\n                .filter(([name,child])=>child && name.match(re_pattern))\n                .map(([,child])=>child.find(restPath))\n                .flat(Infinity)\n            ;\n        };\n        // Straight search (wildcardless path)\n        // (Returns single component)\n        return parts.reduce(\n            (current, name)=>{\n                if (current === undefined) return;   // No match.\n                if (name == \"..\") return current.parent;  // Go up one level.\n                if ( // Special syntax for list siblings (.+n / .-n)\n                    name[0] == \".\"\n                ) {\n                    if (name == \".\") return current; // Current node.\n                    if (! current.parent) return; // Root node => no siblings.\n                    const delta = parseInt(name.slice(1));\n                    if (isNaN(delta)) return; // Invalid sibling syntax.\n                    if (current.parent.options.type == \"list\") {\n                        const n = parseInt(current.name) + delta\n                        if (! isNaN(n)) return current.parent.children[n];\n                    } else {\n                        const keys = Object.keys(current.parent.children);\n                        const currentPosition = keys.findIndex(key=>key==current.name);\n                        const newKey = keys[currentPosition + delta];\n                        return current.parent.children[newKey];\n                    };\n                } else {\n                    return current.children[name];\n                };\n            }\n            , base\n        );\n    };//}}}\n    inheritedOption(optName, defaultValue) {//{{{\n        const me = this;\n        for (\n            const p of [me, ...me.parents]\n        ) if (\n            p.options[optName] !== undefined\n        ) return p.options[optName];\n        return defaultValue;\n    };//}}}\n    moveTo(){//{{{\n        const me = this;\n        if (! me.targetNode.id) me.targetNode.id = me.getPath();\n        document.location.hash = me.targetNode.id;\n        // Avoid noisy url hash \"randomish\" effect:\n        window.history.pushState({}, undefined,window.location.pathname);\n            // Like 'document.location.hash = \"\"' but without leaving leading\n            // hash character.\n    };//}}}\n    getTriggers(actionNames = \"\") {//{{{\n        const me = this;\n        const myCurrentActions = [];\n        const actionKeys = new Set([actionNames]\n            .flat()\n            .map(String)\n            .filter(x=>x)\n        );\n        const returnAll = actionKeys.has(\"*\");\n        for (\n            const tgg\n            of [me, ...me.root.targetNode.querySelectorAll(me.selector)]\n                .map(target=>target[sym_smart])\n                .filter(x=>x) // Ignore not yet rendered.\n        ) {\n            const options = tgg.getTriggerArgs()\n            if (! options) continue; // Not a trigger\n            if (\n                ! Object.is(options.context, me) // Current context\n                && ! Object.is(tgg, me)          // Trigger focused itself\n            ) continue;\n            if (\n                returnAll\n                || actionKeys.has(options.action)\n            ) myCurrentActions.push(tgg);\n        };\n        return myCurrentActions;\n    };//}}}\n    updateId() {//{{{\n        const me = this;\n        if (me.genId === false) return; // Abort if disabled.\n        const newId = me.genId(me.getPath());\n        if (me.targetNode.id != newId) {\n            me.targetNode.id = newId;\n            for (\n                const child\n                of Object.values(me.children)\n            ) child.updateId();\n        };\n        return me.targetNode.id\n    };//}}}\n    focus() {//{{{\n        const me = this;\n        for (const fname in me.children) {\n            return me.children[fname].focus();\n        };\n        if (me.targetFieldNode) {\n            // Prefer fields over triggers, forms, etc...\n            me.targetFieldNode.focus();\n        } else {\n            me.targetNode.focus();\n        }\n    };//}}}\n    getTriggerArgs() {}; // Let's easily filter out non trigger compoenents.\n    // Error types:\n    renderError(code, message) {//{{{\n        const me = this;\n        const targetNode = (\n            me.parent?.isSingleton ? me.parent.targetNode\n            : me.targetNode\n        );\n        const error = new errors.renderError(code, message, me.getPath());\n        replaceWrongNode(targetNode, error);\n        return error;\n    };//}}}\n};\n\nexport class SmarkField extends SmarkComponent {\n    constructor(...args){\n        super(...args);\n        this._isField = true;\n        if (! Object.is(this, this.root)) {\n            this.name = this.validName(\n                this.options.name\n                , this.targetNode.getAttribute(\"name\")\n            );\n            if (this.options.hasOwnProperty(\"value\")) {\n                if (this.targetNode.getAttribute(\"value\") !== null) { // Conflict\n                    throw me.renderError(\n                        'VALUE_CONFLICT'\n                        , `Initial value specied both as \"value\" option and HTML \"value\" attribute.`\n                    );\n                };\n                this.targetNode.setAttribute(\"value\", this.options.value);\n            };\n        };\n    };\n};\n\nexport function createType(name, controller) {//{{{\n    if (componentTypes[name] !== undefined) throw new Error(\n        `Duplicate component type definition: ${name}`\n    );\n    if (! (controller.prototype instanceof SmarkComponent)) throw new Error(\n        `Bad component type implementation for: ${name}`\n    );\n    componentTypes[name] = controller;\n};//}}}\n\n","// lib/hotkeys.js\n// ==============\n\n// const l = (label, cbk=x=>x)=>d=>(console.log(`${label}: `, cbk(d)), d);\n\nexport class hotKeys_handler {\n    constructor(form) {\n        const me = this;\n        me.form = form;\n        me.revealed = null;\n        const onStatusChange = hotKeys_handler.onStatusChange.bind(me);\n        me.form.targetNode.addEventListener(\"keydown\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"keyup\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"focusout\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"focusin\", onStatusChange, true);\n    };\n    static onStatusChange(ev) {\n        const me = this;\n\n        // Deactivation:\n        if (ev.type == \"keyup\") {\n            if (ev.key == \"Control\") return void me.reveal(false);\n            if (ev.key != \"Alt\") return;\n        };\n\n        // Focus leave:\n        if (ev.type == \"focusout\") {\n            if (me.revealed !== null) {\n                me.reveal(); // Unreveal, but keep activated.\n            };\n            return;\n        };\n\n        // Focus enter:\n        if (ev.type == \"focusin\" && me.revealed === null) {\n            return; // No hotkeys revealed.\n            // Otherwise behave as new activation\n        };\n\n        // Determine ctrlKey and altKey status properly:\n        // (Found differences between versions of the same browser)\n        const ctrlKey = ev.ctrlKey || ev.key == \"Control\";\n        const altKey = ev.altKey && ev.type != \"keyup\" || ev.key == \"Alt\" && ev.type == \"keydown\";\n        // ev.type is \"keydown\" (or \"keyup\" in case of Alt) or \"focusin\"\n        const activation = (\n            // Pressing ctrl key with or without alt key\n            ctrlKey && (ev.key == \"Control\" || ev.key == \"Alt\")\n            // Reentering focus after some action without deactivation\n            || ev.type == \"focusin\"\n        );\n\n        // (Re)activation:\n        if (activation) {\n            const level = altKey ? 2 : 1;\n            // Activate and reveal:\n            return void me.reveal(ev.target, level);\n        };\n\n        // Hotkey stroke:\n        if (me.revealed instanceof Array) {\n            const targettedTrigger = me.revealed.find(\n                t=>t.options.hotkey == ev.key\n            );\n            if (targettedTrigger) {\n                // Prevent default and stop propagation:\n                //   Even if disabled to avoid weird behaviour with repetitions\n                //   (Ex. using \"+\" to add items to a list would zoom in\n                //   some browsers when max_items is reached).\n                ev.preventDefault();\n                ev.stopPropagation();\n                // Perform the action:\n                if (! targettedTrigger.targetNode.disabled) {\n                    // Unless trigger is disabled\n                    targettedTrigger.targetNode.click();\n                };\n            };\n        };\n\n    };\n    reveal(target, level = 1) {\n        const me = this;\n\n        // Conceal previous target triggers' hotkeys if any:\n        if (me.revealed !== null) {\n            for (const t of me.revealed) {\n                t.targetNode.removeAttribute(\"data-hotkey\");\n            };\n            me.revealed.length = 0;\n        };\n\n        if (target === false) {\n            me.revealed = null; // Deactivate hot keys\n        };\n\n        if (target) {\n\n            // Reveal new target triggers' hotkeys:\n            const component = me.form.getComponent(target);\n            const activeContexts = getActiveContexts(component);\n            const candidateTriggers = activeContexts\n                // .map(l(\"activeContexts\", ({name, targetNode})=>({name, targetNode})))\n                .map((ctx, distance)=>{\n                    const candidates = [];\n                    for (const tg of ctx.getTriggers('*')) {\n                        const hotkey = String(tg.options.hotkey || \"\");\n                        if (hotkey == \"\") continue; // Ignore triggers without hotkey.\n                        const args = tg.getTriggerArgs() || {};\n                        candidates.push({\n                            tg,\n                            distance,   // Number of ancestors levels.\n                            args,\n                            hotkey,\n                        });\n                    };\n                    return candidates;\n                })\n                // .map(l(\"Triggers\", tlist=>tlist.map(({hotkey, distance, tg, args})=>({hotkey, distance, tg, args}))))\n                .flat()\n                .sort((ta,tb)=>{\n                    const atargetnode = ta.args.target?.targetNode;\n                    const btargetnode = tb.args.target?.targetNode;\n                    const bcontained = btargetnode ? .5 * btargetnode.contains(component.targetNode) : 0;\n                    const acontained = atargetnode ? .5 * atargetnode.contains(component.targetNode) : 0;\n                    const retv = (\n                        // Prefer triggers with nearest context:\n                        + ta.distance - tb.distance\n                        // Prefer triggers contained in ancestors (not siblings):\n                        + bcontained - acontained\n                    );\n                    // if (true || ta.hotkey == \"-\" && tb.hotkey == \"-\") {\n                    //     console.log(`--(${ta.hotkey} - ${tb.hotkey})------------------------------------------------`);\n                    //     console.log(\"--\", ta.tg.targetNode, tb.tg.targetNode, component.targetNode);\n                    //     console.log(\"--\", ta.distance, tb.distance, - tb.distance + ta.distance);\n                    //     console.log(\"--\", + acontained, + bcontained, + bcontained - acontained);\n                    //     console.log(`===========> ${retv}`);\n                    // };\n                    return retv;\n                })\n            ;\n\n            const seen = new Map(); // hotkey => [times seen, distance from target]\n            me.revealed = [];\n\n            for (const candidate of candidateTriggers) {\n                const [times, distance] = seen.get(candidate.hotkey) || [1, 0];\n                if (times < level) {\n                    seen.set(candidate.hotkey, [times + 1, candidate.distance]);\n                    continue; // Level not reached.\n                };\n                if (times > level) {\n                    continue; // Used by more preferent tg.\n                };\n                if (\n                    Object.is(candidate.tg.targetNode, target)\n                    || candidate.distance > distance\n                ) { // Don't pick more than one per \"ancestory\" level.\n                    if (! candidate.tg.targetNode.disabled) {\n                        candidate.tg.targetNode.setAttribute(\"data-hotkey\", candidate.hotkey);\n                    };\n                    me.revealed.push(candidate.tg); // Let stroke detection know it matched.\n                    // Avoid activating the following candidates by \"oveflowing\" their times seen count:\n                    // (UX): Do it even if disabled for behavioral consistency...\n                    seen.set(candidate.hotkey, [times + 1, candidate.distance]);\n                };\n            };\n\n        };\n\n    };\n};\n\nfunction getComponentSiblings(context) {\n    const children = context.parent?.children || [];\n    const position = Object.keys(children).findIndex((name)=>(name === context.name));\n    const brothers = Object.values(children);\n    const backwards = brothers.slice(0, position).reverse();\n    const forwards = brothers.slice(position + 1);\n    return [...forwards, ...backwards];\n};\n\nfunction getActiveContexts(component) {\n    const upwards = [component, ...component.parents];\n    return [\n        ...upwards,\n        ...upwards.map(getComponentSiblings).flat()\n    ];\n};\n\n","// types/trigger.type.js\n// =====================\nimport {SmarkComponent} from \"../lib/component.js\";\n\nexport const action = function action_decorator(targetMtd, {kind, name, addInitializer}) {\n    if (kind == \"method\") addInitializer(function registerAction() {\n        const me = this;\n        this.actions[name] = async function (data, options = {}) {\n            // Actions are async functions that can be triggered by trigger\n            // components.\n            // They receive data and options as arguments.\n            // They emit BeforeAction_<name> and AfterAction_<name> events.\n            // The options argument is passed to event handlers as is but with\n            // data property set to data argument.\n            // If a BeforeAction_<name> event handler calls event.preventDefault(),\n            // the action is cancelled.\n            let defaultPrevented = false;\n            options.data = data;\n            if (! options.silent) {\n                defaultPrevented = ! await me.emit(`BeforeAction_${name}`, options);\n                data = options.data; // Update data in case it was modified by event handlers.\n            };\n            if (defaultPrevented) return; // Action cancelled by event handler.\n            // Cal the method implementing the action.\n            // It receives data and options arguments.\n            // Here options.data is set to the input data argument.\n            // After execution, options.data is updated with the returned data.\n            data = await targetMtd.call(me, data, options);\n            options.data = data;\n            if (! options.silent) {\n                me.emit(`AfterAction_${name}`, options);\n            };\n            // The resulting action method returns the data returned by the\n            // original method.\n            // Options object can be mutated inside the original method and\n            // that mutations will be visible to the AfterAction_xxxx event\n            // handlers.\n            return data;\n        };\n    });\n};\n\nexport class trigger extends SmarkComponent {\n    constructor(node, options, ...args){\n        delete options.name; // Triggers are always unnamed.\n        return super(node, options, ...args);\n    };\n    render(){\n        const me = this;\n        me.parent.onRendered(()=>{\n            const triggerArgs = me.getTriggerArgs();\n            if (\n                typeof triggerArgs.context?.onTriggerRender == \"function\"\n            ) triggerArgs.context.onTriggerRender(triggerArgs);\n        });\n    };\n    disable() {//{{{\n        const me = this;\n        me.targetNode.disabled = true;\n    };//}}}\n    enable() {//{{{\n        const me = this;\n        me.targetNode.disabled = false;\n    };//}}}\n    getTriggerArgs() {//{{{\n        const me = this;\n        const parents = [me, ...me.parents];\n        const {\n            // property: local variable\n            action,\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n        if (! action) return; // Not a trigger component.\n\n        const context = (\n            contextPath ? me.parent.find(contextPath)\n            : parents.find(p=>(typeof p.actions[action] == \"function\"))\n        );\n\n        const target = (\n            targetPath ? context?.find(targetPath) // Explicit target (context relative)\n            : contextPath ? null // Explicit context path => don't mind component position\n            : (\n                parents\n                    .slice(1) // Skip self\n                    .find(p=>p.parent?.targetNode.isSameNode(context?.targetNode))\n                || null\n            )\n        );\n\n        return {\n            action,\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n\nexport async function onTriggerClick(ev) {\n    const me = this;\n    const triggerComponent = me.getComponent(ev.target);\n    const options = triggerComponent.getTriggerArgs();\n    if (! options) return; // Not a trigger.\n    const {context, action, data} = options;\n    const mtd = context?.actions[action]\n    if (\n        typeof mtd != \"function\"\n    ) throw me.renderError(\n        \"UNKNOWN_ACTION\"\n        , `Unknown action ${action}`\n        + (context ? ` for ${context.options.type}` : \"\")\n    );\n    return await mtd(data, options);\n};\n\n\n","// types/label.type.js\n// ===================\nimport {SmarkComponent} from \"../lib/component.js\";\nimport {randomId} from \"../lib/helpers.js\";\nimport {getRoots} from \"../lib/helpers.js\";\n\nexport class label extends SmarkComponent {\n    constructor(node, {allow_select = false, ...options}, ...args){\n        delete options.name; // Labels are always unnamed.\n        super(node, {allow_select, ...options}, ...args);\n        const me = this;\n        me.eventHooks.click.push(\n            function click_hook(ev) {\n                // Mimic native label behavior for non-native fields:\n                if (ev.defaultPrevented) return;\n                const {target} = me.getLabelArgs();\n                if (\n                    ! target?.targetFieldNode\n                    || (me.nodeType === \"legend\")\n                ) target.focus();\n            },\n        );\n    };\n    async render(){\n        const me = this;\n        // Enhance triggers inside the label:\n        let childField = null;\n        for (\n            const node\n            of getRoots(me.targetNode, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            if (!! newItem?._isField) {\n                if (childField !== null) throw me.renderError(\n                    'EXTRA_FIELD_IN_LABEL'\n                    , `Labels can wrap only one target field, but multiple fields found in form ${me.getPath()}.`\n                );\n                if (me.options.target !== undefined) {\n                    throw me.renderError(\n                        'LABEL_EXPLICIT_TARGET'\n                        , `Labels wrapping their target field cannot define explicit target option in form ${me.getPath()}.`\n                    );\n                };\n                childField = newItem;\n                childField.parent = me.parent;\n                me.parent.mountField(childField);\n            };\n        };\n        me.parent.onRendered(async ()=>{\n            const me = this;\n            me.nodeType = String(me.targetNode.tagName).toLowerCase();\n            const labelArgs = me.getLabelArgs();\n            const labelledField = labelArgs.target || {};\n            await labelledField.rendered; // Ensure target field is rendered.\n            if (labelledField.targetFieldNode) { // Apply only to native inputs (scalars)\n                if (! labelledField.targetFieldNode.id) { // Ensure targetted field has an Id\n                    labelledField.targetFieldNode.id = randomId();\n                };\n                me.targetNode.setAttribute(\"for\", labelledField.targetFieldNode.id);\n            };\n\n            // Automatically link label and field for screen readers:\n            if (\n                me.nodeType != \"label\"   // Not a native <label>\n            ) {\n                // Ensure label has an Id:\n                if (! me.targetNode.id) {\n                    me.targetNode.id = randomId();\n                };\n                // Get previous aria-labelledby values:\n                const alb_arr = (\n                    labelledField.targetNode.getAttribute(\"aria-labelledby\")\n                    || \"\"\n                )\n                    .split(\" \")\n                    .filter(id => id)\n                ;\n                // Add label id if not already present:\n                if (0 > alb_arr.indexOf(me.targetNode.id)) {\n                    alb_arr.push(me.targetNode.id);\n                };\n                // Reinject updated list:\n                labelledField.targetNode.setAttribute(\n                    \"aria-labelledby\"\n                    , alb_arr.join(\" \")\n                );\n            } else {\n                if (! labelledField.targetFieldNode) {\n                    throw me.renderError(\n                        'LABEL_FOR_NONFIELD'\n                        , `Native <label> tags targetting non native field are not allowed in HTML, you should use different tag.`\n                    );\n                };\n            };\n\n            // Make labels non-selectable unless \"allow_select\" option is set\n            // to true.\n            if (! me.options.allow_select) {\n                me.targetNode.style[\"user-select\"] = \"none\";\n            };\n        });\n    };\n    getLabelArgs() {//{{{\n        const me = this;\n        let context, target;\n\n        const {\n            // property: local variable\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n\n        if (! contextPath && ! targetPath) {\n            // Guess ;-)\n            context = me.parent;\n            if (\n                me.nodeType === \"legend\"\n                && context.targetNode.tagName.toLowerCase() === \"fieldset\"\n            ) {\n                target = Object.values(context.children)[0]; // First child of fieldset\n            } else {\n                const candidates = context.targetNode.querySelectorAll(me.selector);\n                let found = false;\n                for (const childName in candidates) {\n                    if (found) {\n                        let targetComponent = me.getComponent(candidates[childName]);\n                        if (targetComponent?._isField) {\n                            target = targetComponent;\n                            break;\n                        };\n                    } else if (\n                        Object.is(candidates[childName], me.targetNode)\n                    ) {\n                        found = true;\n                    };\n                };\n            };\n        } else {\n            context = (\n                contextPath ? me.parent.find(contextPath)\n                : me.parent\n            );\n            target = (\n                targetPath ? context.find(targetPath) // Explicit target (context relative)\n                : context\n            );\n        };\n\n        return {\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n","\nimport {action} from \"../types/trigger.type.js\";\n\nexport const foldable = function foldable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class foldableTarget extends target {\n            render(...args) {//{{{\n                const retv = super.render(...args);\n                const me = this;\n                me.root.onRendered(()=>{\n                    me.fold(null, {\n                        operation: ( !! me.options.folded ? \"fold\" : \"unfold\"),\n                        autofocus: false, // Never focus during initial render\n                    });\n                });\n                return retv;\n            };//}}}\n            @action\n            fold(_data, {//{{{\n                operation = \"toggle\", // Values: \"fold\" / \"unfold\" / \"toggle\"\n                origin,\n                autofocus = true,\n            } = {}) {\n                const me = this;\n                const wasFolded = me.targetNode.style.display == \"none\";\n                const isFolded = (\n                    operation == \"fold\" ? true\n                    : operation == \"unfold\" ? false\n                    : ! wasFolded\n                );\n                me.targetNode.style.display = (\n                    isFolded ? \"none\"\n                    : me.originalDisplayProp\n                );\n\n                me.getTriggers(\"fold\").forEach(tgg => {\n                    const {foldedClass, unfoldedClass} = tgg.options;\n                    if (foldedClass) tgg.targetNode.classList[\n                        isFolded ? \"add\"\n                        : \"remove\"\n                    ](foldedClass);\n                    if (unfoldedClass) tgg.targetNode.classList[\n                        isFolded ? \"remove\"\n                        : \"add\"\n                    ](unfoldedClass);\n                });\n\n                me.getTriggers([\"addItem\", \"removeItem\"]).map(\n                    isFolded ? tgg => tgg.disable()\n                    : tgg => tgg.enable()\n                );\n\n                // Set focus accordingly:\n                autofocus && (isFolded ? origin : me)?.focus();\n            };//}}}\n        };\n    };\n};\n","// src/decorators/export_to_target.deco.js\n// =======================================\n\nexport const export_to_target = function export_to_target_decorator(method, {kind}) {\n    if (kind == \"method\") {\n        return async function export_mtd(data, {target, ...options}={}) {\n            const me = this;\n            const value = await method.call(me, data, options);\n            try {\n                await target.import(value);\n            } catch (error) {\n                // target not provided or invalid\n            };\n            return value;\n        };\n    };\n};\n","// src/decorators/import_from_target.deco.js\n// =========================================\n\nexport const import_from_target = function import_from_target_decorator(method, {kind}) {\n    if (kind == \"method\") {\n        return async function import_mtd(data, {target, ...options}={}) {\n            const me = this;\n            try {\n                data = await target.export();\n            } catch (error) {\n                // target not provided or invalid\n            };\n            return await method.call(me, data, options);\n        };\n    };\n};\n","// types/form.type.js\n// ==================\n\nimport {SmarkField} from \"../lib/component.js\";\nimport {action} from \"./trigger.type.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {getRoots, parseJSON} from \"../lib/helpers.js\";\n\n@foldable\nexport class form extends SmarkField {\n    constructor(...args) {\n        super(...args);\n        const me = this;\n        // Focus forms on click (likewise to field types):\n        this.eventHooks.click.push ( ev => {\n            if (\n                ev.defaultPrevented\n                // Unless focus_on_click explicitly set to false\n                || ! me.inheritedOption('focus_on_click', true)\n            ) return;\n            this.focus();\n        });\n    };\n    mountField(newItem) {\n        const me = this;\n        if (!! newItem?._isField) {\n            if (me.children[newItem.name] !== undefined) throw me.renderError(\n                'REPEATED_FIELD_NAME'\n                , `Field name '${newItem.name}' used more than once in this form level.`\n            );\n            me.children[newItem.name] = newItem;\n            newItem.updateId();\n        };\n    };\n    async render() {//{{{\n        const me = this;\n        me.originalDisplayProp = me.targetNode.style.display;\n        // Enhance childs:\n        for (\n            const node\n            of getRoots(me.targetNode, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            me.mountField(newItem);\n        };\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        const me = this;\n        return Object.fromEntries(\n            await Promise.all(Object.entries(me.children).map(\n                async ([key, child])=>[key, await child.export(null, {silent: true})]\n            ))\n        );\n    };//}}}\n    @action\n    @import_from_target\n    async import(data = {}, {focus = true} = {}) {//{{{\n        const me = this;\n        const dataConstructor = Object(data).constructor;\n        if (\n            dataConstructor !== {}.constructor // Not a plain object\n            && ! (data = parseJSON(data))      // Neither a (valid) JSON string\n        ) throw me.renderError(\n            'FORM_NOT_PLAIN_OBJECT'\n            , `Expected plain object or vailid JSON for form import, ${dataConstructor.name} given.`\n        );\n        const retv = Object.fromEntries(\n            await Promise.all(\n                Object.entries(me.children).map(\n                    async ([key, target]) => {\n                        // Could have used target.then(...) but, event\n                        // components' import() method SHOULD be async, it\n                        // would have failed in case it's not.\n                        // Forcing it to be async is not possible because\n                        // transpilers would break this check.\n                        // ...and, IMHO, this approach is better than a dirty\n                        // Promise.resolve(...)\n                        const value = await target.import(data[key], {focus, silent: true});\n                        return [key, value];\n                    }\n                )\n            )\n        );\n        if (focus) me.focus();\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of Object.values(me.children)\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async clear(_data, {focus} = {}) {//{{{\n        const me = this;\n        return await me.import({}, {focus, silent: true});\n    };//}}}\n};\n","// types/list.decorators/smartdisabling.deco.js\n// ============================================\n\nasync function updateTriggers(context) {\n    await context.rendered;\n    for (const tg of context.getTriggers([\"removeItem\", \"addItem\"])) {\n        tg.targetNode.disabled = (\n            tg.options.action == \"removeItem\" ? (\n                context.children.length <= context.min_items\n                && tg.options.failback != \"clear\" // Unless clearing function\n            )\n            : context.children.length >= context.max_items\n        );\n    };\n};\n\nexport const smartdisabling = function list_smartdisabling_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class smartdisablingClass extends target {\n            async render(...args) {//{{{\n                const retv = await super.render(...args);\n                const me = this;\n                setTimeout(()=>updateTriggers(me), 1);\n                    // FIXME (Why do we need to delay it?)\n                    // Even more: Why it is even needed with min_items >= 1??\n\n                return retv;\n            };//}}}\n        };\n    } else if (kind == \"method\") {\n        return async function smartdisablingMethod(...args) {\n            const me = this;\n            const retv = await target.call(me, ...args);\n            updateTriggers(me);\n            return retv;\n        };\n    };\n};\n","\nconst sym_mux = Symbol(\"smart_mutex\");\n\nclass Mutex {\n    constructor() {\n        this.mtx = Promise.resolve();\n    };\n    lock() {\n        // Sync operation:\n        let nextResolve;\n        const nextMtx = new Promise(resolve => {\n            nextResolve = () => resolve();\n        });\n        const currMtx = this.mtx;\n        this.mtx = nextMtx;\n        // Async behaviour:\n        return currMtx.then(function unlock() {\n            return nextResolve\n        });\n    };\n}\n\nexport const mutex = function method_mutex_decorator(muxName) {\n    return function mutex_decorator(target, {kind}) {\n        if (kind == \"method\") {\n            return async function muxed_target(...args) {\n                const me = this;\n                if (! me[sym_mux]) me[sym_mux] = {};\n                if (! me[sym_mux][muxName]) me[sym_mux][muxName] = new Mutex();\n                const unlock = await me[sym_mux][muxName].lock(); // Await previous muxed call (if any)\n                let err, retv;\n                try {\n                    retv = await target.call(me, ...args);\n                } catch (error) {\n                    err = error;\n                };\n                unlock();\n                if (err) throw err;\n                return retv;\n            };\n\n        };\n    };\n};\n","// types/list.type.js\n// ==================\n\nimport {SmarkField} from \"../lib/component.js\";\nimport {smartdisabling} from \"./list.decorators/smartdisabling.deco.js\";\nimport {action} from \"./trigger.type.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {sortable} from \"./list.decorators/sortable.deco.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {mutex} from \"../decorators/mutex.deco.js\";\nimport {makeRoom, getRoots, parseJSON} from \"../lib/helpers.js\";\n\n// Private helpers:\n// ----------------\n\nfunction makeNonNavigable(target) {//{{{\n    if (\n        // Tabindex not explicitly defined:\n        target.getAttribute(\"tabindex\") === null\n    ) {\n        target.setAttribute(\"tabindex\", \"-1\");\n    };\n};//}}}\n\nfunction loadTemplates(me) {//{{{\n    const templates = {};\n    for (const child of [...me.targetNode.children]) {\n        const {role = \"item\"} = parseJSON(child.getAttribute(\"data-smark\")) || {};\n        switch (role) {\n            case \"empty_list\":\n            case \"header\":\n            case \"separator\":\n            case \"last_separator\":\n            case \"footer\":\n            case \"placeholder\": // (Only with max_items defined)\n                child.setAttribute(\"data-role\", role);\n            case \"item\": // (Default)\n                if (templates[role] !== undefined) throw me.renderError(\n                    'LIST_DUPLICATE_TEMPLATE'\n                    , `Repated list template role ${role}`\n                );\n                templates[role] = child;\n                templates[role].remove();\n            break;\n        };\n    };\n    if (me.targetNode.children.length) {\n        const {role = \"(unspecified)\"} = parseJSON(\n            me.targetNode.children[0].getAttribute(\"data-smark\")\n        ) || {};\n        throw me.renderError(\n            'LIST_UNKNOWN_TEMPLATE_ROLE'\n            , `Unknown list template role ${role}`\n        );\n    };\n    if (! templates.last_separator) {\n        templates.last_separator = templates.separator; // (If any)\n    };\n    if (\n        templates.item.querySelector(\"[id]\") !== null // Contains IDs\n    ) throw me.renderError(\n        'LIST_CONTAINS_ID'\n        , `List components are not allowed to contain elements with 'id' attribute`\n    );\n    return templates;\n};//}}}\n\n\n// List component type:\n// --------------------\n\n@foldable\n@sortable\n@smartdisabling\nexport class list extends SmarkField {\n    async #appendChild(child) {//{{{\n        const me = this;\n        if (me.templates.header) {\n            me.templates.header.after(child);\n        } else {\n            me.targetNode.appendChild(child);\n        };\n    };//}}}\n    async render () {//{{{\n        const me = this;\n        me.originalDisplayProp = me.targetNode.style.display;\n\n        me.min_items = Math.max(0,\n            typeof me.options.min_items == \"number\" ? me.options.min_items\n            : 1\n        );\n        me.max_items = Math.max(me.min_items,\n            typeof me.options.max_items == \"number\" ? me.options.max_items\n            : Infinity\n        );\n        me.children = [];\n        me.templates = loadTemplates(me);\n        me.placeholders = [];\n        const tplOptions = me.getNodeOptions(\n            me.templates.item\n            , {\n                type: me.options.of, // Allow to specify items type from list declaration.\n            }\n        );\n        if (\n            me.options.of\n            && tplOptions.type != me.options.of\n        ) throw me.renderError(\n            'LIST_ITEM_TYPE_MISSMATCH'\n            , `List item type missmatch`\n        );\n\n        for (const tpl of [\n            me.templates.header,\n            me.templates.footer,\n        ]) if (!! tpl) {\n            me.targetNode.appendChild(tpl);\n            // Enhance childs:\n            for (\n                const node\n                of getRoots(tpl, me.selector)\n            ) {\n                const newItem = await me.enhance(node);\n                if (!! newItem?._isField) {\n                    throw me.renderError(\n                        'FIELD_IN_WRONG_LIST_TEMPLATE'\n                        , `Fields are not allowed in list's template roles other than item.`\n                    );\n                };\n            };\n        };\n\n        // onRendered tweaks:\n        me.root.onRendered(async ()=>{\n            for(let i=0; i<me.min_items; i++) await me.addItem({silent: true});\n\n            // Initialize \"count\" actions and reinject empty_list template:\n            if (me.min_items == 0) await me.renum();\n\n            // Let screen readers know lists may change.\n            me.targetNode.setAttribute(\"aria-live\", \"polite\");\n            me.targetNode.setAttribute(\"aria-atomic\", \"true\");\n        });\n    };//}}}\n    onTriggerRender({action, origin, context}) {//{{{\n        switch (action) {\n            case \"addItem\":\n            case \"removeItem\":\n                if (\n                    // Placed inside\n                    (1 + [...origin.parents].findIndex(p=>Object.is(p, context)))\n                    && origin.options.hotkey\n                ) {\n                    // Skip them in keyboard navigation.\n                    makeNonNavigable(origin.targetNode);\n                };\n                break;\n        };\n    };//}}}\n    @mutex(\"list_mutating\")\n    @action\n    @export_to_target\n    async export() {//{{{\n        const me = this;\n        const list = [];\n        const emptyChilds = [];\n        const stripEmpties = ! me.inheritedOption(\"exportEmpties\", false);\n        for (const child of me.children) {\n            if (stripEmpties && await child.isEmpty()) {\n                if (list.length < me.min_items) emptyChilds.push(child);\n                continue;\n            };\n            list.push(await child.export(null, {silent: true}));\n        };\n        for (let i=0; list.length < me.min_items; i++) {\n            list.push(await emptyChilds[i].export(null, {silent: true}));\n        };\n        return list;\n    };//}}}\n    @action\n    @import_from_target\n    async import(data = [], {focus} = {}) {//{{{\n        const me = this;\n        // Auto-update in case of scalar to array template upgrade:\n        if (! (data instanceof Array)) data = [data];\n        // Load data:\n        for (\n            let i = 0;\n            i < Math.min(data.length, me.max_items); // Limit to allowed items\n            i++\n        ) {\n            if (me.children.length <= i) await me.addItem({silent: true}); // Make room on demand\n            await me.children[i].import(data[i], {focus, silent: true});\n        };\n        // Remove extra items if possible (over min_items):\n        for (\n            let i = Math.max(data.length, me.min_items);\n            i < me.children.length;\n        ) await me.removeItem({silent: true});\n        // Report if data doesn't fit:\n        if (data.length > me.max_items) {\n            me.emit(\"error\", {\n                code: 'LIST_IMPORT_OVERFLOW',\n                message: `Trying to import array greater than list's max_items. Data beyond max_items ignored.`,\n                context: me,\n                data,\n                options: me.options,\n            });\n        };\n        // Clear items over imported data if min_items is greater:\n        for (\n            let i = data.length;\n            i < me.children.length; // (Due to min_items)\n            i++\n        ) me.children[i].clear({silent: true});\n        if (focus) me.focus();\n        return; // await me.export(null, {silent: true});\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    @smartdisabling\n    async addItem(_data, options = {}) {//{{{\n        const me = this;\n        // Parameters checking and resolution:{{{\n        options.action = \"addItem\";\n        options.origin ||= null; // (Internal call)\n        options.context ||= me;  // (Internal call)\n        options.source ||= null; // Source component to copy data from.\n        options.target ||= null; // Target child component to insert before/after.\n        options.position ||= \"after\";\n        options.autoscroll ||= null;   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n        options.failback ||= \"throw\";  // \"none\" / \"throw\" (default)\n        if (options.position != \"after\" && options.position != \"before\") throw me.renderError(\n            'LIST_WRONG_ADDITEM_POSITION'\n            , `Invalid value for addItem() position property: ${options.position}`\n        );\n        if (me.children.length >= me.max_items) {\n            switch (options.failback) {\n                case \"none\":\n                    break;\n                case \"throw\":\n                default:\n                    me.emit(\"error\", {\n                        code: 'LIST_MAX_ITEMS_REACHED',\n                        message: `Cannot add items over max_items boundary`,\n                        options,\n                    });\n            };\n            return;\n        };\n        if (me.children.length && ! options.target) options.target = ( // Auto target:\n            options.position == \"before\" ?  me.children[0] // Insert at the beginning\n            : me.children[me.children.length - 1]  // Append at the end\n        );\n        //}}}\n        // DOM element creation:{{{\n        const newItemTarget = me.templates.item.cloneNode(true);\n        //}}}\n        // Child component creation and insertion:{{{\n        let newItem;\n        if (! me.children.length) {\n            await me.#appendChild(newItemTarget);\n            newItem = await me.enhance(newItemTarget, {type: \"form\", name: 0});\n            await newItem.rendered;\n            me.children.push(newItem);\n            newItem.name = 0;\n        } else {\n            me.children = (await Promise.all(\n                me.children.map(async (child, i)=>{\n                    if (! child.targetNode.isSameNode(options.target.targetNode)) {\n                        return child;\n                    } else {\n                        // Append or prepend new item to the target child:\n                        child.targetNode[options.position](newItemTarget);\n                            // Note that options.position is ensured to be \"after\" or \"before\" above.\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        const chunk = [child, newItem];\n                        // Ensure correct order:\n                        if (options.position == \"before\") chunk.reverse();\n                        return chunk; // Array that will be flattened later...\n                    };\n                })\n            ))\n                .flat()\n            ;\n        };\n        await me.renum();\n        //}}}\n        // Copy data from source component if specified:{{{\n        if (options.source) {\n            const sourceComponent = newItem.find(options.source);\n            if (!! sourceComponent) {\n                const data = await sourceComponent.export();\n                await newItem.import(data, {silent: true});\n            };\n        };\n        //}}}\n        // Autoscroll handling:{{{\n        if (options.autoscroll == \"elegant\" && !! newItem) {\n            makeRoom(newItem.targetNode, - newItem.offsetHeight);\n        } else {\n            const moveTarget = (\n                ! newItem ? null\n                : options.autoscroll == \"self\" ? newItem\n                : options.autoscroll == \"parent\" ? newItem.parent\n                : null\n            );\n            if (moveTarget) moveTarget.moveTo();\n        };\n        //}}}\n        if (me.renderedSync) newItem.focus();\n        return newItem;\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    @smartdisabling\n    async removeItem(_data, options = {}) {//{{{\n        const me = this;\n        options.action = \"removeItem\";\n        options.origin ||= null; // (Internal call)\n        options.context ||= me;  // (Internal call)\n        options.target ||= null; // Target child component to remove.\n        options.autoscroll ||= null;   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n        let preserve_non_empty = options.preserve_non_empty ||= false;\n        options.failback ||= \"throw\";  // \"none\" / \"clear\" / \"throw\" (default)\n        if (! options.target) {\n            if (preserve_non_empty) for (\n                const t of [...me.children]\n                .reverse() // Pick last first\n            ) if (await t.isEmpty()) {\n                options.target = t;\n                break;\n            };\n            if (! options.target) {\n                options.target = me.children[me.children.length - 1];\n                preserve_non_empty = false;\n                // Allow non empty removal as last chance if no target\n                // specified.\n            };\n        };\n        const targets = (\n            options.target instanceof Array ? options.target\n            : [options.target]\n        );\n        for (const currentTarget of [...targets].reverse()) {\n            if (me.children.length <= me.min_items) {\n                switch (options.failback) {\n                    case \"none\":\n                        break;\n                    case \"clear\":\n                        await currentTarget.clear({silent: true});\n                        return;\n                    case \"throw\":\n                    default:\n                        me.emit(\"error\", {\n                            code: 'LIST_MIN_ITEMS_REACHED',\n                            message: `Cannot remove items under min_items boundary`,\n                            options,\n                        });\n                        return;\n                };\n            };\n            if (preserve_non_empty && ! await currentTarget.isEmpty()) continue;\n            // Locate target child and rebuild children array without it:{{{\n            let oldItem = null;\n            let newFocusPosition = null;\n            const newChildren = me.children\n                .filter((child, i, all)=>{\n                    if (child.targetNode.isSameNode(currentTarget.targetNode)) {\n                        if (options.autoscroll == \"elegant\") {\n                            makeRoom(child.targetNode, child.targetNode.offsetHeight);\n                        } else {\n                            const moveTarget = (\n                                options.autoscroll == \"self\" ? child\n                                : options.autoscroll == \"parent\" ? child.parent\n                                : null\n                            );\n                            if (moveTarget) moveTarget.moveTo();\n                        };\n                        oldItem = child;\n                        newFocusPosition = (\n                            (all.length -i > 1) ? newFocusPosition = i // More above\n                            : i == 0 ? null           // No items left\n                            : i - 1                   // Removing last item\n                        );\n                        return false;\n                    };\n                    return true;\n                })\n            ;\n            // }}}\n            // Perform removal:{{{\n            await me.emit(\"removeItem_beforeRender\", {\n                ...options,\n                target: oldItem,\n                targetNode: oldItem.targetNode,\n            }, false);\n            await oldItem.unrender();\n            me.children = newChildren;\n            await me.renum();\n            await me.emit(\"removeItem_afterRender\", {\n                ...options,\n                target: oldItem,\n                targetNode: oldItem.targetNode,\n            }, false);\n            if (newFocusPosition !== null) {\n                me.children[newFocusPosition].focus();\n            };\n            // }}}\n        };\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of me.children\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async clear(_data, {focus} = {}) {//{{{\n        const me = this;\n        return await me.import([], {focus, silent: true});\n    };//}}}\n    @action\n    count(_data, {delta = 0} = {}) {//{{{\n        // Return number of children.\n        // But also it's sole existence allow reinjecting contents to it.\n        const me = this;\n        return me.children.length + Number(delta);\n    };//}}}\n    @action\n    position(_data, {target, offset = 1} = {}) {//{{{\n        return Number(target?.name) + Number(offset);\n    };//}}}\n    async renum(){//{{{\n        const me = this;\n\n        // Update child index:\n        for (const i in me.children) {\n            me.children[i].name = i;\n            me.children[i].updateId();\n        };\n\n        // Handle separators:\n        if (\n            !! me.templates.separator\n            || !! me.templates.last_separator\n        ) for (const i in me.children) {\n\n            const isLastNode = i >= me.children.length - 1;\n            const sepRole = (\n                i <= 0 ? null\n                : isLastNode ? \"last_separator\"\n                : \"separator\"\n            );\n\n            const currentNode = me.children[i].targetNode;\n            const prevNode = currentNode.previousElementSibling;\n            const prevNode_role = prevNode && prevNode.getAttribute(\"data-role\");\n            if (prevNode_role !== sepRole) {\n                if (!! prevNode_role) prevNode.remove();\n                const sepTemplate = me.templates[sepRole];\n                if (!! sepRole && !! sepTemplate) currentNode.parentElement.insertBefore(sepTemplate.cloneNode(true), currentNode);\n            };\n            if (isLastNode) { // LastItem\n                const nextNode = currentNode.nextElementSibling;\n                if (!! nextNode) nextNode.remove();\n            };\n\n        };\n\n        // Handle empty_list template:\n        if (me.templates.empty_list) {\n            if (me.children.length) {\n                me.templates.empty_list.remove(); // (from DOM)\n            } else {\n                await me.#appendChild(me.templates.empty_list);\n            };\n        };\n\n        // Handle placeholder template:\n        if (\n            me.templates.placeholder\n            && !! me.max_items // (Only if we have a finite padding limit)\n        ) {\n            let placeHoldersCount = (me.max_items || 0) - me.children.length;\n            if (\n                placeHoldersCount > 0\n                && me.children.length === 0\n                && !! me.templates.empty_list\n            ) placeHoldersCount--; // Discount the hole occupied by empty_list\n            if (me.placeholders.length < placeHoldersCount) {\n                for (let i = me.placeholders.length; i < placeHoldersCount; i++) {\n                    const placeholder = me.templates.placeholder.cloneNode(true);\n                    if (me.templates.footer) {\n                        me.templates.footer.before(placeholder);\n                    } else {\n                        me.targetNode.appendChild(placeholder);\n                    };\n                    me.placeholders.push(placeholder);\n                };\n            } else { // me.placeholders.length >= placeHoldersCount\n                for (let i = me.placeholders.length; i > placeHoldersCount; i--) {\n                    me.placeholders.pop().remove();\n                };\n            };\n        };\n\n        // Update counter triggers:\n        me.getTriggers(\"position\").forEach(tgg=>{\n            const me = this;\n            const args = tgg.getTriggerArgs();\n            tgg.targetNode.innerText = me.position(args.data, {...args, silent: true});\n        });\n        me.getTriggers(\"count\").forEach(tgg=>{\n            const me = this;\n            const args = tgg.getTriggerArgs();\n            tgg.targetNode.innerText = me.count(args.data, {...args, silent: true});\n        });\n    };//}}}\n};\n","// types/list.decorators/sortable.deco.js\n// ======================================\n\nimport {mutex} from \"../../decorators/mutex.deco.js\";\n\nexport const sortable = function list_sortable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class sortableTarget extends target {\n            async render(...args) {//{{{\n                const retv = await super.render(...args);\n                const me = this;\n\n                me.sortable = !! me.options.sortable;\n                me.templates.item.setAttribute(\"draggable\", me.sortable);\n                me.children.forEach(c=>c.targetNode.setAttribute(\"dragable\", me.sortable));\n                if (me.sortable) {\n                    let dragSource = null;\n                    let dragDest = null;\n                    me.targetNode.addEventListener(\"dragstart\", e => {\n                        if (dragSource === null) {\n                            dragSource = e.target\n                            e.stopPropagation();\n                        } else {\n                            // Single dragging at a time.\n                            e.preventDefault();\n                        };\n                    });\n                    me.targetNode.addEventListener(\"dragover\", e => e.preventDefault());\n                    me.targetNode.addEventListener(\"drop\", e => {\n                        if (! dragSource) return; // Already dropped\n                        let target = e.target;\n                        while (\n                            target.parentElement\n                            && target.parentElement != dragSource.parentElement\n                        ) target = target.parentElement;\n                        dragDest = target;\n                    });\n                    me.targetNode.addEventListener(\"dragend\", async () => {\n                        if (dragDest)  await me.move({\n                            from: me.getComponent(dragSource),\n                            to: me.getComponent(dragDest),\n                        });\n                        dragSource = null;\n                        dragDest = null;\n                    });\n                };\n\n                return retv;\n            };//}}}\n            @mutex(\"list_mutating\")\n            async move(options = {}) {//{{{\n                const me = this;\n                let {\n                    from,\n                    to,\n                } = options;\n\n                // // FIXME: Avoid nested sortables to interact.\n                // console.log({from, to}); // <--- See this!!!\n\n                //\n                // TODO: Convert to action!!!\n                //\n                if (\n                    to === null // Dropped outside\n                    || from === null // (Shouldn't happen)\n                ) return;\n                const fromi = Number(from?.name);\n                const toi = Number(to?.name);\n                if (fromi == toi) {\n                    return;\n                } else if (fromi < toi) {\n                    const newChunk = [\n                        ...me.children.slice(fromi + 1, toi + 1),\n                        me.children[fromi],\n                    ];\n                    me.children.splice(fromi, toi - fromi + 1, ...newChunk);\n                } else if (fromi > toi) {\n                    const newChunk = [\n                        me.children[fromi],\n                        ...me.children.slice(toi, fromi),\n                    ];\n                    me.children.splice(toi, fromi - toi + 1, ...newChunk);\n                };\n                const inc = fromi < toi ? 1 : -1;\n                const moveMethod = inc > 0 ? \"after\" : \"before\";\n                to.targetNode[moveMethod](from.targetNode);\n                me.renum();\n            };//}}}\n        };\n    };\n};\n","// types/input.type.js\n// ===================\nimport {form} from \"./form.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {parseJSON} from \"../lib/helpers.js\";\nexport class input extends form {\n    constructor(...args) {//{{{\n        super(...args);\n        const me = this;\n        me.eventHooks.keydown.push(\n            function keydown_hook(ev) {\n                if (ev.defaultPrevented) return;\n                if (ev.originalEvent.key === \"Enter\") {\n                    const backwards = ev.originalEvent.shiftKey;\n                    if (\n                        ev.context.targetNode.tagName === \"TEXTAREA\"\n                        && ! ev.originalEvent.ctrlKey\n                        && ! backwards\n                    ) return; // Require Ctrl key to escape textareas.\n                    let nextField = (\n                        ! backwards ? ev.context.find(\".+1\") || ev.context.find(\"../.+1\")\n                        : ev.context.find(\".-1\") || ev.context.find(\"../.-1\")\n                    );\n                    if (nextField) {\n                        nextField.focus();\n                        ev.originalEvent.preventDefault();\n                        ev.originalEvent.stopPropagation();\n                    };\n                };\n            },\n        );\n    }; // }}}\n    async render() {//{{{\n        const me = this;\n        me.isSingleton = ! (\n            me.targetNode.tagName === \"INPUT\"\n            || me.targetNode.tagName === \"SELECT\"\n            || me.targetNode.tagName === \"TEXTAREA\"\n        );\n        me.isCheckbox = (\n            ! me.isSingleton\n            && String(me.targetNode.type).toLowerCase() == \"checkbox\"\n        );\n        if (me.isSingleton) {\n            await super.render();\n            const sons = Object.values(me.children);\n            if (sons.length != 1) throw me.renderError(\n                'NOT_A_SINGLETON'\n                , `Singleton forms are only allowed to contain exactly one`\n                + ` data field but ${sons.length} found.`\n            );\n            const son = sons[0];\n            if (me.options.type !== son.options.type) throw me.renderError(\n                'SINGLETON_TYPE_MISMATCH'\n                , `Singleton type (${me.options.type})`\n                + ` does not match child field type (${son.options.type}).`\n            );\n            me.targetFieldNode = son.targetNode;\n        } else {\n            me.targetFieldNode = me.targetNode;\n        };\n    };//}}}\n    @action\n    @export_to_target\n    async export(_data, options) {//{{{\n        const me = this;\n        if (me.isSingleton) return await me.children[\"\"].export(_data, options);\n        const nodeFld = me.targetFieldNode;\n        let retv;\n        if (me.isCheckbox) {\n            retv = !! nodeFld.checked;\n        } else if (\n            me.options.encoding === \"json\"\n            && nodeFld.tagName.toUpperCase() === \"SELECT\"\n            && nodeFld.options[nodeFld.selectedIndex]?.getAttribute(\"value\") === null\n        ) {\n            // Keep fallback working when encoding is json and value attribute is not set.\n            // (and don't expetct <opton> inner text to be JSON)\n            retv = JSON.stringify(nodeFld.options[nodeFld.selectedIndex].text);\n        } else {\n            retv = nodeFld.value;\n        };\n        return (\n            me.options.encoding === \"json\" ? parseJSON(retv) || null\n            : retv\n        );\n    };//}}}\n    @action\n    @import_from_target\n    async import(data = \"\", options = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await me.children[\"\"].import(data, options);\n        let {focus = true} = options;\n        const nodeFld = me.targetFieldNode;\n        if (\n            typeof data === \"object\"\n            && me.options.type === \"input\"    // Not in a derivated field types\n            || me.options.encoding === \"json\" // JSON encoding specified\n        ) {\n            data ||= null;\n            const isTextarea = nodeFld.tagName.toUpperCase() === \"TEXTAREA\";\n            data = (\n                isTextarea ? JSON.stringify(data, null, 4) // Pretty print\n                : JSON.stringify(data) // Compact print\n            ) || \"\";\n        };\n        if (me.isCheckbox) {\n            me.targetNode.checked = !! data;\n        } else if (\n            me.options.encoding === \"json\"\n            && nodeFld.tagName.toUpperCase() === \"SELECT\"\n        ) {\n            me.targetNode.value = (data || \"null\"); // Faster, but won't work if value attribute is not set.\n            if (nodeFld.selectedIndex === -1) {\n                // Fallback when value attribute is not set.\n                const parsed = parseJSON(data) || \"\";\n                const idx = Array.from(nodeFld.options).findIndex(\n                    opt => opt.text === parsed\n                );\n                if (idx !== -1) nodeFld.selectedIndex = idx;\n            };\n        } else {\n            me.targetNode.value = data;\n        };\n        if (focus) me.focus();\n        return me.targetNode.value;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = (\n            me.isCheckbox ? \"\" // Do not consider checkboxes.\n            : await me.export(null, {silent: true})\n        );\n        return ! value.trim().length;\n            // Native input's value type is always a string.\n    };//}}}\n    @action\n    async clear(_data, {focus} = {}) {//{{{\n        const me = this;\n        await me.import(\n            me.options.encoding === \"json\" ? null : \"\"\n            , {focus}\n        );\n    };//}}}\n};\n","// types/number.type.js\n// ====================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nexport class number extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"number\").toLowerCase() != \"number\"\n        ) throw me.renderError(\n            'NOT_A_NUMBER_FIELD'\n            , `Number inputs require an INPUT tag of type \"number\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"number\"; // Autofill\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        return (\n            data.length && ! isNaN(data) ? Number(data)\n            : null\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import(data = null, options = {}) {//{{{\n        const me = this;\n        const typename = typeof data;\n        if (me.isSingleton) return await super.import(data, options); // Overload only inner field\n        const retv =  await super.import((\n            typename == \"number\" ? data\n            : typename == \"string\" && data.length && ! isNaN(data) ? Number(data)\n            : null\n        ), options);\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export(null, {silent: true});\n        return value === null;\n    };//}}}\n};\n","// types/date.type.js\n// ==================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nconst re_timePart = /T.*/;\nfunction parseDateStr(str) {//{{{\n    // Accept \"YYYYMMDD\":\n    if (str.length == 8) return new Date([\n        str.substring(0, 4),\n        str.substring(4, 6),\n        str.substring(6, 8),\n    ].join(\"-\"));\n\n    // Accept \"YYYY-MM-DD\" (like date inputs)\n    // > new Date(\"2023-11-30\")\n    // 2023-11-30T00:00:00.000Z\n    // ...but don't accept if not zero-padded:\n    // > new Date(\"2023-11-3\")\n    // 2023-11-02T23:00:00.000Z\n    if (\n        str.length == 10\n        && str[4] == \"-\"\n        && str[7] == \"-\"\n    ) return new Date(str);\n\n    // Also don't accept other locale dependant formats:\n    // > new Date(\"11/30/2023\")\n    // 2023-11-29T23:00:00.000Z\n\n    return NaN;\n};//}}}\nfunction ISODate(value) {//{{{\n    return value.toISOString().replace(re_timePart, \"\");\n};//}}}\nexport class date extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"date\").toLowerCase() != \"date\"\n        ) throw me.renderError(\n            'NOT_A_DATE_FIELD'\n            , `Date inputs require an INPUT tag of type \"date\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"date\"; // Autofill\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        if (! data.length) return null;\n        const value = parseDateStr(data);\n        return (\n            isNaN(value) ? null\n            : ISODate(value)\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import(data = null, {focus = true} = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await super.import(data, {focus}); // Overload only inner field\n        const value = (\n            data instanceof Date ? data // Accept Date instance\n            : typeof data == \"number\" ? new Date(data) // Accept epoch\n            : ! data || (typeof data != \"string\") ? NaN // Reject nullish\n            : parseDateStr(data) // Handle strings\n        );\n        const retv = await super.import((\n            isNaN(value) ? null\n            : ISODate(value)\n        ), {focus});\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export(null, {silent: true});\n        return value === null;\n    };//}}}\n};\n","// types/radio.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {randomId} from \"../lib/helpers.js\";\nexport class radio extends input {\n    constructor(...args) {\n        super(...args);\n        const me = this;\n        let master = me.parent.children[me.name];\n        let retv = me;\n        if (master) {\n            me.targetNode.setAttribute(\"name\", master.sharedNodeName);\n            master.radioButtons.push(me.targetNode);\n            retv = {}; // Not the master field.\n        } else {\n            master = me;\n            // Provide unique name for DOM navigation to work properly:\n            master.sharedNodeName = randomId();\n            master.targetNode.setAttribute(\"name\", master.sharedNodeName);\n            master.radioButtons = [\n                master.targetNode\n            ];\n        };\n        let changeEventHandler = onRadioInteraction.bind(master);\n        me.targetNode.addEventListener(\"click\", changeEventHandler);\n        me.targetNode.addEventListener(\"keydown\", changeEventHandler);\n        return retv;\n    };\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"radio\").toLowerCase() != \"radio\"\n        ) throw me.renderError(\n            'NOT_A_RADIO_FIELD'\n            , `Radio inputs require an INPUT tag of type \"radio\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"radio\"; // Autofill\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        return this.radioButtons.find(r=>r.checked)?.value || null;\n    };//}}}\n    @action\n    @import_from_target\n    async import(data = null, {focus = true} = {}) {//{{{\n        const selected = this.radioButtons.find(r=>r.value === data);\n        if (selected) {\n            selected.checked = true;\n        } else {\n            this.radioButtons.forEach(r=>r.checked = false);\n        };\n        if (focus) this.focus();\n    };//}}}\n    async isEmpty() {//{{{\n        return ! (1 + this.radioButtons.findIndex(r=>r.checked));\n    };//}}}\n};\n\nfunction onRadioInteraction(event) {//{{{\n    if (\n        event.type === \"click\"\n        || event.type === \"keydown\" && event.code === \"Delete\"\n        // NOTE: Some browsers also send fake click events for toggling radio\n        //       buttons.\n        //       This approach avoids to interfere with that behavior while\n        //       ensuring a consistent keyboard resetting method (through the\n        //       Delete key).\n    ) {\n        const me = this;\n        let checked = true; // All raddio buttons become checked on click.\n        const lastSelection = Object.is(me.lastClicked?.target, event.target);\n        if (lastSelection) checked = (\n            ! me.lastClicked.checked    // Click  => Toggle\n            && event.type !== \"keydown\" // Delete => Reset\n        );\n        me.lastClicked = {\n            target: event.target,\n            checked,\n        };\n        event.target.checked = checked;\n    };\n};//}}}\n","// types/color.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nconst re_color = /^#([a-f0-9]{3}){1,2}$/i;\nconst disabled_style = `\n    opacity: .5;\n    background: repeating-linear-gradient(\n            45deg,\n            black,\n            black 10px,\n            white 10px,\n            white 20px\n        ),\n        black;\n    background-blend-mode: difference;\n`;\nexport class color extends input {\n    constructor(...args) {\n        super(...args);\n        // Add keydown hook to handle \"Delete\" key:\n        this.eventHooks.keydown.push ( ev => {\n            if (ev.defaultPrevented) return;\n            if (ev.originalEvent.key === \"Delete\") {\n                ev.context.clear();\n            };\n        });\n    };\n    async render() {//{{{\n        await super.render();\n        const me = this;\n\n        if (me.isSingleton) return; // (Only for real field)\n\n        // Check targetField's type attribute:\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"color\").toLowerCase() != \"color\"\n        ) throw me.renderError(\n            'NOT_A_COLOR_FIELD'\n            , `Color inputs require an INPUT tag of type \"color\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"color\"; // Autofill\n\n        // Iniitialize me.isDefined flag:\n        const valueAttr = me.targetFieldNode.getAttribute(\"value\");\n        me.isDefined = (\n            valueAttr !== null         // value property not defined\n            && valueAttr.trim() !== \"\" // value property defined (string)\n        );\n\n        // Remember original \"style\" attribute and update if appropriate:\n        me.defaultStyleAttr = me.targetFieldNode.getAttribute(\"style\") + \";\";\n        if (! me.isDefined) me.targetFieldNode.setAttribute(\n            \"style\"\n            , me.defaultStyleAttr + disabled_style\n        );\n\n        // Handle me.isDefined set:\n        const resetDefined = ev=>{\n            if (\n                ev.code    !== \"Enter\"\n                && ev.Code !== \"Space\"\n                && ev.code !== undefined // ev.type must be \"click\" or \"change\"\n                    // && ev.type !== \"click\" // Click event\n                    // && ev.type !== \"change\" // Change event\n            ) return;\n            me.isDefined = true;\n            me.targetFieldNode.setAttribute(\"style\", me.defaultStyleAttr);\n        };\n        me.targetFieldNode.addEventListener(\"keydown\", resetDefined);\n        me.targetFieldNode.addEventListener(\"click\", resetDefined);\n        me.targetFieldNode.addEventListener(\"change\", resetDefined);\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        let data = await super.export(...args);\n        if (! me.isSingleton) data = (\n            me.isDefined && data.match(re_color) ? data.toLowerCase()\n            : null\n        );\n        return data;\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import(data = null, options = {}) {//{{{\n        const me = this;\n        if (\n            ! me.isSingleton // Only for real field\n        ) {\n            if (\n                data === null              // Explicit null value\n                || ! data.match(re_color)  // Invalid color value\n            ) {\n                me.isDefined = false;\n                me.targetFieldNode.setAttribute(\n                    \"style\"\n                    , me.defaultStyleAttr + disabled_style\n                );\n            } else {\n                me.isDefined = true;\n                me.targetFieldNode.setAttribute(\"style\", me.defaultStyleAttr);\n            };\n        };\n        if (data?.length == 4) data = `#${data[1]}${data[1]}${data[2]}${data[2]}${data[3]}${data[3]}`;\n        const value = await super.import(data, options);\n        return (\n            me.isDefined ? value\n            : null\n        );\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export(null, {silent: true});\n        return value === null;\n    };//}}}\n};\n\n","// SmarkForm.js\n// ============\n\nimport {createType} from \"./lib/component.js\";\nimport {hotKeys_handler} from \"./lib/hotkeys.js\";\n\n// Import core component types and event handlers:\nimport {trigger, onTriggerClick} from \"./types/trigger.type.js\";\nimport {label} from \"./types/label.type.js\";\nimport {form} from \"./types/form.type.js\";\nimport {list} from \"./types/list.type.js\";\nimport {input} from \"./types/input.type.js\";\nimport {number} from \"./types/number.type.js\";\nimport {date} from \"./types/date.type.js\";\nimport {radio} from \"./types/radio.type.js\";\nimport {color} from \"./types/color.type.js\";\n\n\n// Load core component types:\nfor (const [name, controller] of Object.entries({\n    trigger,\n    label,\n    form,\n    list,\n    input,\n    number,\n    date,\n    radio,\n    color,\n})) createType(name,controller);\n\n\nclass SmarkForm extends form {\n    constructor(\n        targetNode\n        , {\n            customActions = {},\n            ...formOptions\n        } = {}\n    ) {\n        const options = {\n            ...formOptions,\n            name: \"\",\n            type: \"form\",\n        };\n        super(\n            targetNode\n            , options\n            , null // (Root has no parent)\n        );\n        const me = this;\n        me.setNodeOptions(me.targetNode, options);\n        me.actions = {\n            ...me.actions,\n            ...Object.fromEntries(\n                Object.entries(customActions)\n                    .map(([name, ctrl])=>[name, ctrl.bind(me)])\n            ),\n        };\n        me.targetNode.addEventListener(\n            \"click\"\n            , onTriggerClick.bind(me)\n            , true\n        );\n        new hotKeys_handler(me);\n    };\n    async render() {\n        const me = this;\n        me.targetNode.setAttribute(\"aria-busy\", \"true\");\n        await super.render();\n        me.targetNode.setAttribute(\"aria-busy\", \"false\");\n    };\n};\n\nSmarkForm.createType = createType;\n\nexport default SmarkForm;\n\n"],"names":["getRoots","target","selector","isTop","parentNode","n","isSameNode","querySelectorAll","filter","e","closest","makeRoom","element","pixels","parent","direction","scrollHeight","clientHeight","maxScroll","scrollTop","randomId","Math","random","toString","substring","parseJSON","str","JSON","parse","err","sym_local_events","Symbol","sym_all_events","re_actionEvHandler","re_localEvHandler","re_allEvHandler","supportedFieldEventTypes","registerEvHandler","evList","evType","evHandler","has","set","get","push","bind","this","legacy","disEnhance","me","targetNode","tagName","toLowerCase","addEventListener","event","preventDefault","componentTypes","sym_smart","re_valid_typename_chars","re_has_wildcards","errors","Error","constructor","code","message","path","super","concat","stack","split","slice","join","_SmarkComponent","_SmarkComponent2","_ref","arguments","length","undefined","property_name","options","_objectWithoutProperties","_excluded","validName","counter","isSingleton","_len","names","Array","_key","n0","trim","actions","types","setNodeOptions","SmarkComponent","renderError","root","parents","iterator","current","autoId","inheritedOption","setRendered","genId","p","replace","onRenderedTasks","renderedSync","rendered","Promise","resolve","children","render","task","setTimeout","emit","context","onRendered","unrender","remove","cbk","getNodeOptions","node","defaultOptions","optionsSrc","dataset","_objectSpread","opt","match","type","action","parentComponent","String","getAttribute","inferType","stringify","enhance","ctrl","getComponent","_target$parentElement","parentElement","getPath","ancestors","map","name","reverse","find","base","parts","x","firstWildcardPos","findIndex","re_pattern","wname","RegExp","pivotPath","restPath","pivot","Object","entries","_ref2","child","_ref3","flat","Infinity","reduce","delta","parseInt","isNaN","keys","currentPosition","key","newKey","optName","defaultValue","moveTo","id","document","location","hash","window","history","pushState","pathname","getTriggers","myCurrentActions","actionKeys","Set","returnAll","tgg","getTriggerArgs","is","updateId","newId","values","focus","fname","targetFieldNode","_me$parent","error","errorNode","createElement","setAttribute","appendChild","createTextNode","clicableNode","textContent","console","replaceWith","replaceWrongNode","_initClass","_applyDecs","targetComponentType","kind","onOptionCallbacks","value","args","Map","onLocal","onAll","on","eventHooks","parentStore","arrayStore","prop","defineProperty","Proxy","_dynamic","createArrayPuller","ev","targetComponent","evData","originalEvent","stopPropagation","stopImmediatePropagation","evt","handler","listenLevel","preventable","propagationStopped","immediatePropagationStopped","defaultPrevented","targetHandlers","parentHandlers","eventHook","c","SmarkField","_isField","hasOwnProperty","createType","controller","prototype","hotKeys_handler","form","revealed","onStatusChange","reveal","ctrlKey","altKey","level","targettedTrigger","t","hotkey","disabled","click","removeAttribute","component","activeContexts","upwards","getComponentSiblings","getActiveContexts","candidateTriggers","ctx","distance","candidates","tg","sort","ta","tb","_ta$args$target","_tb$args$target","atargetnode","btargetnode","bcontained","contains","acontained","seen","candidate","times","_context$parent","position","brothers","backwards","targetMtd","addInitializer","async","data","silent","call","trigger","_triggerArgs$context","triggerArgs","onTriggerRender","disable","enable","_me$options","contextPath","targetPath","otherOptions","_p$parent","origin","onTriggerClick","mtd","label","allow_select","getLabelArgs","nodeType","childField","newItem","mountField","labelledField","alb_arr","indexOf","style","_excluded2","found","childName","foldable","_foldableTarget","_initProto","retv","fold","operation","folded","autofocus","_data","wasFolded","display","isFolded","originalDisplayProp","forEach","foldedClass","unfoldedClass","classList","export_to_target","method","import","import_from_target","export","_form","updateTriggers","min_items","failback","max_items","_form2","fromEntries","all","dataConstructor","isEmpty","clear","smartdisabling","sym_mux","Mutex","mtx","lock","nextResolve","nextMtx","currMtx","then","mutex","muxName","unlock","_list","_list_brand","WeakSet","_exportDecs","_addItemDecs","_removeItemDecs","_appendChild","templates","header","after","_list2","_classPrivateMethodInitSpec","max","role","last_separator","separator","item","querySelector","loadTemplates","placeholders","tplOptions","of","tpl","footer","i","addItem","renum","list","emptyChilds","stripEmpties","min","removeItem","source","autoscroll","newItemTarget","cloneNode","chunk","_assertClassBrand","sourceComponent","offsetHeight","moveTarget","preserve_non_empty","targets","currentTarget","oldItem","newFocusPosition","newChildren","count","Number","offset","isLastNode","sepRole","currentNode","prevNode","previousElementSibling","prevNode_role","sepTemplate","insertBefore","nextNode","nextElementSibling","empty_list","placeholder","placeHoldersCount","before","pop","innerText","_sortableTarget","_moveDecs","sortable","dragSource","dragDest","move","from","to","fromi","toi","newChunk","splice","moveMethod","input","keydown","shiftKey","nextField","isCheckbox","sons","son","_nodeFld$options$node","nodeFld","checked","encoding","toUpperCase","selectedIndex","text","parsed","idx","_input","number","targetTag","targetType","typename","_number","re_timePart","parseDateStr","Date","NaN","ISODate","toISOString","date","_date","radio","master","sharedNodeName","radioButtons","changeEventHandler","onRadioInteraction","_this$radioButtons$fi","r","selected","_me$lastClicked","lastClicked","_radio","re_color","disabled_style","color","valueAttr","isDefined","defaultStyleAttr","resetDefined","Code","_color","SmarkForm","customActions"],"mappings":"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"}