{"version":3,"file":"SmarkForm.esm.js","sources":["../src/lib/helpers.js","../src/lib/events.js","../src/lib/legacy.js","../src/lib/component.js","../src/lib/hotkeys.js","../src/types/trigger.type.js","../src/types/label.type.js","../src/lib/field.js","../src/decorators/foldable.deco.js","../src/decorators/export_to_target.deco.js","../src/decorators/import_from_target.deco.js","../src/types/form.type.js","../src/types/list.decorators/smartdisabling.deco.js","../src/types/list.decorators/focusretention.deco.js","../src/decorators/mutex.deco.js","../src/types/list.decorators/sortable.deco.js","../src/types/list.type.js","../src/types/input.type.js","../src/types/number.type.js","../src/types/date.type.js","../src/types/time.type.js","../src/types/datetime-local.type.js","../src/types/radio.type.js","../src/types/color.type.js","../src/main.js"],"sourcesContent":["\"use strict\";\nexport function getRoots(target, selector){//{{{\n    const parent = target.parentNode;\n    const isTop = (\n        parent === null ? n => n === null\n        : n=>(n===null)||n.isSameNode(target)\n    );\n    return [\n        ...target.querySelectorAll(selector)\n    ].filter(\n        e=>isTop(e.parentNode.closest(selector))\n    );\n};//}}}\n\nexport function makeRoom(element, pixels) {//{{{\n    let parent = element.parentNode;\n    const direction = (\n        pixels >= 0 ? 1\n        : -1\n    );\n    while (parent) {\n        // Check if parent has vertical scroll bar\n        if (parent.scrollHeight > parent.clientHeight * direction) {\n            // Get the maximum amount that can be scrolled in this parent\n            var maxScroll = parent.scrollHeight - parent.clientHeight * direction;\n\n            // If desired amount is less than maximum scroll, perform scroll\n            if (pixels <= maxScroll * direction) {\n                parent.scrollTop += pixels;\n                return;\n            } else {\n              // If desired amount is greater than maximum scroll,\n              // scroll to maximum and subtract it from desired amount\n              parent.scrollTop = maxScroll;\n              pixels -= maxScroll;\n            };\n        };\n        parent = parent.parentNode;\n    };\n};//}}}\n\nexport function randomId() {//{{{\n    return Math.random().toString(36).substring(2);\n};//}}}\n\nexport function parseJSON(str) {//{{{\n    try {\n        return JSON.parse(str);\n    } catch (err) {};\n};//}}}\n\nexport function createArrayPuller(parentStore) {//{{{\n    // Create an object that populates arrays to each accessed property\n    const arrayStore = {};\n    for (const prop in parentStore) {\n        arrayStore[prop] = [...parentStore[prop]]; // Copy existing arrays\n        // This allows to remove inherited properties individually if needed\n    }\n    // Dynamically create an array per each accessed property:\n    Object.defineProperty(arrayStore, '_dynamic', {\n      get() {\n        return new Proxy(this, {\n          get(target, prop) {\n            if (prop in target) {\n              return target[prop];\n            }\n            target[prop] = [];\n            return target[prop];\n          }\n        });\n      }\n    });\n    return arrayStore._dynamic;\n};//}}}\n\nexport function replaceWrongNode(targetNode, error) {// {{{\n    // Create the outer <div> element\n    const errorNode = document.createElement('div');\n    errorNode.setAttribute('title', error.message);\n    errorNode.setAttribute('style', \"display: inline-block; padding: .5em 1em; background: red; color: yellow; border-radius: 50% 0%\");\n    // Add the text with the error code\n    errorNode.appendChild(document.createTextNode(error.code));\n    // Create the inner clicable button\n    const clicableNode = document.createElement('span');\n    clicableNode.setAttribute('title', 'Log the error again');\n    clicableNode.setAttribute('style', 'cursor: pointer; font-weight: bold; background-color: white; color: red; border-radius: 50%; padding: 0 4px; margin-left: 8px;');\n    clicableNode.textContent = 'â†§';\n    clicableNode.addEventListener('click', () => {\n        console.error(error);\n    });\n    errorNode.appendChild(clicableNode);\n    // Replace the targetNode with the errorNode\n    targetNode.replaceWith(errorNode);\n};// }}}\n\nexport function parseTime(str) {//{{{\n    // Accept \"HH:mm\" format (5 characters)\n    if (str.length === 5 && str[2] === \":\") {\n        const hours = parseInt(str.substring(0, 2), 10);\n        const minutes = parseInt(str.substring(3, 5), 10);\n        if (\n            hours >= 0 && hours <= 23\n            && minutes >= 0 && minutes <= 59\n        ) {\n            return str + \":00\"; // Add seconds\n        }\n    }\n    \n    // Accept \"HH:mm:ss\" format (8 characters)\n    if (str.length === 8 && str[2] === \":\" && str[5] === \":\") {\n        const hours = parseInt(str.substring(0, 2), 10);\n        const minutes = parseInt(str.substring(3, 5), 10);\n        const seconds = parseInt(str.substring(6, 8), 10);\n        if (\n            hours >= 0 && hours <= 23\n            && minutes >= 0 && minutes <= 59\n            && seconds >= 0 && seconds <= 59\n        ) {\n            return str;\n        }\n    }\n    \n    // Accept \"HHmmss\" format (6 characters)\n    if (str.length === 6) {\n        const hours = parseInt(str.substring(0, 2), 10);\n        const minutes = parseInt(str.substring(2, 4), 10);\n        const seconds = parseInt(str.substring(4, 6), 10);\n        if (\n            hours >= 0 && hours <= 23\n            && minutes >= 0 && minutes <= 59\n            && seconds >= 0 && seconds <= 59\n        ) {\n            return [\n                str.substring(0, 2),\n                str.substring(2, 4),\n                str.substring(4, 6),\n            ].join(\":\");\n        }\n    }\n    \n    // Accept \"HHmm\" format (4 characters)\n    if (str.length === 4) {\n        const hours = parseInt(str.substring(0, 2), 10);\n        const minutes = parseInt(str.substring(2, 4), 10);\n        if (\n            hours >= 0 && hours <= 23\n            && minutes >= 0 && minutes <= 59\n        ) {\n            return [\n                str.substring(0, 2),\n                str.substring(2, 4),\n                \"00\"\n            ].join(\":\");\n        }\n    }\n    \n    return null;\n};//}}}\n\nexport function parseDateTime(str) {//{{{\n    // Accept \"YYYYMMDDTHHmmss\" format\n    if (str.length === 15 && str[8] === \"T\") {\n        const date = [\n            str.substring(0, 4),\n            str.substring(4, 6),\n            str.substring(6, 8),\n        ].join(\"-\");\n        const time = [\n            str.substring(9, 11),\n            str.substring(11, 13),\n            str.substring(13, 15),\n        ].join(\":\");\n        return new Date(`${date}T${time}`);\n    }\n    \n    // Accept \"YYYYMMDDTHHmm\" format\n    if (str.length === 13 && str[8] === \"T\") {\n        const date = [\n            str.substring(0, 4),\n            str.substring(4, 6),\n            str.substring(6, 8),\n        ].join(\"-\");\n        const time = [\n            str.substring(9, 11),\n            str.substring(11, 13),\n            \"00\",\n        ].join(\":\");\n        return new Date(`${date}T${time}`);\n    }\n    \n    // Accept \"YYYY-MM-DDTHH:mm:ss\" format (standard datetime-local format)\n    if (\n        str.length === 19\n        && str[4] === \"-\"\n        && str[7] === \"-\"\n        && str[10] === \"T\"\n        && str[13] === \":\"\n        && str[16] === \":\"\n    ) {\n        return new Date(str);\n    }\n    \n    // Accept \"YYYY-MM-DDTHH:mm\" format (datetime-local without seconds)\n    if (\n        str.length === 16\n        && str[4] === \"-\"\n        && str[7] === \"-\"\n        && str[10] === \"T\"\n        && str[13] === \":\"\n    ) {\n        return new Date(str + \":00\");\n    }\n    \n    // Accept ISO 8601 strings with timezone info (like .toISOString() output)\n    // Example: \"2023-12-25T14:30:45.789Z\"\n    const isoMatch = str.match(/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})?$/);\n    if (isoMatch) {\n        return new Date(str);\n    }\n    \n    return NaN;\n};//}}}\n\nexport function setTabIndex(target, value = \"-1\") {//{{{\n    // Set tabindex attribute only if not explicitly defined\n    if (target.getAttribute(\"tabindex\") === null) {\n        target.setAttribute(\"tabindex\", value);\n    }\n};//}}}\n\nexport function validateInputType(targetFieldNode, expectedType, errorCode, errorMessage) {//{{{\n    // Validate that the target field is an INPUT element with the expected type\n    const targetTag = targetFieldNode.tagName;\n    const targetType = targetFieldNode.getAttribute(\"type\");\n    if (\n        targetTag != \"INPUT\"\n        || (targetType || expectedType).toLowerCase() != expectedType\n    ) {\n        const error = new Error(errorMessage);\n        error.code = errorCode;\n        throw error;\n    }\n    // Autofill type attribute if not present\n    if (!targetType) {\n        targetFieldNode.type = expectedType;\n    }\n};//}}}\n\n","// lib/events.js\n// =============\n\nconst sym_local_events = Symbol(\"Events\");\nconst sym_all_events = Symbol(\"allEvents\");\nconst re_actionEvHandler = /^on(?:Before|After)Action_/;\nconst re_localEvHandler = /^onLocal_/;\nconst re_allEvHandler = /^onAll_/;\n\nimport {createArrayPuller} from \"./helpers.js\";\n\nconst supportedFieldEventTypes = [\n    \"keydown\", \"keyup\", \"keypress\",\n    \"beforeinput\", \"input\", \"change\",\n    \"focus\", \"blur\",\n    \"click\", \"dblclick\", \"contextmenu\",\n    \"mousedown\", \"mouseup\", \"mousemove\", \"mouseenter\", \"mouseleave\", \"mouseover\", \"mouseout\",\n    \"focusin\", \"focusout\",\n\n    // \"select\", \"dragstart\", \"dragend\", \"dragover\", \"dragenter\", \"dragleave\", \"drop\",\n    // \"touchstart\", \"touchend\", \"touchmove\", \"touchcancel\",\n    // \"wheel\", \"scroll\", \"resize\",\n    // \"copy\", \"cut\", \"paste\",\n];\n\nfunction registerEvHandler(evList, evType, evHandler) {\n    const me = this;\n    if (! evList.has(evType)) evList.set(evType, []);\n    evList.get(evType).push(evHandler.bind(me));\n    return me; // Make chainable.\n};\n\n\nexport const events = function events_decorator(targetComponentType, {kind}) {\n    if (kind == \"class\") {\n        return class eventEnabledTarget extends targetComponentType {\n            constructor(target, optionsSrc, ...args) {// {{{\n\n                // Capture before/after action event hanlers through\n                // onBeforeAction_xxx / onAfterAction_xxx options\n                // ...and onLocal_xxx / onAll_xxx regular event handlers.\n                const options = {};\n                const onOptionCallbacks = [];\n                for (\n                    const [key, value]\n                    of Object.entries(optionsSrc)\n                ) if (re_actionEvHandler.test(key)) {\n                    onOptionCallbacks.push([key.substring(2), value, \"onLocal\"])\n                } else if (re_localEvHandler.test(key)) {\n                } else if (re_localEvHandler.test(key)) {\n                    onOptionCallbacks.push([key.substring(8), value, \"onLocal\"])\n                } else if (re_allEvHandler.test(key)) {\n                    onOptionCallbacks.push([key.substring(6), value, \"onAll\"])\n                } else {\n                    // Threat the rest as regular options:\n                    options[key] = value;\n                };\n\n                // Call original constructor:\n                super(target, options, ...args);\n\n                // Events enhancing:\n                const me = this;\n                me[sym_local_events] = new Map();\n                me[sym_all_events] = new Map();\n                me.onLocal = registerEvHandler.bind(me, me[sym_local_events]);\n                me.onAll = registerEvHandler.bind(me, me[sym_all_events]);\n                me.on = me.onAll; // Handy alias for listening all events.\n\n                // Create event hooks object:\n                me.eventHooks = createArrayPuller(super.eventHooks);\n                    // eventHooks are eventHandlers provided by the component type.\n                    // They are processed after regular events if not default prevented.\n\n                // Field events redirection:\n                if (\n                    // Do it only once and from root component target:\n                    Object.is(me, me.root)\n                ) {\n                    for (const evType of supportedFieldEventTypes) {\n                        me.targetNode.addEventListener(evType, ev=>{\n                            const targetComponent = me.getComponent(ev.target);\n                            const evData = {\n                                type: evType,\n                                originalEvent: ev,\n                                context: targetComponent,\n                                preventDefault: ev.preventDefault.bind(ev),\n                                stopPropagation: ev.stopPropagation.bind(ev),\n                                stopImmediatePropagation: ev.stopImmediatePropagation.bind(ev),\n                            };\n                            targetComponent.emit(evType, evData);\n                        }, true); // Use capture phase\n                    };\n                };\n\n                // Setup action handlers provided through options:\n                for (\n                    const [evt, handler, listenLevel]\n                    of onOptionCallbacks\n                ) me[listenLevel](evt, handler);\n\n            };// }}}\n            async emit(evType, evData, preventable = true) {// {{{\n                const me = this;\n                let propagationStopped = false;\n                let immediatePropagationStopped = false;\n                const event = {\n                    ...evData,\n                    type: evType,\n                    defaultPrevented: false,\n                };\n                if (preventable) {\n                    event.preventDefault = () => event.defaultPrevented = true;\n                    event.stopPropagation = () => propagationStopped = true;\n                    event.stopImmediatePropagation = () => immediatePropagationStopped = true;\n                };\n                // Event target phase:\n                const targetHandlers = [ // Local handlers, then global ones:\n                    ...(me[sym_local_events].get(evType) || []),\n                    ...(me[sym_all_events].get(evType) || []),\n                ];\n                for (const handler of targetHandlers) {\n                    if (immediatePropagationStopped) break;\n                    await handler(evData);\n                };\n                // Events bubbling phase:\n                for (const parent of me.parents) {\n                    if (propagationStopped) break;\n                    const parentHandlers = parent[sym_all_events].get(evType) || [];\n                    for (const handler of parentHandlers) {\n                        if (immediatePropagationStopped) break;\n                        await handler(evData);\n                    };\n                }\n                // Event hooks (default behavior hooks)::\n                for (const eventHook of me.eventHooks[evType]) {\n                    // WARNING: eventHooks are called inconditionally!\n                    // They should check if event.defaultPrevented is set by themselves.\n                    // This may seem counter-intuitive and unhandy, but it will allow, for instance,\n                    // to implement a fake default prevention to \"change\" events (which are not natively cancelable) by restoring previous value.\n                    await eventHook(evData);\n                };\n                return ! event.defaultPrevented;\n            };// }}}\n        };\n    };\n};\n\n","// src/lib/legacy.js\n// =================\n\nexport default {\n    disEnhance(me) {\n\n        // Prevent <form>'s default behaviour:\n        if (me.targetNode.tagName.toLowerCase()) {\n            me.targetNode.addEventListener('submit', function(event) {\n\n                // Avoid form's regular submission:\n                event.preventDefault();\n\n                // More work may be needed to be done here (let's give it some\n                // more thought...)\n\n            });\n        };\n\n    },\n};\n","// lib/component.js\n// ================\nconst componentTypes = {};\n\nimport {events} from \"./events.js\";\nimport legacy from \"./legacy.js\";\nimport {parseJSON, replaceWrongNode} from \"./helpers.js\";\n\nconst sym_smart = Symbol(\"smart_component\");\nconst re_valid_typename_chars = /^[a-z0-9_]+$/i;\nconst re_has_wildcards = /[\\*\\?]/;\nconst wild2regex = wname => new RegExp(//{{{\n    \"^\"\n    + wname\n        .replace(/\\*+/g, \".*\")\n        .replace(/\\?/g, \".\")\n    + \"$\"\n);//}}}\n\nconst errors = {\n    renderError: class renderError extends Error {//{{{\n        constructor(code, message, path) {\n            super(`RenderError(${path}): ${message}`);\n            this.code = code;\n            this.path = path;\n            this.stack = this.stack\n                .split(\"\\n\")\n                .slice(2)\n                .join(\"\\n\")\n            ;\n        };\n    },//}}}\n};\n\nfunction inferType(node, parentComponent) {//{{{\n    switch (node.tagName.toLowerCase()) {\n        case \"ul\":\n        case \"ol\":\n        case \"table\":\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n            return \"list\";\n        case \"input\":\n            const type = String(node.getAttribute(\"type\")||\"\").toLowerCase();\n            if (parentComponent.isSingleton) return parentComponent.options.type;\n            switch(type) {\n                case \"number\":\n                case \"date\":\n                case \"time\":\n                case \"datetime-local\":\n                case \"radio\":\n                case \"color\":\n                    return type;\n            };\n        case \"textarea\":\n        case \"select\":\n            return \"input\";\n        case \"label\":\n            return \"label\";\n        default:\n            //(implicit)//if (parentComponent.options.type == \"list\") return \"form\";\n        case \"form\":\n            return \"form\";\n    };\n};//}}}\n\n@events\nexport class SmarkComponent {\n    constructor(//{{{\n        targetNode\n        , {\n            property_name = \"smark\",\n            ...options\n        } = {}\n        , parent\n    ) {\n        const me = this;\n\n        me.validName = (function nameGenerator() {//{{{\n            let counter = 0;\n            return function(...names){\n                if (me.parent.isSingleton) return \"\";\n                    // Singleton target components are unnamed.\n                for (\n                    let n0 of names\n                ) if (\n                    typeof n0 == \"string\"\n                ) {\n                    n0 = n0.trim();\n                    if (n0.length) return n0;\n                };\n                return 'UNNAMED'+(++counter);\n            };\n        })();//}}}\n\n        me.actions = {};\n        me.property_name = property_name;\n        me.selector = `[data-${me.property_name}],[data-${me.property_name}-type],[data-${me.property_name}-action]`;\n        me.types = componentTypes;\n        me.targetNode = targetNode;\n        me.options = options;\n        me.setNodeOptions(me.targetNode, me.options);\n\n        me.parent = parent;\n        if (! me.parent instanceof SmarkComponent) throw me.renderError(\n            'INVALID_PARENT'\n            , `Smark Components must have valid Smark Component parent.`\n        );\n        me.root = (\n            me.parent === null ? me\n            : me.parent.root\n        );\n\n        // Parents iterator:\n        me.parents = {};\n        me.parents[Symbol.iterator] = function* () {\n            let current = me.parent;\n            while (current) {\n                yield current;\n                current = current.parent;\n            };\n        };\n\n        // Calculate prefix or disable autoId:\n        const autoId = me.inheritedOption(\"autoId\", false);\n        me.genId = (\n            autoId === false ? false\n                // Do not auto-generate IDs.\n            : autoId === true ? p => p.replace(/\\//g, \"_\")\n                // Use \"_path_in_underscore_style\".\n            : typeof autoId == \"string\" ? p => autoId+p.replace(/\\//g, \"_\")\n                // Use \"prefix\" + \"_path_in_underscore_style\".\n            : typeof autoId == \"function\" ? autoId\n                // Use fn(path) custom style.\n            : false\n                // Failback to disabled.\n        );\n\n        me.onRenderedTasks = [];\n\n        let setRendered;\n        me.renderedSync = false;\n        me.rendered = new Promise(resolve => setRendered = resolve);\n\n        me.children = {};\n        me.targetNode[sym_smart] = me;\n\n        (async ()=>{\n            await me.render();\n            for (\n                const task of me.onRenderedTasks\n            ) await task();\n            me.onRenderedTasks = null;\n            setRendered(true);\n            setTimeout(()=>me.renderedSync = true, 1);\n            await me.emit(\"afterRender\", {\n                context: me\n            }, false);\n        })();\n        if (me.options.onRendered) me.onRendered(me.options.onRendered);\n\n    };//}}}\n    async unrender() {\n        const me = this;\n        await me.emit(\"beforeUnrender\", {\n            context: me\n        }, false);\n        me.targetNode.remove();\n    };\n    onRendered(cbk) {//{{{\n        const me = this;\n        if (me.onRenderedTasks) {\n            me.onRenderedTasks.push(cbk.bind(me));\n        } else {\n            cbk.bind(me)();\n        };\n    };//}}}\n    getNodeOptions(node, defaultOptions) {//{{{\n        const me = this;\n        let optionsSrc = (\n            node.dataset[me.property_name] || \"\"\n        ).trim() || null;\n        if (optionsSrc === \"data-\"+me.property_name) {\n            // Accept <input data-smark=\"data-smark\"> as special case since\n            // <input data-smark> is not automatically converted to\n            // data-smark=\"true\" by the browser like other tags.\n            optionsSrc = null;\n        };\n        let explicitOptions = parseJSON(optionsSrc);\n        if (! explicitOptions && optionsSrc !== null) {\n            if (re_valid_typename_chars.test(optionsSrc)) {\n                explicitOptions = {type: optionsSrc};\n            } else {\n                throw me.renderError(\n                    \"INVALID_OPTIONS_OBJECT\"\n                    , `data-${me.property_name}: must be a valid JSON object.`\n                );\n            };\n        };\n        // Read individual data-smark-<option_name> attributes:\n        const attrOptions = {};\n        const attrPrefix = me.property_name;\n        for (const [dataKey, dataValue] of Object.entries(node.dataset)) {\n            if (\n                ! dataKey.startsWith(attrPrefix)\n                || dataKey.length <= attrPrefix.length\n                || dataKey[attrPrefix.length] < 'A'\n                || dataKey[attrPrefix.length] > 'Z'\n            ) continue;\n            // Convert dataset key to option name (strip prefix, lowercase first letter):\n            const suffix = dataKey.slice(attrPrefix.length);\n            const optName = suffix[0].toLowerCase() + suffix.slice(1);\n            // Parse value as JSON or fall back to raw string:\n            const parsed = parseJSON(dataValue);\n            const optValue = parsed !== undefined ? parsed : dataValue;\n            // Check for conflict with explicit JSON options:\n            if (explicitOptions?.hasOwnProperty(optName)) {\n                if (JSON.stringify(explicitOptions[optName]) !== JSON.stringify(optValue)) {\n                    throw me.renderError(\n                        'DUPLICATE_OPTION'\n                        , `Option \"${optName}\" is specified both in data-${me.property_name} and as a data-${me.property_name}-* attribute with conflicting values.`\n                    );\n                };\n                continue; // Same value: already present, skip.\n            };\n            attrOptions[optName] = optValue;\n        };\n        const options = {\n            ...defaultOptions,\n            ...explicitOptions,\n            ...attrOptions,\n        };\n        const isSingletonTarget = (\n            me.isSingleton // New component's parent is a singleton\n            && options.type !== \"label\"           // And not a trigger\n            && ! options.hasOwnProperty(\"action\") // Neither a label\n        );\n        if (isSingletonTarget) {\n            // Merge singleton options into child component options:\n            for (const key of Object.keys(me.options)) {\n                if ( // Skip if...\n                    key === \"name\"\n                    || key === \"type\" && options[key] === \"label\"\n                ) continue;\n                if (options.hasOwnProperty(key)) {\n                    throw me.renderError(\n                        'SINGLETON_OPTION_CONFLICT',\n                        `Singleton field option defined both in parent and schild for key: ${key}.`\n                    );\n                };\n                if (key !== \"type\") {\n                    options[key] = me.options[key];\n                };\n            };\n        };\n        if (! options.action && ! options.type) options.type = inferType(node, me);\n        me.setNodeOptions(node, options);\n        return options;\n    };//}}}\n    setNodeOptions(node, options) {//{{{\n        const me = this;\n        node.dataset[me.property_name] = JSON.stringify(options);\n    };//}}}\n    async enhance(node, defaultOptions) {//{{{\n        const me = this;\n\n        // Sanityze and store options:{{{\n        let options = me.getNodeOptions(node, defaultOptions);\n        //}}}\n\n        // Prevent default behaviours:{{{\n        legacy.disEnhance(me);\n        //}}}\n\n        // Classify:{{{\n        if (options.action) {\n            if (! options.type) options.type = \"trigger\"; // Make type optional for triggers.\n            if (options.type != \"trigger\") throw me.renderError(\n                \"ACTION_IN_NON_TRIGGER\"\n                , `\"action\" property is only allowed for \"trigger\" components but \"${options.type}\" type specified.`\n            );\n        } else if (typeof options.type != \"string\") {\n            throw me.renderError(\n                \"NO_TYPE_PROVIDED\"\n                , `Invalid SmarkForm item: type is mandatory for non trigger components.`\n            );\n        };\n        //}}}\n\n        // Enhance:{{{\n        const ctrl = me.types[options.type];\n        if (! ctrl) throw me.renderError(\n            \"UNKNOWN_TYPE\"\n            , `Unimplemented SmarkForm component controller: ${options.type}`,\n        );\n        return new ctrl (\n            node\n            , options\n            , me\n        );\n        //}}}\n\n    };//}}}\n    getComponent(target) {//{{{\n        const me = this;\n        return (\n            target[sym_smart]\n            || target.parentElement?.closest(me.selector)[sym_smart]\n            || null\n        );\n    };//}}}\n    getPath() {//{{{\n        const me = this;\n        const ancestors = [...me.parents].map(p=>p.name).reverse();\n        if (me.name) ancestors.push(me.name); // Compute parent path inside labels (or singletons?).\n        return ancestors.join(\"/\") || \"/\";\n    };//}}}\n    find(path=\"\") { // {{{\n        const me = this;\n        let base = me;\n        while ( // Always detect real fields in singletons, labels and triggers.\n            ! base.name\n            && base.parent !== null // Not root form\n        ) {\n            base = base.parent;\n        };\n        path = String(path); // Allow numbers (arrays simply won't match).\n        if (path[0] == \"/\") while (base.parent) base = base.parent;\n        const parts = path\n            .split(\"/\")\n            .filter(x=>x)\n        ;\n        // (Recursive) Multi-match search (path with '*' wildcards):\n        // (Returns array of components)\n        const firstWildcardPos = parts.findIndex(p=>re_has_wildcards.test(p));\n        if (firstWildcardPos >= 0) {\n            const re_pattern = wild2regex(parts[firstWildcardPos]);\n            const pivotPath = parts.slice(0, firstWildcardPos).join(\"/\");\n            const restPath = parts.slice(firstWildcardPos + 1).join(\"/\");\n            const pivot = base.find(pivotPath);\n            const pivotChilds = Object.entries(pivot.children);\n            return pivotChilds\n                .filter(([name,child])=>child && re_pattern.test(name))\n                .map(([,child])=>child.find(restPath))\n                .flat(Infinity)\n            ;\n        };\n        // Straight search (wildcardless path)\n        // (Returns single component)\n        return parts.reduce(\n            (current, name)=>{\n                if (current === undefined) return;   // No match.\n                if (name == \"..\") return current.parent;  // Go up one level.\n                if ( // Special syntax for list siblings (.+n / .-n)\n                    name[0] == \".\"\n                ) {\n                    if (name == \".\") return current; // Current node.\n                    if (! current.parent) return; // Root node => no siblings.\n                    const delta = parseInt(name.slice(1));\n                    if (isNaN(delta)) return; // Invalid sibling syntax.\n                    if (current.parent.options.type == \"list\") {\n                        const n = parseInt(current.name) + delta\n                        if (! isNaN(n)) return current.parent.children[n];\n                    } else {\n                        const keys = Object.keys(current.parent.children);\n                        const currentPosition = keys.findIndex(key=>key==current.name);\n                        const newKey = keys[currentPosition + delta];\n                        return current.parent.children[newKey];\n                    };\n                } else {\n                    return current.children[name];\n                };\n            }\n            , base\n        );\n    };//}}}\n    inheritedOption(optName, defaultValue) {//{{{\n        const me = this;\n        for (\n            const p of [me, ...me.parents]\n        ) if (\n            p.options[optName] !== undefined\n        ) return p.options[optName];\n        return defaultValue;\n    };//}}}\n    moveTo(){//{{{\n        const me = this;\n        if (! me.targetNode.id) me.targetNode.id = me.getPath();\n        document.location.hash = me.targetNode.id;\n        // Avoid noisy url hash \"randomish\" effect:\n        window.history.pushState({}, undefined,window.location.pathname);\n            // Like 'document.location.hash = \"\"' but without leaving leading\n            // hash character.\n    };//}}}\n    getTriggers(actionNames = \"\", limit = Infinity) {//{{{\n        const me = this;\n        const myCurrentActions = [];\n        const actionKeys = new Set([actionNames]\n            .flat()\n            .map(String)\n            .filter(x=>x)\n        );\n        const returnAll = actionKeys.has(\"*\");\n        for (\n            const tgg\n            of [me, ...me.root.targetNode.querySelectorAll(me.selector)]\n                .map(target=>target[sym_smart])\n                .filter(x=>x) // Ignore not yet rendered.\n        ) {\n            const options = tgg.getTriggerArgs()\n            if (! options) continue; // Not a trigger\n            if (\n                ! Object.is(options.context, me) // Current context\n                && ! Object.is(tgg, me)          // Trigger focused itself\n            ) continue;\n            if (\n                returnAll\n                || actionKeys.has(options.action)\n            ) myCurrentActions.push(tgg);\n            if (myCurrentActions.length >= limit) break;\n        };\n        return myCurrentActions;\n    };//}}}\n    updateId() {//{{{\n        const me = this;\n        if (me.genId === false) return; // Abort if disabled.\n        const newId = me.genId(me.getPath());\n        if (me.targetNode.id != newId) {\n            me.targetNode.id = newId;\n            for (\n                const child\n                of Object.values(me.children)\n            ) child.updateId();\n        };\n        return me.targetNode.id\n    };//}}}\n    focus() {//{{{\n        const me = this;\n        for (const fname in me.children) {\n            // Pick first with minimal function calls.\n            return void me.children[fname].focus();\n        };\n        if (me.targetFieldNode) {\n            // Prefer fields over triggers, forms, etc...\n            me.targetFieldNode.focus();\n        } else {\n            me.targetNode.focus();\n        }\n    };//}}}\n    getTriggerArgs() {}; // Let's easily filter out non trigger compoenents.\n    // Error types:\n    renderError(code, message) {//{{{\n        const me = this;\n        const targetNode = (\n            me.parent?.isSingleton ? me.parent.targetNode\n            : me.targetNode\n        );\n        const error = new errors.renderError(code, message, me.getPath());\n        replaceWrongNode(targetNode, error);\n        return error;\n    };//}}}\n};\n\nexport function createType(name, controller) {//{{{\n    if (componentTypes[name] !== undefined) throw new Error(\n        `Duplicate component type definition: ${name}`\n    );\n    if (! (controller.prototype instanceof SmarkComponent)) throw new Error(\n        `Bad component type implementation for: ${name}`\n    );\n    componentTypes[name] = controller;\n};//}}}\n\n","// lib/hotkeys.js\n// ==============\n\n// const l = (label, cbk=x=>x)=>d=>(console.log(`${label}: `, cbk(d)), d);\n\nexport class hotKeys_handler {\n    constructor(form) {\n        const me = this;\n        me.form = form;\n        me.revealed = null;\n        const onStatusChange = hotKeys_handler.onStatusChange.bind(me);\n        me.form.targetNode.addEventListener(\"keydown\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"keyup\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"focusout\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"focusin\", onStatusChange, true);\n    };\n    static onStatusChange(ev) {\n        const me = this;\n\n        // Deactivation:\n        if (ev.type == \"keyup\") {\n            if (ev.key == \"Control\") return void me.reveal(false);\n            if (ev.key != \"Alt\") return;\n        };\n\n        // Focus leave:\n        if (ev.type == \"focusout\") {\n            if (me.revealed !== null) {\n                me.reveal(); // Unreveal, but keep activated.\n            };\n            return;\n        };\n\n        // Focus enter:\n        if (ev.type == \"focusin\" && me.revealed === null) {\n            return; // No hotkeys revealed.\n            // Otherwise behave as new activation\n        };\n\n        // Determine ctrlKey and altKey status properly:\n        // (Found differences between versions of the same browser)\n        const ctrlKey = ev.ctrlKey || ev.key == \"Control\";\n        const altKey = ev.altKey && ev.type != \"keyup\" || ev.key == \"Alt\" && ev.type == \"keydown\";\n        // ev.type is \"keydown\" (or \"keyup\" in case of Alt) or \"focusin\"\n        const activation = (\n            // Pressing ctrl key with or without alt key\n            ctrlKey && (ev.key == \"Control\" || ev.key == \"Alt\")\n            // Reentering focus after some action without deactivation\n            || ev.type == \"focusin\"\n        );\n\n        // (Re)activation:\n        if (activation) {\n            const level = altKey ? 2 : 1;\n            // Activate and reveal:\n            return void me.reveal(ev.target, level);\n        };\n\n        // Hotkey stroke:\n        if (me.revealed instanceof Array) {\n            const targettedTrigger = me.revealed.find(\n                t=>t.options.hotkey == ev.key\n            );\n            if (targettedTrigger) {\n                // Prevent default and stop propagation:\n                //   Even if disabled to avoid weird behaviour with repetitions\n                //   (Ex. using \"+\" to add items to a list would zoom in\n                //   some browsers when max_items is reached).\n                ev.preventDefault();\n                ev.stopPropagation();\n                // Perform the action:\n                if (! targettedTrigger.targetNode.disabled) {\n                    // Unless trigger is disabled\n                    targettedTrigger.targetNode.click();\n                };\n            };\n        };\n\n    };\n    reveal(target, level = 1) {\n        const me = this;\n\n        // Conceal previous target triggers' hotkeys if any:\n        if (me.revealed !== null) {\n            for (const t of me.revealed) {\n                t.targetNode.removeAttribute(\"data-hotkey\");\n            };\n            me.revealed.length = 0;\n        };\n\n        if (target === false) {\n            me.revealed = null; // Deactivate hot keys\n        };\n\n        if (target) {\n\n            // Reveal new target triggers' hotkeys:\n            const component = me.form.getComponent(target);\n            const activeContexts = getActiveContexts(component);\n            const candidateTriggers = activeContexts\n                // .map(l(\"activeContexts\", ({name, targetNode})=>({name, targetNode})))\n                .map((ctx, distance)=>{\n                    const candidates = [];\n                    for (const tg of ctx.getTriggers('*')) {\n                        const hotkey = String(tg.options.hotkey || \"\");\n                        if (hotkey == \"\") continue; // Ignore triggers without hotkey.\n                        const args = tg.getTriggerArgs() || {};\n                        candidates.push({\n                            tg,\n                            distance,   // Number of ancestors levels.\n                            args,\n                            hotkey,\n                        });\n                    };\n                    return candidates;\n                })\n                // .map(l(\"Triggers\", tlist=>tlist.map(({hotkey, distance, tg, args})=>({hotkey, distance, tg, args}))))\n                .flat()\n                .sort((ta,tb)=>{\n                    const atargetnode = ta.args.target?.targetNode;\n                    const btargetnode = tb.args.target?.targetNode;\n                    const bcontained = btargetnode ? .5 * btargetnode.contains(component.targetNode) : 0;\n                    const acontained = atargetnode ? .5 * atargetnode.contains(component.targetNode) : 0;\n                    const retv = (\n                        // Prefer triggers with nearest context:\n                        + ta.distance - tb.distance\n                        // Prefer triggers contained in ancestors (not siblings):\n                        + bcontained - acontained\n                    );\n                    // if (true || ta.hotkey == \"-\" && tb.hotkey == \"-\") {\n                    //     console.log(`--(${ta.hotkey} - ${tb.hotkey})------------------------------------------------`);\n                    //     console.log(\"--\", ta.tg.targetNode, tb.tg.targetNode, component.targetNode);\n                    //     console.log(\"--\", ta.distance, tb.distance, - tb.distance + ta.distance);\n                    //     console.log(\"--\", + acontained, + bcontained, + bcontained - acontained);\n                    //     console.log(`===========> ${retv}`);\n                    // };\n                    return retv;\n                })\n            ;\n\n            const seen = new Map(); // hotkey => [times seen, distance from target]\n            me.revealed = [];\n\n            for (const candidate of candidateTriggers) {\n                const [times, distance] = seen.get(candidate.hotkey) || [1, 0];\n                if (times < level) {\n                    seen.set(candidate.hotkey, [times + 1, candidate.distance]);\n                    continue; // Level not reached.\n                };\n                if (times > level) {\n                    continue; // Used by more preferent tg.\n                };\n                if (\n                    Object.is(candidate.tg.targetNode, target)\n                    || candidate.distance > distance\n                ) { // Don't pick more than one per \"ancestory\" level.\n                    if (! candidate.tg.targetNode.disabled) {\n                        candidate.tg.targetNode.setAttribute(\"data-hotkey\", candidate.hotkey);\n                    };\n                    me.revealed.push(candidate.tg); // Let stroke detection know it matched.\n                    // Avoid activating the following candidates by \"oveflowing\" their times seen count:\n                    // (UX): Do it even if disabled for behavioral consistency...\n                    seen.set(candidate.hotkey, [times + 1, candidate.distance]);\n                };\n            };\n\n        };\n\n    };\n};\n\nfunction getComponentSiblings(context) {\n    const children = context.parent?.children || [];\n    const position = Object.keys(children).findIndex((name)=>(name === context.name));\n    const brothers = Object.values(children);\n    const backwards = brothers.slice(0, position).reverse();\n    const forwards = brothers.slice(position + 1);\n    return [...forwards, ...backwards];\n};\n\nfunction getActiveContexts(component) {\n    const upwards = [component, ...component.parents];\n    return [\n        ...upwards,\n        ...upwards.map(getComponentSiblings).flat()\n    ];\n};\n\n","// types/trigger.type.js\n// =====================\nimport {SmarkComponent} from \"../lib/component.js\";\n\nexport const action = function action_decorator(targetMtd, {kind, name, addInitializer}) {\n    if (kind == \"method\") addInitializer(function registerAction() {\n        const me = this;\n        this.actions[name] = async function (data, options = {}) {\n            // Actions are async functions that can be triggered by trigger\n            // components.\n            // They receive data and options as arguments.\n            // They emit BeforeAction_<name> and AfterAction_<name> events.\n            // The options argument is passed to event handlers as is but with\n            // data property set to data argument.\n            // If a BeforeAction_<name> event handler calls event.preventDefault(),\n            // the action is cancelled.\n            // Some actions may accept a \"focus\" option to focus the target component\n            // after the action is performed. When tey are executed via trigger components,\n            // the default value of that option is true.\n            if (! Object.hasOwnProperty(options, \"focus\")) options.focus = true;\n            let defaultPrevented = false;\n            options.data = data;\n            if (! options.silent) {\n                defaultPrevented = ! await me.emit(`BeforeAction_${name}`, options);\n                data = options.data; // Update data in case it was modified by event handlers.\n            };\n            if (defaultPrevented) return; // Action cancelled by event handler.\n            // Cal the method implementing the action.\n            // It receives data and options arguments.\n            // Here options.data is set to the input data argument.\n            // After execution, options.data is updated with the returned data.\n            data = await targetMtd.call(me, data, options);\n            options.data = data;\n            if (! options.silent) {\n                me.emit(`AfterAction_${name}`, options);\n            };\n            // The resulting action method returns the data returned by the\n            // original method.\n            // Options object can be mutated inside the original method and\n            // that mutations will be visible to the AfterAction_xxxx event\n            // handlers.\n            return data;\n        };\n    });\n};\n\nexport class trigger extends SmarkComponent {\n    constructor(node, options, ...args){\n        delete options.name; // Triggers are always unnamed.\n        return super(node, options, ...args);\n    };\n    render(){\n        const me = this;\n        me.parent.onRendered(()=>{\n            const triggerArgs = me.getTriggerArgs();\n            if (\n                typeof triggerArgs.context?.onTriggerRender == \"function\"\n            ) triggerArgs.context.onTriggerRender(triggerArgs);\n        });\n    };\n    disable() {//{{{\n        const me = this;\n        me.targetNode.disabled = true;\n    };//}}}\n    enable() {//{{{\n        const me = this;\n        me.targetNode.disabled = false;\n    };//}}}\n    getTriggerArgs() {//{{{\n        const me = this;\n        const parents = [me, ...me.parents];\n        const {\n            // property: local variable\n            action,\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n        if (! action) return; // Not a trigger component.\n\n        const context = (\n            contextPath ? me.parent.find(contextPath)\n            : parents.find(p=>(typeof p.actions[action] == \"function\"))\n        );\n\n        const target = (\n            targetPath ? context?.find(targetPath) // Explicit target (context relative)\n            : contextPath ? null // Explicit context path => don't mind component position\n            : (\n                parents\n                    .slice(1) // Skip self\n                    .find(p=>p.parent?.targetNode.isSameNode(context?.targetNode))\n                || null\n            )\n        );\n\n        return {\n            action,\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n\nexport async function onTriggerClick(ev) {\n    const me = this;\n    const triggerComponent = me.getComponent(ev.target);\n    const options = triggerComponent.getTriggerArgs();\n    if (! options) return; // Not a trigger.\n    const {context, action, data} = options;\n    const mtd = context?.actions[action]\n    if (\n        typeof mtd != \"function\"\n    ) throw me.renderError(\n        \"UNKNOWN_ACTION\"\n        , `Unknown action ${action}`\n        + (context ? ` for ${context.options.type}` : \"\")\n    );\n    return await mtd(data, options);\n};\n\n\n","// types/label.type.js\n// ===================\nimport {SmarkComponent} from \"../lib/component.js\";\nimport {randomId} from \"../lib/helpers.js\";\nimport {getRoots} from \"../lib/helpers.js\";\n\nexport class label extends SmarkComponent {\n    constructor(node, {allow_select = false, ...options}, ...args){\n        delete options.name; // Labels are always unnamed.\n        super(node, {allow_select, ...options}, ...args);\n        const me = this;\n        me.eventHooks.click.push(\n            function click_hook(ev) {\n                // Mimic native label behavior for non-native fields:\n                if (ev.defaultPrevented) return;\n                const {target} = me.getLabelArgs();\n                if (\n                    ! target?.targetFieldNode\n                    || (me.nodeType === \"legend\")\n                ) target.focus();\n            },\n        );\n    };\n    async render(){\n        const me = this;\n        // Enhance triggers inside the label:\n        let childField = null;\n        for (\n            const node\n            of getRoots(me.targetNode, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            if (!! newItem?._isField) {\n                if (childField !== null) throw me.renderError(\n                    'EXTRA_FIELD_IN_LABEL'\n                    , `Labels can wrap only one target field, but multiple fields found in form ${me.getPath()}.`\n                );\n                if (me.options.target !== undefined) {\n                    throw me.renderError(\n                        'LABEL_EXPLICIT_TARGET'\n                        , `Labels wrapping their target field cannot define explicit target option in form ${me.getPath()}.`\n                    );\n                };\n                childField = newItem;\n                childField.parent = me.parent;\n                me.parent.mountField(childField);\n            };\n        };\n        me.parent.onRendered(async ()=>{\n            const me = this;\n            me.nodeType = String(me.targetNode.tagName).toLowerCase();\n            const labelArgs = me.getLabelArgs();\n            const labelledField = labelArgs.target || {};\n            await labelledField.rendered; // Ensure target field is rendered.\n            if (labelledField.targetFieldNode) { // Apply only to native inputs (scalars)\n                if (! labelledField.targetFieldNode.id) { // Ensure targetted field has an Id\n                    labelledField.targetFieldNode.id = randomId();\n                };\n                me.targetNode.setAttribute(\"for\", labelledField.targetFieldNode.id);\n            };\n\n            // Automatically link label and field for screen readers:\n            if (\n                me.nodeType != \"label\"   // Not a native <label>\n            ) {\n                // Ensure label has an Id:\n                if (! me.targetNode.id) {\n                    me.targetNode.id = randomId();\n                };\n                // Get previous aria-labelledby values:\n                const alb_arr = (\n                    labelledField.targetNode.getAttribute(\"aria-labelledby\")\n                    || \"\"\n                )\n                    .split(\" \")\n                    .filter(id => id)\n                ;\n                // Add label id if not already present:\n                if (0 > alb_arr.indexOf(me.targetNode.id)) {\n                    alb_arr.push(me.targetNode.id);\n                };\n                // Reinject updated list:\n                labelledField.targetNode.setAttribute(\n                    \"aria-labelledby\"\n                    , alb_arr.join(\" \")\n                );\n            } else {\n                if (! labelledField.targetFieldNode) {\n                    throw me.renderError(\n                        'LABEL_FOR_NONFIELD'\n                        , `Native <label> tags targetting non native field are not allowed in HTML, you should use different tag.`\n                    );\n                };\n            };\n\n            // Make labels non-selectable unless \"allow_select\" option is set\n            // to true.\n            if (! me.options.allow_select) {\n                me.targetNode.style[\"user-select\"] = \"none\";\n            };\n        });\n    };\n    getLabelArgs() {//{{{\n        const me = this;\n        let context, target;\n\n        const {\n            // property: local variable\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n\n        if (! contextPath && ! targetPath) {\n            // Guess ;-)\n            context = me.parent;\n            if (\n                me.nodeType === \"legend\"\n                && context.targetNode.tagName.toLowerCase() === \"fieldset\"\n            ) {\n                target = Object.values(context.children)[0]; // First child of fieldset\n            } else {\n                const candidates = context.targetNode.querySelectorAll(me.selector);\n                let found = false;\n                for (const childName in candidates) {\n                    if (found) {\n                        let targetComponent = me.getComponent(candidates[childName]);\n                        if (targetComponent?._isField) {\n                            target = targetComponent;\n                            break;\n                        };\n                    } else if (\n                        Object.is(candidates[childName], me.targetNode)\n                    ) {\n                        found = true;\n                    };\n                };\n            };\n        } else {\n            context = (\n                contextPath ? me.parent.find(contextPath)\n                : me.parent\n            );\n            target = (\n                targetPath ? context.find(targetPath) // Explicit target (context relative)\n                : context\n            );\n        };\n\n        return {\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n","// lib/field.js\n// ============\n\nimport {SmarkComponent} from \"./component.js\";\nimport {action} from \"../types/trigger.type.js\";\n\nexport class SmarkField extends SmarkComponent {\n    constructor(...args){\n        super(...args);\n        this._isField = true;\n        this.defaultValue = undefined; // Should be redefined by derived classes.\n        this.emptyValue = undefined;   // Type-level empty value (for clear action)\n        if (! Object.is(this, this.root)) {\n            this.name = this.validName(\n                this.options.name\n                , this.targetNode.getAttribute(\"name\")\n            );\n        };\n        const hasValueAttr = this.targetNode.getAttribute(\"value\") !== null;\n        const hasValueOption = this.options.hasOwnProperty(\"value\");\n        if (hasValueAttr && hasValueOption) { // Conflict\n            throw this.renderError(\n                'VALUE_CONFLICT'\n                , `Initial value specied both as \"value\" option and HTML \"value\" attribute.`\n            );\n        };\n        this.onRendered(async ()=>{\n            // This situation won't occur until after rendering, allowing\n            // for modifications to defaultValue in constructors of\n            // derived classes.\n            this.defaultValue = (\n                hasValueOption ? this.options.value\n                : hasValueAttr ? this.targetNode.getAttribute(\"value\")\n                : this.emptyValue\n            );\n            if ( this.targetFieldNode) {\n                this.targetNode.setAttribute(\"value\", this.defaultValue);\n            };\n            await this.reset(null, {silent: true, focus: false});\n        });\n    };\n    @action\n    async clear(_data, options = {}) {//{{{\n        // Clear removes all user-provided values, resetting to type-level empty state\n        // (ignoring any configured defaults)\n        await this.import(this.emptyValue, {silent: true, setDefault: false, ...options});\n    };//}}}\n    @action\n    async reset(_data, options = {}) {//{{{\n        // Reset reverts to the configured default values (including any prepopulated defaults)\n        await this.import(undefined, {silent: true, ...options});\n    };//}}}\n    // Note: Future 'null' action would explicitly set the entire form/field to null.\n    // For nested forms, this would set the form value to null rather than clearing fields.\n    // Implementation placeholder for when null action is needed:\n    // @action\n    // async null(_data, options = {}) {\n    //     // Set the entire form/field to null (not clearing individual fields)\n    //     await this.import(null, {silent: true, ...options});\n    // }\n};\n\n","\nimport {action} from \"../types/trigger.type.js\";\n\nexport const foldable = function foldable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class foldableTarget extends target {\n            render(...args) {//{{{\n                const retv = super.render(...args);\n                const me = this;\n                me.root.onRendered(()=>{\n                    me.fold(null, {\n                        operation: ( !! me.options.folded ? \"fold\" : \"unfold\"),\n                        autofocus: false, // Never focus during initial render\n                    });\n                });\n                return retv;\n            };//}}}\n            @action\n            fold(_data, {//{{{\n                operation = \"toggle\", // Values: \"fold\" / \"unfold\" / \"toggle\"\n                origin,\n                autofocus = true,\n            } = {}) {\n                const me = this;\n                const wasFolded = me.targetNode.style.display == \"none\";\n                const isFolded = (\n                    operation == \"fold\" ? true\n                    : operation == \"unfold\" ? false\n                    : ! wasFolded\n                );\n                me.targetNode.style.display = (\n                    isFolded ? \"none\"\n                    : me.originalDisplayProp\n                );\n\n                me.getTriggers(\"fold\").forEach(tgg => {\n                    const {foldedClass, unfoldedClass} = tgg.options;\n                    if (foldedClass) tgg.targetNode.classList[\n                        isFolded ? \"add\"\n                        : \"remove\"\n                    ](foldedClass);\n                    if (unfoldedClass) tgg.targetNode.classList[\n                        isFolded ? \"remove\"\n                        : \"add\"\n                    ](unfoldedClass);\n                });\n\n                me.getTriggers([\"addItem\", \"removeItem\"]).map(\n                    isFolded ? tgg => tgg.disable()\n                    : tgg => tgg.enable()\n                );\n\n                // Set focus accordingly:\n                autofocus && (isFolded ? origin : me)?.focus();\n            };//}}}\n        };\n    };\n};\n","// src/decorators/export_to_target.deco.js\n// =======================================\n\nexport const export_to_target = function export_to_target_decorator(method, {kind}) {\n    if (kind == \"method\") {\n        return async function export_mtd(data, {target, ...options}={}) {\n            const me = this;\n            const value = await method.call(me, data, options);\n            try {\n                await target.import(value);\n            } catch (error) {\n                // target not provided or invalid\n            };\n            return value;\n        };\n    };\n};\n","// src/decorators/import_from_target.deco.js\n// =========================================\n\nexport const import_from_target = function import_from_target_decorator(method, {kind}) {\n    if (kind == \"method\") {\n        return async function import_mtd(data, {target, ...options}={}) {\n            const me = this;\n            try {\n                data = await target.export();\n            } catch (error) {\n                // target not provided or invalid\n            };\n            return await method.call(me, data, options);\n        };\n    };\n};\n","// types/form.type.js\n// ==================\n\nimport {SmarkField} from \"../lib/field.js\";\nimport {action} from \"./trigger.type.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {getRoots, parseJSON} from \"../lib/helpers.js\";\n\n@foldable\nexport class form extends SmarkField {\n    constructor(...args) {\n        super(...args);\n        const me = this;\n        me.defaultValue = {};\n        me.emptyValue = {}; // Type-level empty state for clear action\n        // Focus forms on click (likewise to field types):\n        this.eventHooks.click.push ( ev => {\n            if (\n                ev.defaultPrevented\n                // Unless focus_on_click explicitly set to false\n                || ! me.inheritedOption('focus_on_click', true)\n            ) return;\n            this.focus();\n        });\n    };\n    mountField(newItem) {\n        const me = this;\n        if (!! newItem?._isField) {\n            if (me.children[newItem.name] !== undefined) throw me.renderError(\n                'REPEATED_FIELD_NAME'\n                , `Field name '${newItem.name}' used more than once in this form level.`\n            );\n            me.children[newItem.name] = newItem;\n            newItem.updateId();\n        };\n    };\n    async render() {//{{{\n        const me = this;\n        me.originalDisplayProp = me.targetNode.style.display;\n        // Enhance childs:\n        for (\n            const node\n            of getRoots(me.targetNode, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            me.mountField(newItem);\n        };\n    };//}}}\n    @action\n    @export_to_target\n    async export(_data, {exportEmpties} = {}) {//{{{\n        const me = this;\n        return Object.fromEntries(\n            await Promise.all(Object.entries(me.children).map(\n                async ([key, child])=>[key, await child.export(null, {silent: true, exportEmpties})]\n            ))\n        );\n    };//}}}\n    @action\n    @import_from_target\n    async import(data, {focus = false, silent = false, setDefault = true} = {}) {//{{{\n        const me = this;\n        const isReset = data === undefined;\n        if (isReset) {\n            data = me.defaultValue; // Undefined clears to default:\n        } else if (data === \"\") {\n            data = {};\n        }\n        // Ensure data is a plain object (or valid JSON string):\n        const dataConstructor = Object(data).constructor;\n        if (\n            dataConstructor !== {}.constructor // Not a plain object\n            && ! (data = parseJSON(data))      // Neither a (valid) JSON string\n        ) throw new Error(\n            'FORM_NOT_PLAIN_OBJECT'\n            , `Expected plain object or vailid JSON for form import, ${dataConstructor.name} given.`\n        );\n        const childSetDefault = !isReset && setDefault;\n        const retv = Object.fromEntries(\n            await Promise.all(\n                Object.entries(me.children).map(\n                    async ([key, target]) => {\n                        // Could have used target.then(...) but, event\n                        // components' import() method SHOULD be async, it\n                        // would have failed in case it's not.\n                        // Forcing it to be async is not possible because\n                        // transpilers would break this check.\n                        // ...and, IMHO, this approach is better than a dirty\n                        // Promise.resolve(...)\n                        const value = await target.import(data[key], {focus: focus && !silent, silent, setDefault: childSetDefault});\n                        return [key, value];\n                    }\n                )\n            )\n        );\n        if (childSetDefault) {\n            me.defaultValue = await me.export(null, {silent: true, exportEmpties: true});\n        };\n        if (focus && !silent) me.focus();\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of Object.values(me.children)\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n};\n","// types/list.decorators/smartdisabling.deco.js\n// ============================================\n\nasync function updateTriggers(context) {\n    for (const tg of context.getTriggers([\"removeItem\", \"addItem\"])) {\n        tg.targetNode.disabled = (\n            tg.options.action == \"removeItem\" ? (\n                context.children.length <= context.min_items\n                && tg.options.failback != \"clear\" // Unless clearing function\n            )\n            : context.children.length >= context.max_items\n        );\n    };\n};\n\nexport const smartdisabling = function list_smartdisabling_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class smartdisablingClass extends target {\n            async render(...args) {//{{{\n                const retv = await super.render(...args);\n                await updateTriggers(this);\n                return retv;\n            };//}}}\n        };\n    } else if (kind == \"method\") {\n        return async function smartdisablingMethod(...args) {\n            const retv = await target.call(this, ...args);\n            updateTriggers(this);\n            return retv;\n        };\n    };\n};\n","// types/list.decorators/focusretention.deco.js\n// ============================================\n\n// Keep focus inside the list when it becomes empty so that new items can be added through keyboard.\n// (Also focusing addItem trigger allows to re-add it with just hitting Space or Enter key)\nexport const focusretention = function list_focusretention_decorator(target, {kind}) {\n    if (kind == \"method\") {\n        return async function focusretentionMethod(_data, options, ...args) {\n            const me = this;\n            const retv = await target.call(me, _data, options, ...args);\n            if (\n                !! options?.focus\n                && me.count() === 0\n            ) {\n                const someAddItemTrigger = me.getTriggers(\"addItem\", 1)[0];\n                if (someAddItemTrigger) {\n                    someAddItemTrigger.targetNode.focus();\n                };\n            };\n            return retv;\n        };\n    };\n};\n","\nconst sym_mux = Symbol(\"smart_mutex\");\n\nclass Mutex {\n    constructor() {\n        this.mtx = Promise.resolve();\n    };\n    lock() {\n        // Sync operation:\n        let nextResolve;\n        const nextMtx = new Promise(resolve => {\n            nextResolve = () => resolve();\n        });\n        const currMtx = this.mtx;\n        this.mtx = nextMtx;\n        // Async behaviour:\n        return currMtx.then(function unlock() {\n            return nextResolve\n        });\n    };\n}\n\nexport const mutex = function method_mutex_decorator(muxName) {\n    return function mutex_decorator(target, {kind}) {\n        if (kind == \"method\") {\n            return async function muxed_target(...args) {\n                const me = this;\n                if (! me[sym_mux]) me[sym_mux] = {};\n                if (! me[sym_mux][muxName]) me[sym_mux][muxName] = new Mutex();\n                const unlock = await me[sym_mux][muxName].lock(); // Await previous muxed call (if any)\n                let err, retv;\n                try {\n                    retv = await target.call(me, ...args);\n                } catch (error) {\n                    err = error;\n                };\n                unlock();\n                if (err) throw err;\n                return retv;\n            };\n\n        };\n    };\n};\n","// types/list.decorators/sortable.deco.js\n// ======================================\n\nimport {mutex} from \"../../decorators/mutex.deco.js\";\n\nexport const sortable = function list_sortable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class sortableTarget extends target {\n            async render(...args) {//{{{\n                const retv = await super.render(...args);\n                const me = this;\n\n                me.sortable = !! me.options.sortable;\n                me.templates.item.setAttribute(\"draggable\", me.sortable);\n                me.children.forEach(c=>c.targetNode.setAttribute(\"dragable\", me.sortable));\n                if (me.sortable) {\n                    let dragSource = null;\n                    let dragDest = null;\n                    me.targetNode.addEventListener(\"dragstart\", e => {\n                        if (dragSource === null) {\n                            dragSource = e.target\n                            e.stopPropagation();\n                        } else {\n                            // Single dragging at a time.\n                            e.preventDefault();\n                        };\n                    });\n                    me.targetNode.addEventListener(\"dragover\", e => e.preventDefault());\n                    me.targetNode.addEventListener(\"drop\", e => {\n                        if (! dragSource) return; // Already dropped\n                        let target = e.target;\n                        while (\n                            target.parentElement\n                            && target.parentElement != dragSource.parentElement\n                        ) target = target.parentElement;\n                        dragDest = target;\n                    });\n                    me.targetNode.addEventListener(\"dragend\", async () => {\n                        if (dragDest)  await me.move({\n                            from: me.getComponent(dragSource),\n                            to: me.getComponent(dragDest),\n                        });\n                        dragSource = null;\n                        dragDest = null;\n                    });\n                };\n\n                return retv;\n            };//}}}\n            @mutex(\"list_mutating\")\n            async move(options = {}) {//{{{\n                const me = this;\n                let {\n                    from,\n                    to,\n                } = options;\n\n                // // FIXME: Avoid nested sortables to interact.\n                // console.log({from, to}); // <--- See this!!!\n\n                //\n                // TODO: Convert to action!!!\n                //\n                if (\n                    to === null // Dropped outside\n                    || from === null // (Shouldn't happen)\n                ) return;\n                const fromi = Number(from?.name);\n                const toi = Number(to?.name);\n                if (fromi == toi) {\n                    return;\n                } else if (fromi < toi) {\n                    const newChunk = [\n                        ...me.children.slice(fromi + 1, toi + 1),\n                        me.children[fromi],\n                    ];\n                    me.children.splice(fromi, toi - fromi + 1, ...newChunk);\n                } else if (fromi > toi) {\n                    const newChunk = [\n                        me.children[fromi],\n                        ...me.children.slice(toi, fromi),\n                    ];\n                    me.children.splice(toi, fromi - toi + 1, ...newChunk);\n                };\n                const inc = fromi < toi ? 1 : -1;\n                const moveMethod = inc > 0 ? \"after\" : \"before\";\n                to.targetNode[moveMethod](from.targetNode);\n                me.renum();\n            };//}}}\n        };\n    };\n};\n","// types/list.type.js\n// ==================\n\nimport {SmarkField} from \"../lib/field.js\";\nimport {smartdisabling} from \"./list.decorators/smartdisabling.deco.js\";\nimport {focusretention} from \"./list.decorators/focusretention.deco.js\";\nimport {action} from \"./trigger.type.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {sortable} from \"./list.decorators/sortable.deco.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {mutex} from \"../decorators/mutex.deco.js\";\nimport {makeRoom, getRoots, parseJSON, setTabIndex} from \"../lib/helpers.js\";\n\n// Private helpers:\n// ----------------\n\nfunction loadTemplates(me) {//{{{\n    const templates = {};\n    for (const child of [...me.targetNode.children]) {\n        const {role = \"item\"} = parseJSON(child.getAttribute(\"data-smark\")) || {};\n        switch (role) {\n            case \"empty_list\":\n            case \"header\":\n            case \"separator\":\n            case \"last_separator\":\n            case \"footer\":\n            case \"placeholder\": // (Only with max_items defined)\n                child.setAttribute(\"data-role\", role);\n            case \"item\": // (Default)\n                if (templates[role] !== undefined) throw me.renderError(\n                    'LIST_DUPLICATE_TEMPLATE'\n                    , `Repated list template role ${role}`\n                );\n                templates[role] = child;\n                templates[role].remove();\n            break;\n        };\n    };\n    if (me.targetNode.children.length) {\n        const {role = \"(unspecified)\"} = parseJSON(\n            me.targetNode.children[0].getAttribute(\"data-smark\")\n        ) || {};\n        throw me.renderError(\n            'LIST_UNKNOWN_TEMPLATE_ROLE'\n            , `Unknown list template role ${role}`\n        );\n    };\n    if (! templates.last_separator) {\n        templates.last_separator = templates.separator; // (If any)\n    };\n    if (\n        templates.item.querySelector(\"[id]\") !== null // Contains IDs\n    ) throw me.renderError(\n        'LIST_CONTAINS_ID'\n        , `List components are not allowed to contain elements with 'id' attribute`\n    );\n    return templates;\n};//}}}\n\n\n// List component type:\n// --------------------\n\n@foldable\n@sortable\n@smartdisabling\nexport class list extends SmarkField {\n    constructor(...args) {\n        super(...args);\n        const me = this;\n        me.defaultValue = [];\n        me.emptyValue = []; // Type-level empty state for clear action\n    };\n    async #appendChild(child) {//{{{\n        const me = this;\n        if (me.templates.header) {\n            me.templates.header.after(child);\n        } else {\n            me.targetNode.appendChild(child);\n        };\n    };//}}}\n    async render () {//{{{\n        const me = this;\n        me.originalDisplayProp = me.targetNode.style.display;\n\n        me.min_items = Math.max(0,\n            typeof me.options.min_items == \"number\" ? me.options.min_items\n            : 1\n        );\n        me.max_items = Math.max(me.min_items,\n            typeof me.options.max_items == \"number\" ? me.options.max_items\n            : Infinity\n        );\n        me.children = [];\n        me.templates = loadTemplates(me);\n        me.placeholders = [];\n        const tplOptions = me.getNodeOptions(\n            me.templates.item\n            , {\n                type: me.options.of, // Allow to specify items type from list declaration.\n            }\n        );\n        if (\n            me.options.of\n            && tplOptions.type != me.options.of\n        ) throw me.renderError(\n            'LIST_ITEM_TYPE_MISSMATCH'\n            , `List item type missmatch`\n        );\n\n        for (const tpl of [\n            me.templates.header,\n            me.templates.footer,\n        ]) if (!! tpl) {\n            me.targetNode.appendChild(tpl);\n            // Enhance childs:\n            for (\n                const node\n                of getRoots(tpl, me.selector)\n            ) {\n                const newItem = await me.enhance(node);\n                if (!! newItem?._isField) {\n                    throw me.renderError(\n                        'FIELD_IN_WRONG_LIST_TEMPLATE'\n                        , `Fields are not allowed in list's template roles other than item.`\n                    );\n                };\n            };\n        };\n\n        // onRendered tweaks:\n        me.root.onRendered(async ()=>{\n            // Only add items up to min_items, skipping any already added\n            // by a parent default-value import that ran before this task.\n            for(let i=me.children.length; i<me.min_items; i++) await me.addItem(null, {silent: true});\n\n            // Initialize \"count\" actions and reinject empty_list template:\n            if (me.min_items == 0) await me.renum();\n\n            // Let screen readers know lists may change.\n            me.targetNode.setAttribute(\"aria-live\", \"polite\");\n            me.targetNode.setAttribute(\"aria-atomic\", \"true\");\n        });\n    };//}}}\n    onTriggerRender({action, origin, context}) {//{{{\n        switch (action) {\n            case \"addItem\":\n            case \"removeItem\":\n                if (\n                    // Placed inside\n                    (1 + [...origin.parents].findIndex(p=>Object.is(p, context)))\n                    && origin.options.hotkey\n                ) {\n                    // Skip them in keyboard navigation.\n                    setTabIndex(origin.targetNode);\n                };\n                break;\n        };\n    };//}}}\n    @mutex(\"list_mutating\")\n    @action\n    @export_to_target\n    async export(_data, {exportEmpties: forceExportEmpties} = {}) {//{{{\n        const me = this;\n        const list = [];\n        const emptyChilds = [];\n        const stripEmpties = forceExportEmpties !== undefined\n            ? ! forceExportEmpties\n            : ! me.inheritedOption(\"exportEmpties\", false);\n        for (const child of me.children) {\n            if (stripEmpties && await child.isEmpty()) {\n                if (list.length < me.min_items) emptyChilds.push(child);\n                continue;\n            };\n            list.push(await child.export(null, {silent: true, exportEmpties: forceExportEmpties}));\n        };\n        for (let i=0; list.length < me.min_items; i++) {\n            list.push(await emptyChilds[i].export(null, {silent: true, exportEmpties: forceExportEmpties}));\n        };\n        return list;\n    };//}}}\n    @action\n    @import_from_target\n    @mutex(\"list_import\")\n    async import(data, {focus = false, silent = false, setDefault = true} = {}) {//{{{\n        const me = this;\n        const isReset = data === undefined;\n        // Undefined clears to default:\n        if (isReset) data = me.defaultValue;\n        // Auto-update in case of scalar to array template upgrade:\n        if (! (data instanceof Array)) data = [data];\n        const childSetDefault = !isReset && setDefault;\n        // Load data:\n        const top = Math.min(data.length, me.max_items);\n        for (\n            let i = 0;\n            i < top; // Limit to allowed items\n            i++\n        ) {\n            if (me.children.length <= i) await me.addItem(null, {silent: true}); // Make room on demand\n            await me.children[i].import(data[i], {focus: focus && !silent, silent, setDefault: childSetDefault});\n        };\n        // Remove extra items if possible (over min_items):\n        for (\n            let i = Math.max(data.length, me.min_items);\n            i < me.children.length;\n        ) await me.removeItem(null, {silent: true});\n        // Report if data doesn't fit:\n        if (data.length > me.max_items) {\n            me.emit(\"error\", {\n                code: 'LIST_IMPORT_OVERFLOW',\n                message: `Trying to import array greater than list's max_items. Data beyond max_items ignored.`,\n                context: me,\n                data,\n                options: me.options,\n            });\n        };\n        // Reset items over imported data if min_items is greater:\n        for (\n            let i = data.length;\n            i < me.children.length; // (Due to min_items)\n            i++\n        ) me.children[i].reset({silent: true});\n        if (childSetDefault) {\n            me.defaultValue = await me.export(null, {silent: true, exportEmpties: true});\n        };\n        if (focus && !silent) me.focus();\n        return; // await me.export(null, {silent: true});\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    @smartdisabling\n    async addItem(_data, options = {}) {//{{{\n        const me = this;\n        // Parameters checking and resolution:{{{\n        options.action = \"addItem\";\n        options.origin ||= null; // (Internal call)\n        options.context ||= me;  // (Internal call)\n        options.source ||= null; // Source component to copy data from.\n        options.target ||= null; // Target child component to insert before/after.\n        options.position ||= \"after\";\n        options.autoscroll ||= null;   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n        options.failback ||= \"throw\";  // \"none\" / \"throw\" (default)\n        options.silent ||= false;       // When true, don't focus the new item\n        if (options.position != \"after\" && options.position != \"before\") throw me.renderError(\n            'LIST_WRONG_ADDITEM_POSITION'\n            , `Invalid value for addItem() position property: ${options.position}`\n        );\n        if (me.children.length >= me.max_items) {\n            switch (options.failback) {\n                case \"none\":\n                    break;\n                case \"throw\":\n                default:\n                    me.emit(\"error\", {\n                        code: 'LIST_MAX_ITEMS_REACHED',\n                        message: `Cannot add items over max_items boundary`,\n                        options,\n                    });\n            };\n            return;\n        };\n        if (me.children.length && ! options.target) options.target = ( // Auto target:\n            options.position == \"before\" ?  me.children[0] // Insert at the beginning\n            : me.children[me.children.length - 1]  // Append at the end\n        );\n        //}}}\n        // DOM element creation:{{{\n        const newItemTarget = me.templates.item.cloneNode(true);\n        //}}}\n        // Child component creation and insertion:{{{\n        let newItem;\n        if (! me.children.length) {\n            await me.#appendChild(newItemTarget);\n            newItem = await me.enhance(newItemTarget, {type: \"form\", name: 0});\n            await newItem.rendered;\n            me.children.push(newItem);\n            newItem.name = 0;\n        } else {\n            me.children = (await Promise.all(\n                me.children.map(async (child, i)=>{\n                    if (! child.targetNode.isSameNode(options.target.targetNode)) {\n                        return child;\n                    } else {\n                        // Append or prepend new item to the target child:\n                        child.targetNode[options.position](newItemTarget);\n                            // Note that options.position is ensured to be \"after\" or \"before\" above.\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        const chunk = [child, newItem];\n                        // Ensure correct order:\n                        if (options.position == \"before\") chunk.reverse();\n                        return chunk; // Array that will be flattened later...\n                    };\n                })\n            ))\n                .flat()\n            ;\n        };\n        await me.renum();\n        //}}}\n        // Copy data from source component if specified:{{{\n        if (options.source) {\n            const sourceComponent = newItem.find(options.source);\n            if (!! sourceComponent) {\n                const data = await sourceComponent.export();\n                await newItem.import(data, {silent: true});\n            };\n        };\n        //}}}\n        // Autoscroll handling:{{{\n        if (options.autoscroll == \"elegant\" && !! newItem) {\n            makeRoom(newItem.targetNode, - newItem.offsetHeight);\n        } else {\n            const moveTarget = (\n                ! newItem ? null\n                : options.autoscroll == \"self\" ? newItem\n                : options.autoscroll == \"parent\" ? newItem.parent\n                : null\n            );\n            if (moveTarget) moveTarget.moveTo();\n        };\n        //}}}\n        if (me.renderedSync && !options.silent) newItem.focus();\n        return newItem;\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    @smartdisabling\n    @focusretention\n    async removeItem(_data, options = {}) {//{{{\n        const me = this;\n        options.action = \"removeItem\";\n        options.origin ||= null; // (Internal call)\n        options.context ||= me;  // (Internal call)\n        options.target ||= null; // Target child component to remove.\n        options.autoscroll ||= null;   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n        let preserve_non_empty = options.preserve_non_empty ||= false;\n        options.failback ||= \"throw\";  // \"none\" / \"clear\" / \"throw\" (default)\n        if (! options.target) {\n            if (preserve_non_empty) for (\n                const t of [...me.children]\n                .reverse() // Pick last first\n            ) if (await t.isEmpty()) {\n                options.target = t;\n                break;\n            };\n            if (! options.target) {\n                options.target = me.children[me.children.length - 1];\n                preserve_non_empty = false;\n                // Allow non empty removal as last chance if no target\n                // specified.\n            };\n        };\n        const targets = (\n            options.target instanceof Array ? options.target\n            : [options.target]\n        );\n        for (const currentTarget of [...targets].reverse()) {\n            if (me.children.length <= me.min_items) {\n                switch (options.failback) {\n                    case \"none\":\n                        break;\n                    case \"clear\":\n                        await currentTarget.clear({silent: true});\n                        return;\n                    case \"throw\":\n                    default:\n                        me.emit(\"error\", {\n                            code: 'LIST_MIN_ITEMS_REACHED',\n                            message: `Cannot remove items under min_items boundary`,\n                            options,\n                        });\n                        return;\n                };\n            };\n            if (preserve_non_empty && ! await currentTarget.isEmpty()) continue;\n            // Locate target child and rebuild children array without it:{{{\n            let oldItem = null;\n            let newFocusPosition = null;\n            const newChildren = me.children\n                .filter((child, i, all)=>{\n                    if (child.targetNode.isSameNode(currentTarget.targetNode)) {\n                        if (options.autoscroll == \"elegant\") {\n                            makeRoom(child.targetNode, child.targetNode.offsetHeight);\n                        } else {\n                            const moveTarget = (\n                                options.autoscroll == \"self\" ? child\n                                : options.autoscroll == \"parent\" ? child.parent\n                                : null\n                            );\n                            if (moveTarget) moveTarget.moveTo();\n                        };\n                        oldItem = child;\n                        newFocusPosition = (\n                            (all.length -i > 1) ? newFocusPosition = i // More above\n                            : i == 0 ? null           // No items left\n                            : i - 1                   // Removing last item\n                        );\n                        return false;\n                    };\n                    return true;\n                })\n            ;\n            // }}}\n            // Perform removal:{{{\n            await me.emit(\"removeItem_beforeRender\", {\n                ...options,\n                target: oldItem,\n                targetNode: oldItem.targetNode,\n            }, false);\n            await oldItem.unrender();\n            me.children = newChildren;\n            await me.renum();\n            await me.emit(\"removeItem_afterRender\", {\n                ...options,\n                target: oldItem,\n                targetNode: oldItem.targetNode,\n            }, false);\n            if (newFocusPosition !== null && !options.silent) {\n                me.children[newFocusPosition].focus();\n            };\n            // }}}\n        };\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of me.children\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    count(_data, {delta = 0} = {}) {//{{{\n        // Return number of children.\n        // But also it's sole existence allow reinjecting contents to it.\n        const me = this;\n        return me.children.length + Number(delta);\n    };//}}}\n    @action\n    position(_data, {target, offset = 1} = {}) {//{{{\n        return Number(target?.name) + Number(offset);\n    };//}}}\n    async renum(){//{{{\n        const me = this;\n\n        // Update child index:\n        for (const i in me.children) {\n            me.children[i].name = i;\n            me.children[i].updateId();\n        };\n\n        // Handle separators:\n        if (\n            !! me.templates.separator\n            || !! me.templates.last_separator\n        ) for (const i in me.children) {\n\n            const isLastNode = i >= me.children.length - 1;\n            const sepRole = (\n                i <= 0 ? null\n                : isLastNode ? \"last_separator\"\n                : \"separator\"\n            );\n\n            const currentNode = me.children[i].targetNode;\n            const prevNode = currentNode.previousElementSibling;\n            const prevNode_role = prevNode && prevNode.getAttribute(\"data-role\");\n            if (prevNode_role !== sepRole) {\n                if (!! prevNode_role) prevNode.remove();\n                const sepTemplate = me.templates[sepRole];\n                if (!! sepRole && !! sepTemplate) currentNode.parentElement.insertBefore(sepTemplate.cloneNode(true), currentNode);\n            };\n            if (isLastNode) { // LastItem\n                const nextNode = currentNode.nextElementSibling;\n                if (!! nextNode) nextNode.remove();\n            };\n\n        };\n\n        // Handle empty_list template:\n        if (me.templates.empty_list) {\n            if (me.children.length) {\n                me.templates.empty_list.remove(); // (from DOM)\n            } else {\n                await me.#appendChild(me.templates.empty_list);\n            };\n        };\n\n        // Handle placeholder template:\n        if (\n            me.templates.placeholder\n            && !! me.max_items // (Only if we have a finite padding limit)\n        ) {\n            let placeHoldersCount = (me.max_items || 0) - me.children.length;\n            if (\n                placeHoldersCount > 0\n                && me.children.length === 0\n                && !! me.templates.empty_list\n            ) placeHoldersCount--; // Discount the hole occupied by empty_list\n            if (me.placeholders.length < placeHoldersCount) {\n                for (let i = me.placeholders.length; i < placeHoldersCount; i++) {\n                    const placeholder = me.templates.placeholder.cloneNode(true);\n                    if (me.templates.footer) {\n                        me.templates.footer.before(placeholder);\n                    } else {\n                        me.targetNode.appendChild(placeholder);\n                    };\n                    me.placeholders.push(placeholder);\n                };\n            } else { // me.placeholders.length >= placeHoldersCount\n                for (let i = me.placeholders.length; i > placeHoldersCount; i--) {\n                    me.placeholders.pop().remove();\n                };\n            };\n        };\n\n        // Update counter triggers:\n        me.getTriggers(\"position\").forEach(tgg=>{\n            const me = this;\n            const args = tgg.getTriggerArgs();\n            tgg.targetNode.innerText = me.position(args.data, {...args, silent: true});\n        });\n        me.getTriggers(\"count\").forEach(tgg=>{\n            const me = this;\n            const args = tgg.getTriggerArgs();\n            tgg.targetNode.innerText = me.count(args.data, {...args, silent: true});\n        });\n    };//}}}\n};\n","// types/input.type.js\n// ===================\nimport {form} from \"./form.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {parseJSON} from \"../lib/helpers.js\";\nexport class input extends form {\n    constructor(...args) {//{{{\n        super(...args);\n        const me = this;\n        me.defaultValue = \"\";\n        me.emptyValue = \"\"; // Type-level empty state for clear action\n        me.eventHooks.keydown.push(\n            function keydown_hook(ev) {\n                if (ev.defaultPrevented) return;\n                if (ev.originalEvent.key === \"Enter\") {\n                    const backwards = ev.originalEvent.shiftKey;\n                    if (\n                        ev.context.targetNode.tagName === \"TEXTAREA\"\n                        && ! ev.originalEvent.ctrlKey\n                        && ! backwards\n                    ) return; // Require Ctrl key to escape textareas.\n                    let nextField = (\n                        ! backwards ? ev.context.find(\".+1\") || ev.context.find(\"../.+1\")\n                        : ev.context.find(\".-1\") || ev.context.find(\"../.-1\")\n                    );\n                    if (nextField) {\n                        nextField.focus();\n                        ev.originalEvent.preventDefault();\n                        ev.originalEvent.stopPropagation();\n                    };\n                };\n            },\n        );\n    }; // }}}\n    _setTargetFieldValue(value) {//{{{\n        const me = this;\n        if (me.isSingleton) return; // (Only for real field)\n        me.targetFieldNode.value = value;\n    };//}}}\n    async render() {//{{{\n        const me = this;\n        me.isSingleton = ! (\n            me.targetNode.tagName === \"INPUT\"\n            || me.targetNode.tagName === \"SELECT\"\n            || me.targetNode.tagName === \"TEXTAREA\"\n        );\n        me.isCheckbox = (\n            ! me.isSingleton\n            && String(me.targetNode.type).toLowerCase() == \"checkbox\"\n        );\n        if (me.isSingleton) {\n            await super.render();\n            const sons = Object.values(me.children);\n            if (sons.length != 1) throw me.renderError(\n                'NOT_A_SINGLETON'\n                , `Singleton forms are only allowed to contain exactly one`\n                + ` data field but ${sons.length} found.`\n            );\n            const son = sons[0];\n            if (me.options.type !== son.options.type) throw me.renderError(\n                'SINGLETON_TYPE_MISMATCH'\n                , `Singleton type (${me.options.type})`\n                + ` does not match child field type (${son.options.type}).`\n            );\n            me.targetFieldNode = son.targetNode;\n        } else {\n            me.targetFieldNode = me.targetNode;\n        };\n    };//}}}\n    @action\n    @export_to_target\n    async export(_data, options) {//{{{\n        const me = this;\n        if (me.isSingleton) return await me.children[\"\"].export(_data, options);\n        const nodeFld = me.targetFieldNode;\n        let retv;\n        if (me.isCheckbox) {\n            retv = !! nodeFld.checked;\n        } else if (\n            me.options.encoding === \"json\"\n            && nodeFld.tagName.toUpperCase() === \"SELECT\"\n            && nodeFld.options[nodeFld.selectedIndex]?.getAttribute(\"value\") === null\n        ) {\n            // Keep fallback working when encoding is json and value attribute is not set.\n            // (and don't expetct <opton> inner text to be JSON)\n            retv = JSON.stringify(nodeFld.options[nodeFld.selectedIndex].text);\n        } else {\n            retv = nodeFld.value;\n        };\n        return (\n            me.options.encoding === \"json\" ? parseJSON(retv) || null\n            : retv\n        );\n    };//}}}\n    @action\n    @import_from_target\n    async import(data, options = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await me.children[\"\"].import(data, options);\n        const isReset = data === undefined;\n        // Undefined clears to default:\n        if (isReset) data = me.defaultValue;\n        let {focus = false, silent = false, setDefault = true} = options;\n        const nodeFld = me.targetFieldNode;\n        if (\n            typeof data === \"object\"\n            && me.options.type === \"input\"    // Not in a derivated field types\n            || me.options.encoding === \"json\" // JSON encoding specified\n        ) {\n            data ||= null;\n            const isTextarea = nodeFld.tagName.toUpperCase() === \"TEXTAREA\";\n            data = (\n                isTextarea ? JSON.stringify(data, null, 4) // Pretty print\n                : JSON.stringify(data) // Compact print\n            ) || \"\";\n        };\n        if (me.isCheckbox) {\n            me.targetNode.checked = !! data;\n        } else if (\n            me.options.encoding === \"json\"\n            && nodeFld.tagName.toUpperCase() === \"SELECT\"\n        ) {\n            me._setTargetFieldValue(data || \"null\"); // Faster, but won't work if value attribute is not set.\n            if (nodeFld.selectedIndex === -1) {\n                // Fallback when value attribute is not set.\n                const parsed = parseJSON(data) || \"\";\n                const idx = Array.from(nodeFld.options).findIndex(\n                    opt => opt.text === parsed\n                );\n                if (idx !== -1) nodeFld.selectedIndex = idx;\n            };\n        } else {\n            me._setTargetFieldValue(data);\n        };\n        if (!isReset && setDefault) {\n            me.defaultValue = await me.export(null, {silent: true});\n        };\n        if (focus && !silent) me.focus();\n        return me.targetNode.value;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = (\n            me.isCheckbox ? \"\" // Do not consider checkboxes.\n            : await me.export(null, {silent: true})\n        );\n        return ! value.trim().length;\n            // Native input's value type is always a string.\n    };//}}}\n};\n","// types/number.type.js\n// ====================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {validateInputType} from \"../lib/helpers.js\";\nexport class number extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        try {\n            validateInputType(\n                me.targetFieldNode,\n                \"number\",\n                'NOT_A_NUMBER_FIELD',\n                `Number inputs require an INPUT tag of type \"number\".`\n            );\n        } catch (error) {\n            throw me.renderError(error.code, error.message);\n        }\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        return (\n            data.length && ! isNaN(data) ? Number(data)\n            : null\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import(data, options = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await super.import(data, options); // Overload only inner field\n        // Undefined clears to default:\n        if (data === undefined) data = me.defaultValue;\n        const typename = typeof data;\n        return await super.import((\n            typename == \"number\" ? data\n            : typename == \"string\" && data.length && ! isNaN(data) ? Number(data)\n            : null\n        ), options);\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export(null, {silent: true});\n        return value === null;\n    };//}}}\n};\n","// types/date.type.js\n// ==================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {validateInputType} from \"../lib/helpers.js\";\nconst re_timePart = /T.*/;\nfunction parseDateStr(str) {//{{{\n    // Accept \"YYYYMMDD\":\n    if (str.length == 8) return new Date([\n        str.substring(0, 4),\n        str.substring(4, 6),\n        str.substring(6, 8),\n    ].join(\"-\"));\n\n    // Accept \"YYYY-MM-DD\" (like date inputs)\n    // > new Date(\"2023-11-30\")\n    // 2023-11-30T00:00:00.000Z\n    // ...but don't accept if not zero-padded:\n    // > new Date(\"2023-11-3\")\n    // 2023-11-02T23:00:00.000Z\n    if (\n        str.length == 10\n        && str[4] == \"-\"\n        && str[7] == \"-\"\n    ) return new Date(str);\n\n    // Also don't accept other locale dependant formats:\n    // > new Date(\"11/30/2023\")\n    // 2023-11-29T23:00:00.000Z\n\n    return NaN;\n};//}}}\nfunction ISODate(value) {//{{{\n    return value.toISOString().replace(re_timePart, \"\");\n};//}}}\nexport class date extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        try {\n            validateInputType(\n                me.targetFieldNode,\n                \"date\",\n                'NOT_A_DATE_FIELD',\n                `Date inputs require an INPUT tag of type \"date\".`\n            );\n        } catch (error) {\n            throw me.renderError(error.code, error.message);\n        }\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        if (! data.length) return null;\n        const value = parseDateStr(data);\n        return (\n            isNaN(value) ? null\n            : ISODate(value)\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import(data = null, options = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await super.import(data, options); // Overload only inner field\n        const value = (\n            data instanceof Date ? data // Accept Date instance\n            : typeof data == \"number\" ? new Date(data) // Accept epoch\n            : ! data || (typeof data != \"string\") ? NaN // Reject nullish\n            : parseDateStr(data) // Handle strings\n        );\n        const retv = await super.import((\n            isNaN(value) ? null\n            : ISODate(value)\n        ), options);\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export(null, {silent: true});\n        return value === null;\n    };//}}}\n};\n","// types/time.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {parseTime, validateInputType} from \"../lib/helpers.js\";\n\nfunction ISOTime(value) {//{{{\n    // Extract time from Date object in HH:mm:ss format\n    const hours = String(value.getHours()).padStart(2, '0');\n    const minutes = String(value.getMinutes()).padStart(2, '0');\n    const seconds = String(value.getSeconds()).padStart(2, '0');\n    return `${hours}:${minutes}:${seconds}`;\n};//}}}\n\nexport class time extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        try {\n            validateInputType(\n                me.targetFieldNode,\n                \"time\",\n                'NOT_A_TIME_FIELD',\n                `Time inputs require an INPUT tag of type \"time\".`\n            );\n        } catch (error) {\n            throw me.renderError(error.code, error.message);\n        }\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        if (! data.length) return null;\n        const value = parseTime(data);\n        return value; // Already in HH:mm:ss format or null\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import(data = null, options = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await super.import(data, options); // Overload only inner field\n        const value = (\n            data instanceof Date ? ISOTime(data) // Accept Date instance\n            : typeof data == \"number\" ? ISOTime(new Date(data)) // Accept epoch\n            : ! data || (typeof data != \"string\") ? null // Reject nullish or non-strings\n            : parseTime(data) // Handle strings\n        );\n        const retv = await super.import(value, options);\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export(null, {silent: true});\n        return value === null;\n    };//}}}\n};\n","// types/datetime-local.type.js\n// ==============================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {parseDateTime, validateInputType} from \"../lib/helpers.js\";\n\nfunction ISODateTimeLocal(value) {//{{{\n    // Format as YYYY-MM-DDTHH:mm:ss (local time, no timezone)\n    const year = String(value.getFullYear()).padStart(4, '0');\n    const month = String(value.getMonth() + 1).padStart(2, '0');\n    const day = String(value.getDate()).padStart(2, '0');\n    const hours = String(value.getHours()).padStart(2, '0');\n    const minutes = String(value.getMinutes()).padStart(2, '0');\n    const seconds = String(value.getSeconds()).padStart(2, '0');\n    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;\n};//}}}\n\nexport class datetimeLocal extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        try {\n            validateInputType(\n                me.targetFieldNode,\n                \"datetime-local\",\n                'NOT_A_DATETIME_LOCAL_FIELD',\n                `Datetime-local inputs require an INPUT tag of type \"datetime-local\".`\n            );\n        } catch (error) {\n            throw me.renderError(error.code, error.message);\n        }\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        if (! data.length) return null;\n        const value = parseDateTime(data);\n        return (\n            isNaN(value) ? null\n            : ISODateTimeLocal(value)\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import(data = null, options = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await super.import(data, options); // Overload only inner field\n        const value = (\n            data instanceof Date ? data // Accept Date instance\n            : typeof data == \"number\" ? new Date(data) // Accept epoch\n            : ! data || (typeof data != \"string\") ? NaN // Reject nullish\n            : parseDateTime(data) // Handle strings\n        );\n        const retv = await super.import((\n            isNaN(value) ? null\n            : ISODateTimeLocal(value)\n        ), options);\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export(null, {silent: true});\n        return value === null;\n    };//}}}\n};\n","// types/radio.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {randomId, validateInputType} from \"../lib/helpers.js\";\nexport class radio extends input {\n    constructor(...args) {\n        super(...args);\n        const me = this;\n        let master = me.parent.children[me.name];\n        let retv = me;\n        if (master) {\n            me.targetNode.setAttribute(\"name\", master.sharedNodeName);\n            master.radioButtons.push(me.targetNode);\n            retv = {}; // Not the master field.\n        } else {\n            master = me;\n            // Provide unique name for DOM navigation to work properly:\n            master.sharedNodeName = randomId();\n            master.targetNode.setAttribute(\"name\", master.sharedNodeName);\n            master.radioButtons = [\n                master.targetNode\n            ];\n        };\n        let changeEventHandler = onRadioInteraction.bind(master);\n        me.targetNode.addEventListener(\"click\", changeEventHandler);\n        me.targetNode.addEventListener(\"keydown\", changeEventHandler);\n        return retv;\n    };\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        try {\n            validateInputType(\n                me.targetFieldNode,\n                \"radio\",\n                'NOT_A_RADIO_FIELD',\n                `Radio inputs require an INPUT tag of type \"radio\".`\n            );\n        } catch (error) {\n            throw me.renderError(error.code, error.message);\n        }\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        return this.radioButtons.find(r=>r.checked)?.value || null;\n    };//}}}\n    @action\n    @import_from_target\n    async import(data = null, {focus = false} = {}) {//{{{\n        if (! this.radioButtons) return; // Prevent initialization import from non master radios.\n        const selected = this.radioButtons.find(r=>r.value === data);\n        if (selected) {\n            selected.checked = true;\n        } else {\n            this.radioButtons.forEach(r=>r.checked = false);\n        };\n        if (focus) this.focus();\n    };//}}}\n    async isEmpty() {//{{{\n        return ! (1 + this.radioButtons.findIndex(r=>r.checked));\n    };//}}}\n};\n\nfunction onRadioInteraction(event) {//{{{\n    if (\n        event.type === \"click\"\n        || event.type === \"keydown\" && event.code === \"Delete\"\n        // NOTE: Some browsers also send fake click events for toggling radio\n        //       buttons.\n        //       This approach avoids to interfere with that behavior while\n        //       ensuring a consistent keyboard resetting method (through the\n        //       Delete key).\n    ) {\n        const me = this;\n        let checked = true; // All raddio buttons become checked on click.\n        const lastSelection = Object.is(me.lastClicked?.target, event.target);\n        if (lastSelection) checked = (\n            ! me.lastClicked.checked    // Click  => Toggle\n            && event.type !== \"keydown\" // Delete => Reset\n        );\n        me.lastClicked = {\n            target: event.target,\n            checked,\n        };\n        event.target.checked = checked;\n    };\n};//}}}\n","// types/color.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {validateInputType} from \"../lib/helpers.js\";\nconst re_color = /^#([a-f0-9]{3}){1,2}$/i;\nconst disabled_style = `\n    opacity: .5;\n    background: repeating-linear-gradient(\n            45deg,\n            black,\n            black 10px,\n            white 10px,\n            white 20px\n        ),\n        black;\n    background-blend-mode: difference;\n`;\nexport class color extends input {\n    constructor(...args) {\n        super(...args);\n        const me = this;\n        me.defaultValue = null; // Default value is null (undefined color)\n        me.emptyValue = null;   // Type-level empty state for clear action\n        // Add keydown hook to handle \"Delete\" key:\n        this.eventHooks.keydown.push ( ev => {\n            if (ev.defaultPrevented) return;\n            if (ev.originalEvent.key === \"Delete\") {\n                ev.context.clear();\n            };\n        });\n    };\n    _setTargetFieldValue(value) {//{{{\n        const me = this;\n        if (me.isSingleton) return; // (Only for real field)\n        let isValidNativeValue = re_color.test(value)\n        if (value?.length == 4) value = `#${value[1]}${value[1]}${value[2]}${value[2]}${value[3]}${value[3]}`;\n        me.targetFieldNode.value = (\n            isValidNativeValue ? value.toLowerCase()\n            : \"#000000\"\n        );\n    };//}}}\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        if (me.isSingleton) return; // (Only for real field)\n        me._setTargetFieldValue(me.targetFieldNode.getAttribute(\"value\"));\n        // Check targetField's type attribute:\n        try {\n            validateInputType(\n                me.targetFieldNode,\n                \"color\",\n                'NOT_A_COLOR_FIELD',\n                `Color inputs require an INPUT tag of type \"color\".`\n            );\n        } catch (error) {\n            throw me.renderError(error.code, error.message);\n        }\n\n        // Iniitialize me.isDefined flag:\n        const valueAttr = me.targetFieldNode.getAttribute(\"value\");\n        me.isDefined = (\n            valueAttr !== null         // value property not defined\n            && valueAttr.trim() !== \"\" // value property defined (string)\n        );\n\n        // Remember original \"style\" attribute and update if appropriate:\n        me.defaultStyleAttr = me.targetFieldNode.getAttribute(\"style\") || \"\";\n        if (!! me.defaultStyleAttr) me.defaultStyleAttr += \"; \";\n\n        if (! me.isDefined) me.targetFieldNode.setAttribute(\n            \"style\"\n            , me.defaultStyleAttr + disabled_style\n        );\n\n        // Handle me.isDefined set:\n        const resetDefined = ev=>{\n            if (\n                ev.code    !== \"Enter\"\n                && ev.Code !== \"Space\"\n                && ev.code !== undefined // ev.type must be \"click\" or \"change\"\n                    // && ev.type !== \"click\" // Click event\n                    // && ev.type !== \"change\" // Change event\n            ) return;\n            me.isDefined = true;\n            me.targetFieldNode.setAttribute(\"style\", me.defaultStyleAttr);\n        };\n        me.targetFieldNode.addEventListener(\"keydown\", resetDefined);\n        me.targetFieldNode.addEventListener(\"click\", resetDefined);\n        me.targetFieldNode.addEventListener(\"change\", resetDefined);\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        let data = await super.export(...args);\n        if (! me.isSingleton) data = (\n            me.isDefined && re_color.test(data) ? data.toLowerCase()\n            : null\n        );\n        return data;\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import(data, options = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await me.children[\"\"].import(data, options);\n        // Undefined clears to default:\n        if (data === undefined) data = me.defaultValue;\n        if (\n            data === null              // Explicit null value\n            || ! re_color.test(data)  // Invalid color value\n        ) {\n            me.isDefined = false;\n            me.targetFieldNode.setAttribute(\n                \"style\"\n                , me.defaultStyleAttr + disabled_style\n            );\n        } else {\n            me.isDefined = true;\n            if (data?.length == 4) data = `#${data[1]}${data[1]}${data[2]}${data[2]}${data[3]}${data[3]}`;\n            me.targetFieldNode.setAttribute(\"style\", me.defaultStyleAttr);\n        };\n        const value = await super.import(data, options);\n        return (\n            me.isDefined ? value\n            : null\n        );\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export(null, {silent: true});\n        return value === null;\n    };//}}}\n};\n\n","// SmarkForm.js\n// ============\n\nimport {createType} from \"./lib/component.js\";\nimport {hotKeys_handler} from \"./lib/hotkeys.js\";\n\n// Import core component types and event handlers:\nimport {trigger, onTriggerClick} from \"./types/trigger.type.js\";\nimport {label} from \"./types/label.type.js\";\nimport {form} from \"./types/form.type.js\";\nimport {list} from \"./types/list.type.js\";\nimport {input} from \"./types/input.type.js\";\nimport {number} from \"./types/number.type.js\";\nimport {date} from \"./types/date.type.js\";\nimport {time} from \"./types/time.type.js\";\nimport {datetimeLocal} from \"./types/datetime-local.type.js\";\nimport {radio} from \"./types/radio.type.js\";\nimport {color} from \"./types/color.type.js\";\n\n\n// Load core component types:\nfor (const [name, controller] of Object.entries({\n    trigger,\n    label,\n    form,\n    list,\n    input,\n    number,\n    date,\n    time,\n    \"datetime-local\": datetimeLocal,\n    radio,\n    color,\n})) createType(name,controller);\n\n\nclass SmarkForm extends form {\n    constructor(\n        targetNode\n        , {\n            customActions = {},\n            ...formOptions\n        } = {}\n    ) {\n        const options = {\n            ...formOptions,\n            name: \"\",\n            type: \"form\",\n        };\n        super(\n            targetNode\n            , options\n            , null // (Root has no parent)\n        );\n        const me = this;\n        me.setNodeOptions(me.targetNode, options);\n        me.actions = {\n            ...me.actions,\n            ...Object.fromEntries(\n                Object.entries(customActions)\n                    .map(([name, ctrl])=>[name, ctrl.bind(me)])\n            ),\n        };\n        me.targetNode.addEventListener(\n            \"click\"\n            , onTriggerClick.bind(me)\n            , true\n        );\n        new hotKeys_handler(me);\n    };\n    async render() {\n        const me = this;\n        me.targetNode.setAttribute(\"aria-busy\", \"true\");\n        await super.render();\n        me.targetNode.setAttribute(\"aria-busy\", \"false\");\n    };\n};\n\nSmarkForm.createType = createType;\n\nexport default SmarkForm;\n\n"],"names":["getRoots","target","selector","isTop","parentNode","n","isSameNode","querySelectorAll","filter","e","closest","makeRoom","element","pixels","parent","direction","scrollHeight","clientHeight","maxScroll","scrollTop","randomId","Math","random","toString","substring","parseJSON","str","JSON","parse","err","parseTime","length","hours","parseInt","minutes","seconds","join","parseDateTime","date","time","Date","match","NaN","validateInputType","targetFieldNode","expectedType","errorCode","errorMessage","targetTag","tagName","targetType","getAttribute","toLowerCase","error","Error","code","type","sym_local_events","Symbol","sym_all_events","re_actionEvHandler","re_localEvHandler","re_allEvHandler","supportedFieldEventTypes","registerEvHandler","evList","evType","evHandler","has","set","get","push","bind","this","events","targetComponentType","_ref","kind","constructor","optionsSrc","options","onOptionCallbacks","key","value","Object","entries","test","_len","arguments","args","Array","_key","super","me","Map","onLocal","onAll","on","eventHooks","parentStore","arrayStore","prop","defineProperty","Proxy","_dynamic","createArrayPuller","is","root","targetNode","addEventListener","ev","targetComponent","getComponent","evData","originalEvent","context","preventDefault","stopPropagation","stopImmediatePropagation","emit","evt","handler","listenLevel","targetHandlers","parents","parentHandlers","eventHook","legacy","disEnhance","event","componentTypes","sym_smart","re_valid_typename_chars","re_has_wildcards","errors","message","path","stack","split","slice","_SmarkComponent","SmarkComponent","property_name","undefined","validName","counter","isSingleton","names","n0","trim","actions","types","setNodeOptions","renderError","iterator","current","autoId","inheritedOption","setRendered","genId","p","replace","onRenderedTasks","renderedSync","rendered","Promise","resolve","children","render","task","setTimeout","onRendered","unrender","remove","cbk","getNodeOptions","node","defaultOptions","dataset","explicitOptions","attrOptions","attrPrefix","dataKey","dataValue","startsWith","suffix","optName","parsed","optValue","hasOwnProperty","stringify","keys","action","parentComponent","String","inferType","enhance","ctrl","parentElement","getPath","ancestors","map","name","reverse","find","base","parts","x","firstWildcardPos","findIndex","re_pattern","wname","RegExp","pivotPath","restPath","pivot","child","_ref2","flat","Infinity","reduce","delta","isNaN","currentPosition","newKey","defaultValue","moveTo","id","document","location","hash","window","history","pushState","pathname","getTriggers","limit","myCurrentActions","actionKeys","Set","returnAll","tgg","getTriggerArgs","updateId","newId","values","focus","fname","errorNode","createElement","setAttribute","appendChild","createTextNode","clicableNode","textContent","console","replaceWith","replaceWrongNode","static","_staticBlock","_initClass","_applyDecs","c","createType","controller","prototype","hotKeys_handler","form","revealed","onStatusChange","reveal","ctrlKey","altKey","level","targettedTrigger","t","hotkey","disabled","click","removeAttribute","component","activeContexts","upwards","getComponentSiblings","getActiveContexts","candidateTriggers","ctx","distance","candidates","tg","sort","ta","tb","atargetnode","btargetnode","bcontained","contains","acontained","seen","candidate","times","position","brothers","backwards","targetMtd","addInitializer","async","data","defaultPrevented","silent","call","trigger","triggerArgs","onTriggerRender","disable","enable","contextPath","targetPath","otherOptions","origin","onTriggerClick","mtd","label","allow_select","getLabelArgs","nodeType","childField","newItem","_isField","mountField","labelledField","alb_arr","indexOf","style","found","childName","SmarkField","_initProto","emptyValue","hasValueAttr","hasValueOption","reset","clear","_data","import","setDefault","foldable","retv","fold","operation","folded","autofocus","wasFolded","display","isFolded","originalDisplayProp","forEach","foldedClass","unfoldedClass","classList","export_to_target","method","import_from_target","export","_form","exportEmpties","fromEntries","all","isReset","dataConstructor","childSetDefault","isEmpty","updateTriggers","min_items","failback","max_items","smartdisabling","focusretention","count","someAddItemTrigger","sym_mux","Mutex","mtx","lock","nextResolve","nextMtx","currMtx","then","mutex","muxName","unlock","sortable","_moveDecs","templates","item","dragSource","dragDest","move","from","to","fromi","Number","toi","newChunk","splice","moveMethod","renum","_list","list","header","after","_exportDecs","_importDecs","_addItemDecs","_removeItemDecs","max","role","last_separator","separator","querySelector","loadTemplates","placeholders","tplOptions","of","tpl","footer","i","addItem","setTabIndex","forceExportEmpties","emptyChilds","stripEmpties","top","min","removeItem","source","autoscroll","newItemTarget","cloneNode","chunk","sourceComponent","offsetHeight","moveTarget","preserve_non_empty","targets","currentTarget","oldItem","newFocusPosition","newChildren","offset","isLastNode","sepRole","currentNode","prevNode","previousElementSibling","prevNode_role","sepTemplate","insertBefore","nextNode","nextElementSibling","empty_list","placeholder","placeHoldersCount","before","pop","innerText","input","keydown","shiftKey","nextField","_setTargetFieldValue","isCheckbox","sons","son","nodeFld","checked","encoding","toUpperCase","selectedIndex","text","idx","opt","number","typename","re_timePart","parseDateStr","ISODate","toISOString","ISOTime","getHours","padStart","getMinutes","getSeconds","ISODateTimeLocal","getFullYear","getMonth","getDate","datetimeLocal","radio","master","sharedNodeName","radioButtons","changeEventHandler","onRadioInteraction","r","selected","lastClicked","re_color","disabled_style","color","isValidNativeValue","valueAttr","isDefined","defaultStyleAttr","resetDefined","Code","SmarkForm","customActions","formOptions"],"mappings":"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"}