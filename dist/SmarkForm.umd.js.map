{"version":3,"file":"SmarkForm.umd.js","sources":["../src/lib/helpers.js","../src/lib/events.js","../src/lib/legacy.js","../src/lib/component.js","../src/lib/hotkeys.js","../src/types/trigger.type.js","../src/types/label.type.js","../src/decorators/foldable.deco.js","../src/decorators/export_to_target.deco.js","../src/decorators/import_from_target.deco.js","../src/types/form.type.js","../src/types/list.decorators/smartdisabling.deco.js","../src/decorators/mutex.deco.js","../src/types/list.decorators/sortable.deco.js","../src/types/list.type.js","../src/types/input.type.js","../src/types/number.type.js","../src/types/date.type.js","../src/types/radio.type.js","../src/types/color.type.js","../src/main.js"],"sourcesContent":["\"use strict\";\nexport function getRoots(target, selector){//{{{\n    const parent = target.parentNode;\n    const isTop = (\n        parent === null ? n => n === null\n        : n=>(n===null)||n.isSameNode(target)\n    );\n    return [\n        ...target.querySelectorAll(selector)\n    ].filter(\n        e=>isTop(e.parentNode.closest(selector))\n    );\n};//}}}\n\nexport function makeRoom(element, pixels) {//{{{\n    let parent = element.parentNode;\n    const direction = (\n        pixels >= 0 ? 1\n        : -1\n    );\n    while (parent) {\n        // Check if parent has vertical scroll bar\n        if (parent.scrollHeight > parent.clientHeight * direction) {\n            // Get the maximum amount that can be scrolled in this parent\n            var maxScroll = parent.scrollHeight - parent.clientHeight * direction;\n\n            // If desired amount is less than maximum scroll, perform scroll\n            if (pixels <= maxScroll * direction) {\n                parent.scrollTop += pixels;\n                return;\n            } else {\n              // If desired amount is greater than maximum scroll,\n              // scroll to maximum and subtract it from desired amount\n              parent.scrollTop = maxScroll;\n              pixels -= maxScroll;\n            };\n        };\n        parent = parent.parentNode;\n    };\n};//}}}\n\nexport function randomId() {//{{{\n    return Math.random().toString(36).substring(2);\n};//}}}\n\nexport function parseJSON(str) {//{{{\n    try {\n        return JSON.parse(str);\n    } catch (err) {};\n};//}}}\n\nexport function createArrayPuller(parentStore) {//{{{\n    // Create an object that populates arrays to each accessed property\n    const arrayStore = {};\n    for (const prop in parentStore) {\n        arrayStore[prop] = [...parentStore[prop]]; // Copy existing arrays\n        // This allows to remove inherited properties individually if needed\n    }\n    // Dynamically create an array per each accessed property:\n    Object.defineProperty(arrayStore, '_dynamic', {\n      get() {\n        return new Proxy(this, {\n          get(target, prop) {\n            if (prop in target) {\n              return target[prop];\n            }\n            target[prop] = [];\n            return target[prop];\n          }\n        });\n      }\n    });\n    return arrayStore._dynamic;\n};//}}}\n","// lib/events.js\n// =============\n\nconst sym_local_events = Symbol(\"Events\");\nconst sym_all_events = Symbol(\"allEvents\");\nconst re_actionEvHandler = /^on(?:Before|After)Action_/;\nconst re_localEvHandler = /^onLocal_/;\nconst re_allEvHandler = /^onAll_/;\n\nimport {createArrayPuller} from \"./helpers.js\";\n\nconst supportedFieldEventTypes = [\n    \"keydown\", \"keyup\", \"keypress\",\n    \"beforeinput\", \"input\", \"change\",\n    \"focus\", \"blur\",\n    \"click\", \"dblclick\", \"contextmenu\",\n    \"mousedown\", \"mouseup\", \"mousemove\", \"mouseenter\", \"mouseleave\", \"mouseover\", \"mouseout\",\n    \"focusin\", \"focusout\",\n\n    // \"select\", \"dragstart\", \"dragend\", \"dragover\", \"dragenter\", \"dragleave\", \"drop\",\n    // \"touchstart\", \"touchend\", \"touchmove\", \"touchcancel\",\n    // \"wheel\", \"scroll\", \"resize\",\n    // \"copy\", \"cut\", \"paste\",\n];\n\nfunction registerEvHandler(evList, evType, evHandler) {\n    const me = this;\n    if (! evList.has(evType)) evList.set(evType, []);\n    evList.get(evType).push(evHandler.bind(me));\n    return me; // Make chainable.\n};\n\n\nexport const events = function events_decorator(targetComponentType, {kind}) {\n    if (kind == \"class\") {\n        return class eventEnabledTarget extends targetComponentType {\n            constructor(target, optionsSrc, ...args) {// {{{\n\n                // Capture before/after action event hanlers through\n                // onBeforeAction_xxx / onAfterAction_xxx options\n                // ...and onLocal_xxx / onAll_xxx regular event handlers.\n                const options = {};\n                const onOptionCallbacks = [];\n                for (\n                    const [key, value]\n                    of Object.entries(optionsSrc)\n                ) if (key.match(re_actionEvHandler)) {\n                    onOptionCallbacks.push([key.substring(2), value, \"onLocal\"])\n                } else if (key.match(re_localEvHandler)) {\n                    onOptionCallbacks.push([key.substring(8), value, \"onLocal\"])\n                } else if (key.match(re_allEvHandler)) {\n                    onOptionCallbacks.push([key.substring(6), value, \"onAll\"])\n                } else {\n                    // Threat the rest as regular options:\n                    options[key] = value;\n                };\n\n                // Call original constructor:\n                super(target, options, ...args);\n\n                // Events enhancing:\n                const me = this;\n                me[sym_local_events] = new Map();\n                me[sym_all_events] = new Map();\n                me.onLocal = registerEvHandler.bind(me, me[sym_local_events]);\n                me.onAll = registerEvHandler.bind(me, me[sym_all_events]);\n                me.on = me.onLocal; // Handy and readable alias for local events.\n\n                // Create event hooks object:\n                me.eventHooks = createArrayPuller(super.eventHooks);\n                    // eventHooks are eventHandlers provided by the component type.\n                    // They are processed after regular events if not default prevented.\n\n                // Field events redirection:\n                if (\n                    // Do it only once and from root component target:\n                    Object.is(me, me.root)\n                ) {\n                    for (const evType of supportedFieldEventTypes) {\n                        me.targetNode.addEventListener(evType, ev=>{\n                            const targetComponent = me.getComponent(ev.target);\n                            const {targetNode} = targetComponent;\n\n                            const evData = {\n                                type: evType,\n                                originalEvent: ev,\n                                target: targetComponent,\n                                targetNode,\n                            };\n\n                            targetComponent.emit(evType, evData);\n\n                        }, true); // Use capture phase\n                    };\n                };\n\n                // Setup action handlers provided through options:\n                for (\n                    const [evt, handler, listenLevel]\n                    of onOptionCallbacks\n                ) me[listenLevel](evt, handler);\n\n            };// }}}\n            async emit(evType, evData) {// {{{\n                const me = this;\n                let propagationStopped = false;\n                let immediatePropagationStopped = false;\n                const event = {\n                    ...evData,\n                    type: evType,\n                    defaultPrevented: false,\n                    preventDefault: () => event.defaultPrevented = true,\n                    stopPropagation: () => propagationStopped = true,\n                    stopImmediatePropagation: () => immediatePropagationStopped = true,\n                };\n                // Event target phase:\n                const targetHandlers = [ // Local handlers, then global ones:\n                    ...(me[sym_local_events].get(evType) || []),\n                    ...(me[sym_all_events].get(evType) || []),\n                ];\n                for (const handler of targetHandlers) {\n                    if (immediatePropagationStopped) break;\n                    await handler(evData);\n                };\n                // Events bubbling phase:\n                for (const parent of me.parents) {\n                    if (propagationStopped) break;\n                    const parentHandlers = parent[sym_all_events].get(evType) || [];\n                    for (const handler of parentHandlers) {\n                        if (immediatePropagationStopped) break;\n                        await handler(evData);\n                    };\n                }\n                // Event hooks (default behavior hooks)::\n                for (const eventHook of me.eventHooks[evType]) {\n                    // WARNING: eventHooks are called inconditionally!\n                    // They should check if event.defaultPrevented is set by themselves.\n                    // This may seem counter-intuitive and unhandy, but it will allow, for instance,\n                    // to implement a fake default prevention to \"change\" events (which are not natively cancelable) by restoring previous value.\n                    await eventHook(evData);\n                };\n                return ! event.defaultPrevented;\n            };// }}}\n        };\n    };\n};\n\n","// src/lib/legacy.js\n// =================\n\nexport default {\n    disEnhance(me) {\n\n        // Prevent <form>'s default behaviour:\n        if (me.targetNode.tagName.toLowerCase()) {\n            me.targetNode.addEventListener('submit', function(event) {\n\n                // Avoid form's regular submission:\n                event.preventDefault();\n\n                // More work may be needed to be done here (let's give it some\n                // more thought...)\n\n            });\n        };\n\n    },\n};\n","// lib/component.js\n// ================\nconst componentTypes = {};\n\nimport {events} from \"./events.js\";\nimport legacy from \"./legacy.js\";\n\nconst sym_smart = Symbol(\"smart_component\");\nconst re_valid_typename_chars = /^[a-z0-9_]+$/i;\nconst re_has_wildcards = /[\\*\\?]/;\nconst wild2regex = wname => new RegExp(//{{{\n    \"^\"\n    + wname\n        .replace(/\\*+/g, \".*\")\n        .replace(/\\?/g, \".\")\n    + \"$\"\n);//}}}\n\nconst errors = {\n    renderError: class renderError extends Error {//{{{\n        constructor(code, message, path) {\n            super(`RenderError(${path}): ${message}`);\n            this.code = code;\n            this.path = path;\n            this.stack = this.stack\n                .split(\"\\n\")\n                .slice(2)\n                .join(\"\\n\")\n            ;\n        };\n    },//}}}\n};\n\nfunction inferType(node, parentComponent) {//{{{\n    switch (node.tagName.toLowerCase()) {\n        case \"ul\":\n        case \"ol\":\n        case \"table\":\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n            return \"list\";\n        case \"input\":\n            const type = String(node.getAttribute(\"type\")||\"\").toLowerCase();\n            if (parentComponent.isSingleton) return parentComponent.options.type;\n            switch(type) {\n                case \"number\":\n                case \"date\":\n                case \"radio\":\n                case \"color\":\n                    return type;\n            };\n        case \"textarea\":\n        case \"select\":\n            return \"input\";\n        case \"label\":\n            return \"label\";\n        default:\n            //if (parentComponent.options.type == \"list\") return \"form\";\n        case \"form\":\n            return \"form\";\n    };\n};//}}}\n\n@events\nexport class SmarkComponent {\n    constructor(//{{{\n        targetNode\n        , {\n            property_name = \"smark\",\n            ...options\n        } = {}\n        , parent\n    ) {\n        const me = this;\n\n        me.validName = (function nameGenerator() {//{{{\n            let counter = 0;\n            return function(...names){\n                if (me.parent.isSingleton) return \"\";\n                    // Singleton target components are unnamed.\n                for (\n                    let n0 of names\n                ) if (\n                    typeof n0 == \"string\"\n                ) {\n                    n0 = n0.trim();\n                    if (n0.length) return n0;\n                };\n                return 'UNNAMED'+(++counter);\n            };\n        })();//}}}\n\n        me.actions = {};\n        me.property_name = property_name;\n        me.selector = `[data-${me.property_name}]`;\n        me.types = componentTypes;\n        me.targetNode = targetNode;\n        me.options = options;\n        me.setNodeOptions(me.targetNode, me.options);\n\n        me.parent = parent;\n        if (! me.parent instanceof SmarkComponent) throw me.renderError(\n            'INVALID_PARENT'\n            , `Smark Components must have valid Smark Component parent.`\n        );\n        me.root = (\n            me.parent === null ? me\n            : me.parent.root\n        );\n\n        // Parents iterator:\n        me.parents = {};\n        me.parents[Symbol.iterator] = function* () {\n            let current = me;\n            while (current) {\n                yield current;\n                current = current.parent;\n            };\n        };\n\n        // Calculate prefix or disable autoId:\n        const autoId = me.inherittedOption(\"autoId\", false);\n        me.genId = (\n            autoId === false ? false\n                // Do not auto-generate IDs.\n            : autoId === true ? p => p.replace(/\\//g, \"_\")\n                // Use \"_path_in_underscore_style\".\n            : typeof autoId == \"string\" ? p => autoId+p.replace(/\\//g, \"_\")\n                // Use \"prefix\" + \"_path_in_underscore_style\".\n            : typeof autoId == \"function\" ? autoId\n                // Use fn(path) custom style.\n            : false\n                // Failback to disabled.\n        );\n\n        me.onRenderedTasks = [];\n\n        let setRendered;\n        me.renderedSync = false;\n        me.rendered = new Promise(resolve => setRendered = resolve);\n\n        me.children = {};\n        me.targetNode[sym_smart] = me;\n\n        (async ()=>{\n            await me.render();\n            for (\n                const task of me.onRenderedTasks\n            ) await task();\n            me.onRenderedTasks = null;\n            setRendered(true);\n            setTimeout(()=>me.renderedSync = true, 1);\n        })();\n        if (me.options.onRendered) me.onRendered(me.options.onRendered);\n\n    };//}}}\n    onRendered(cbk) {//{{{\n        const me = this;\n        if (me.onRenderedTasks) {\n            me.onRenderedTasks.push(cbk.bind(me));\n        } else {\n            cbk.bind(me)();\n        };\n    };//}}}\n    getNodeOptions(node, defaultOptions) {//{{{\n        const me = this;\n        const optionsSrc = (\n            node.dataset[me.property_name] || \"\"\n        ).trim() || null;\n        const options = {\n            ...defaultOptions,\n            ...(()=>{\n                try {\n                    const opt = JSON.parse(optionsSrc);\n                    if (typeof opt != \"object\") throw new Error(\"NO_OBJECT\");\n                    return opt;\n                } catch (err) {\n                    return (\n                        optionsSrc.match(re_valid_typename_chars) ? {type: optionsSrc}\n                        : {}\n                    );\n                };\n            })(),\n        };\n        if (! options.action && ! options.type) options.type = inferType(node, me);\n        me.setNodeOptions(node, options);\n        return options;\n    };//}}}\n    setNodeOptions(node, options) {//{{{\n        const me = this;\n        node.dataset[me.property_name] = JSON.stringify(options);\n    };//}}}\n    async enhance(node, defaultOptions) {//{{{\n        const me = this;\n\n        // Sanityze and store options:{{{\n        let options = me.getNodeOptions(node, defaultOptions);\n        //}}}\n\n        // Prevent default behaviours:{{{\n        legacy.disEnhance(me);\n        //}}}\n\n        // Classify:{{{\n        if (options.action) {\n            if (! options.type) options.type = \"trigger\"; // Make type optional for triggers.\n            if (options.type != \"trigger\") throw me.renderError(\n                \"ACTION_IN_NON_TRIGGER\"\n                , `\"action\" property is only allowed for \"trigger\" components but \"${options.type}\" type specified.`\n            );\n        } else if (typeof options.type != \"string\") {\n            throw me.renderError(\n                \"NO_TYPE_PROVIDED\"\n                , `Invalid SmarkForm item: type is mandatory for non trigger components.`\n            );\n        };\n        //}}}\n\n        // Enhance:{{{\n        const ctrl = me.types[options.type];\n        if (! ctrl) throw me.renderError(\n            \"UNKNOWN_TYPE\"\n            , `Unimplemented SmarkForm component controller: ${options.type}`,\n        );\n        return new ctrl (\n            node\n            , options\n            , me\n        );\n        //}}}\n\n    };//}}}\n    getComponent(target) {//{{{\n        const me = this;\n        return (\n            target[sym_smart]\n            || target.parentElement?.closest(me.selector)[sym_smart]\n            || null\n        );\n    };//}}}\n    getPath() {//{{{\n        const me = this;\n        return (\n            [...me.parents].map(p=>p.name)\n            .reverse()\n            .join(\"/\") // Root parent being \"\" => Starting \"/\".\n            || \"/\" // No join (0 parents => root node)\n        );\n    };//}}}\n    find(path=\"\") { // {{{\n        const me = this;\n        let base = me;\n        if (base.name === \"\" && base.parent.isSingleton) base = base.parent;\n             // Always detect singleton fields instead of their child.\n        path = String(path); // Allow numbers (arrays simply won't match).\n        if (path[0] == \"/\") while (base.parent) base = base.parent;\n        const parts = path\n            .split(\"/\")\n            .filter(x=>x)\n        ;\n\n        // (Recursive) Multi-match search (path with '*' wildcards):\n        // (Returns array of components)\n        const firstWildcardPos = parts.findIndex(p=>p.match(re_has_wildcards));\n        if (firstWildcardPos >= 0) {\n            const re_pattern = wild2regex(parts[firstWildcardPos]);\n            const pivotPath = parts.slice(0, firstWildcardPos).join(\"/\");\n            const restPath = parts.slice(firstWildcardPos + 1).join(\"/\");\n            const pivot = base.find(pivotPath);\n            const pivotChilds = Object.entries(pivot.children);\n            return pivotChilds\n                .filter(([name,child])=>child && name.match(re_pattern))\n                .map(([,child])=>child.find(restPath))\n                .flat(Infinity)\n            ;\n        };\n\n        // Straight search (wildcardless path)\n        // (Returns single component)\n        return parts.reduce(\n            (current, name)=>{\n                if (current === undefined) return;   // No match.\n                if (name == \"..\") return current.parent;  // Go up one level.\n                if ( // Special syntax for list siblings (.+n / .-n)\n                    name[0] == \".\"\n                ) {\n                    if (name == \".\") return current; // Current node.\n                    if (! current.parent) return; // Root node => no siblings.\n                    const delta = parseInt(name.slice(1));\n                    if (isNaN(delta)) return; // Invalid sibling syntax.\n                    if (current.parent.options.type == \"list\") {\n                        const n = parseInt(current.name) + delta\n                        if (! isNaN(n)) return current.parent.children[n];\n                    } else {\n                        const keys = Object.keys(current.parent.children);\n                        const currentPosition = keys.findIndex(key=>key==current.name);\n                        const newKey = keys[currentPosition + delta];\n                        return current.parent.children[newKey];\n                    };\n                } else {\n                    return current.children[name];\n                };\n            }\n            , base\n        )\n    ;\n    };//}}}\n    inherittedOption(optName, defaultValue) {//{{{\n        const me = this;\n        for (\n            const p of me.parents\n        ) if (\n            p.options[optName] !== undefined\n        ) return p.options[optName];\n        return defaultValue;\n    };//}}}\n    moveTo(){//{{{\n        const me = this;\n        if (! me.targetNode.id) me.targetNode.id = me.getPath();\n        document.location.hash = me.targetNode.id;\n        // Avoid noisy url hash \"randomish\" effect:\n        window.history.pushState({}, undefined,window.location.pathname);\n            // Like 'document.location.hash = \"\"' but without leaving leading\n            // hash character.\n    };//}}}\n    getTriggers(actionNames = \"\") {//{{{\n        const me = this;\n        const myCurrentActions = [];\n        const actionKeys = new Set([actionNames]\n            .flat()\n            .map(String)\n            .filter(x=>x)\n        );\n        const returnAll = actionKeys.has(\"*\");\n        for (\n            const tgg\n            of [...me.root.targetNode.querySelectorAll(me.selector)]\n                .map(target=>target[sym_smart])\n                .filter(x=>x) // Ignore not yet rendered.\n        ) {\n            const options = tgg.getTriggerArgs()\n            if (! options) continue; // Not a trigger\n            if (! Object.is(options.context, me)) continue;\n            if (\n                returnAll\n                || actionKeys.has(options.action)\n            ) myCurrentActions.push(tgg);\n        };\n        return myCurrentActions;\n    };//}}}\n    updateId() {//{{{\n        const me = this;\n        if (me.genId === false) return; // Abort if disabled.\n        const newId = me.genId(me.getPath());\n        if (me.targetNode.id != newId) {\n            me.targetNode.id = newId;\n            for (\n                const child\n                of Object.values(me.children)\n            ) child.updateId();\n        };\n        return me.targetNode.id\n    };//}}}\n    focus() {//{{{\n        const me = this;\n        for (const fname in me.children) {\n            return me.children[fname].focus();\n        };\n        if (me.targetFieldNode) me.targetFieldNode.focus();\n    };//}}}\n    getTriggerArgs() {}; // Let's easily filter out non trigger compoenents.\n    // Error types:\n    renderError(code, message) {//{{{\n        const me = this;\n        return new errors.renderError(code, message, me.getPath());\n    };//}}}\n};\n\nexport class SmarkField extends SmarkComponent {\n    constructor(...args){\n        super(...args);\n        this._isField = true;\n        if (! Object.is(this, this.root)) {\n            this.name = this.validName(\n                this.options.name\n                , this.targetNode.getAttribute(\"name\")\n            );\n            if (this.options.hasOwnProperty(\"value\")) {\n                if (this.targetNode.getAttribute(\"value\") !== null) { // Conflict\n                    throw me.renderError(\n                        'VALUE_CONFLICT'\n                        , `Initial value specied both as \"value\" option and HTML \"value\" attribute.`\n                    );\n                };\n                this.targetNode.setAttribute(\"value\", this.options.value);\n            };\n        };\n    };\n};\n\nexport function createType(name, controller) {//{{{\n    if (componentTypes[name] !== undefined) throw new Error(\n        `Duplicate component type definition: ${name}`\n    );\n    if (! (controller.prototype instanceof SmarkComponent)) throw new Error(\n        `Bad component type implementation for: ${name}`\n    );\n    componentTypes[name] = controller;\n};//}}}\n\n","// lib/hotkeys.js\n// ==============\n\nexport class hotKeys_handler {\n    constructor(form) {\n        const me = this;\n        me.form = form;\n        me.revealed = null;\n        const onStatusChange = hotKeys_handler.onStatusChange.bind(me);\n        me.form.targetNode.addEventListener(\"keydown\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"keyup\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"focusout\", onStatusChange, true);\n        me.form.targetNode.addEventListener(\"focusin\", onStatusChange, true);\n    };\n    static onStatusChange(ev) {\n        const me = this;\n\n        // Deactivation:\n        if (ev.type == \"keyup\") {\n            if (ev.key == \"Control\") me.reveal(false);\n            return;\n        };\n\n        // Focus leave:\n        if (ev.type == \"focusout\") {\n            if (me.revealed !== null) {\n                me.reveal(); // Unreveal, but keep activated.\n            };\n            return;\n        };\n\n        // Focus enter:\n        if (ev.type == \"focusin\" && me.revealed === null) {\n            return; // No hotkeys revealed.\n            // Otherwise behave as new activation\n        };\n\n        // ev.type is \"keydown\" or \"focusin\"\n        const ctrlKey = ev.ctrlKey || ev.key == \"Control\";\n        const altKey = ev.altKey || ev.key == \"Alt\";\n        const activation = (\n            // Pressing ctrl key with or without alt key\n            ctrlKey && (ev.key == \"Control\" || ev.key == \"Alt\")\n            // Reentering focus after some action without deactivation\n            || ev.type == \"focusin\"\n        );\n\n        // (Re)activation:\n        if (activation) {\n            const level = altKey ? 2 : 1;\n            // Activate and reveal:\n            return void me.reveal(ev.target, level);\n        };\n\n        // Hotkey stroke:\n        if (me.revealed instanceof Array) {\n            const targettedTrigger = me.revealed.find(\n                t=>t.options.hotkey == ev.key\n            );\n            if (targettedTrigger) {\n                // Prevent default and stop propagation:\n                //   Even if disabled to avoid weird behaviour with repetitions\n                //   (Ex. using \"+\" to add items to a list would zoom in\n                //   some browsers when max_items is reached).\n                ev.preventDefault();\n                ev.stopPropagation();\n                // Perform the action:\n                if (! targettedTrigger.targetNode.disabled) {\n                    // Unless trigger is disabled\n                    targettedTrigger.targetNode.click();\n                };\n            };\n        };\n\n    };\n    reveal(target, level = 1) {\n        const me = this;\n\n        // Conceal previous target triggers' hotkeys if any:\n        if (me.revealed !== null) {\n            for (const t of me.revealed) {\n                t.targetNode.removeAttribute(\"data-hotkey\");\n            };\n            me.revealed.length = 0;\n        };\n\n        if (target === false) {\n            me.revealed = null; // Deactivate hot keys\n        };\n\n        if (target) {\n\n            // Reveal new target triggers' hotkeys:\n            const component = me.form.getComponent(target);\n            const activeContexts = [component, ...component.parents];\n            const activeContextsSet = new Set(activeContexts);\n\n            const candidateTriggers = activeContexts\n                .map((ctx, distance)=>(\n                    ctx.getTriggers('*')    // All triggers.\n                    .map(tg=>({\n                        tg,\n                        distance,   // Number of ancestors levels.\n                        args: tg.getTriggerArgs() || {},\n                        hotkey: String(tg.options.hotkey || \"\"),\n                    }))\n                ))\n                .flat()\n                .filter(({args, hotkey})=>(\n                    hotkey.length\n                    && activeContextsSet.has(args.context)\n                ))\n                .sort((ta,tb)=>(\n                    activeContextsSet.has(tb.args.target)\n                    - activeContextsSet.has(ta.args.target)\n                    - tb.distance\n                    + ta.distance\n                ))\n            ;\n\n            const seen = new Map(); // hotkey => [times seen, distance from target]\n            me.revealed = [];\n\n            for (const candidate of candidateTriggers) {\n                const [times, distance] = seen.get(candidate.hotkey) || [1, 0];\n                if (times < level) {\n                    seen.set(candidate.hotkey, [times + 1, candidate.distance]);\n                    continue; // Level not reached.\n                };\n                if (times > level) {\n                    continue; // Used by more preferent tg.\n                };\n                if (candidate.distance > distance) { // Don't pick more than one per \"ancestory\" level.\n                    if (! candidate.tg.targetNode.disabled) {\n                        candidate.tg.targetNode.setAttribute(\"data-hotkey\", candidate.hotkey);\n                    };\n                    me.revealed.push(candidate.tg); // Let stroke detection know it matched.\n                    // Avoid activating the following candidates by \"oveflowing\" their times seen count:\n                    // (UX): Do it even if disabled for behavioral consistency...\n                    seen.set(candidate.hotkey, [times + 1, candidate.distance]);\n                };\n            };\n\n        };\n\n    };\n};\n","// types/trigger.type.js\n// =====================\nimport {SmarkComponent} from \"../lib/component.js\";\n\nexport const action = function action_decorator(targetMtd, {kind, name, addInitializer}) {\n    if (kind == \"method\") addInitializer(function registerAction() {\n        const me = this;\n        this.actions[name] = async function (options = {}) {\n            let defaultPrevented = false;\n            if (! options.silent) {\n                defaultPrevented = ! await me.emit(`BeforeAction_${name}`, options);\n            };\n            if (defaultPrevented) return; // Action cancelled by event handler.\n            const data = await targetMtd.apply(me, options);\n            if (! options.silent) {\n                me.emit(`AfterAction_${name}`, {...options, data});\n            };\n            return data;\n        };\n    });\n};\n\nexport class trigger extends SmarkComponent {\n    constructor(node, options, ...args){\n        delete options.name; // Triggers are always unnamed.\n        return super(node, options, ...args);\n    };\n    render(){\n        const me = this;\n        me.parent.onRendered(()=>{\n            const triggerArgs = me.getTriggerArgs();\n            if (\n                typeof triggerArgs.context?.onTriggerRender == \"function\"\n            ) triggerArgs.context.onTriggerRender(triggerArgs);\n        });\n    };\n    disable() {//{{{\n        const me = this;\n        me.targetNode.disabled = true;\n    };//}}}\n    enable() {//{{{\n        const me = this;\n        me.targetNode.disabled = false;\n    };//}}}\n    getTriggerArgs() {//{{{\n        const me = this;\n        const parents = [...me.parents];\n        const {\n            // property: local variable\n            action,\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n        if (! action) return; // Not a trigger component.\n\n        const context = (\n            contextPath ? me.parent.find(contextPath)\n            : parents.find(p=>(typeof p.actions[action] == \"function\"))\n        );\n\n        const target = (\n            targetPath ? context?.find(targetPath) // Explicit target (context relative)\n            : contextPath ? null // Explicit context path => don't mind component position\n            : (\n                parents\n                    .slice(1) // Skip self\n                    .find(p=>p.parent?.targetNode.isSameNode(context?.targetNode))\n                || null\n            )\n        );\n\n        return {\n            action,\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n\nexport async function onTriggerClick(ev) {\n    const me = this;\n    const triggerComponent = me.getComponent(ev.target);\n    const options = triggerComponent.getTriggerArgs();\n    if (! options) return; // Not a trigger.\n    const {context, action} = options;\n    const mtd = context?.actions[action]\n    if (\n        typeof mtd != \"function\"\n    ) throw me.renderError(\n        \"UNKNOWN_ACTION\"\n        , `Unknown action ${action}`\n        + (context ? ` for ${context.options.type}` : \"\")\n    );\n    return await mtd(options);\n};\n\n\n","// types/label.type.js\n// ===================\nimport {SmarkComponent} from \"../lib/component.js\";\nimport {randomId} from \"../lib/helpers.js\";\nimport {getRoots} from \"../lib/helpers.js\";\n\n// TODO:\n// =====\n//\n//   🚀 Add support for (smarkform) fields contained in the label.\n//      👉 Now we can just not enhance the label (<label>Bla bla bla<input\n//         data-smark></label>) and it will (in this case natively) work.\n//      👉 ...but this does not allow us to use other SmarkForm fields such as\n//         forms and lists (since they can contain more than one native field\n//         which is not allowed by <label> tag.\n//      💡 But we can use different tag (with {data-smark=\"label\"}) and just\n//         create the native <label> tag around the text.\n\nexport class label extends SmarkComponent {\n    constructor(node, {allow_select = false, ...options}, ...args){\n        delete options.name; // Labels are always unnamed.\n        return super(node, {allow_select, ...options}, ...args);\n    };\n    async render(){\n        const me = this;\n        // Enhance acctions:\n        for (\n            const node\n            of getRoots(me.targetNode, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            if (!! newItem?._isField) {\n                throw me.renderError(\n                    'FIELD_IN_LABEL'\n                    , `Non action components not allowed in labels, found ${newItem.name} in form ${me.getPath()}.`\n                );\n            };\n        };\n        me.parent.onRendered(()=>{\n            const labelArgs = me.getLabelArgs();\n            const {targetFieldNode} = labelArgs.target || {};\n            if (targetFieldNode) { // Apply only to native inputs (scalars)\n                if (! targetFieldNode.id) { // Ensure targetted field has an Id\n                    targetFieldNode.id = randomId();\n                };\n                me.targetNode.setAttribute(\"for\", targetFieldNode.id);\n            };\n            if (! me.options.allow_select) {\n                // Make labels non-selectable unless \"allow_select\" option\n                // is set  to true.\n                me.targetNode.style[\"user-select\"] = \"none\";\n            };\n        });\n    };\n    getLabelArgs() {//{{{\n        const me = this;\n        const parents = [...me.parents];\n        let context, target;\n\n        const {\n            // property: local variable\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n\n        if (! contextPath && ! targetPath) {\n            // Guess ;-)\n            context = me.parent;\n            const candidates = context.targetNode.querySelectorAll(me.selector);\n            let found = false;\n            for (const childName in candidates) {\n                if (found) {\n                    let targetComponent = me.getComponent(candidates[childName]);\n                    if (targetComponent?._isField) {\n                        // FIXME : Dig deeper in case of non native field tags\n                        // (forms, lists, singletons...)\n                        // It may require to await for rendering or even listen\n                        // to events (lists with minItems = 0);\n                        target = targetComponent;\n                        break;\n                    };\n                } else if (\n                    Object.is(candidates[childName], me.targetNode)\n                ) {\n                    found = true;;\n                };\n            };\n        } else {\n            context = (\n                contextPath ? me.parent.find(contextPath)\n                : me.parent\n            );\n            target = (\n                targetPath ? context.find(targetPath) // Explicit target (context relative)\n                : context\n            );\n        };\n\n        return {\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n","\nimport {action} from \"../types/trigger.type.js\";\n\nexport const foldable = function foldable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class foldableTarget extends target {\n            render(...args) {//{{{\n                const retv = super.render(...args);\n                const me = this;\n                me.root.onRendered(()=>{\n                    me.fold({operation: (\n                        !! me.options.folded ? \"fold\"\n                        : \"unfold\"\n                    )});\n                });\n                return retv;\n            };//}}}\n            @action\n            fold({//{{{\n                operation = \"toggle\", // Values: \"fold\" / \"unfold\" / \"toggle\"\n            } = {}) {\n                const me = this;\n                const wasFolded = me.targetNode.style.display == \"none\";\n                const isFolded = (\n                    operation == \"fold\" ? true\n                    : operation == \"unfold\" ? false\n                    : ! wasFolded\n                );\n                me.targetNode.style.display = (\n                    isFolded ? \"none\"\n                    : me.originalDisplayProp\n                );\n\n                me.getTriggers(\"fold\").forEach(tgg => {\n                    const {foldedClass, unfoldedClass} = tgg.options;\n                    if (foldedClass) tgg.targetNode.classList[\n                        isFolded ? \"add\"\n                        : \"remove\"\n                    ](foldedClass);\n                    if (unfoldedClass) tgg.targetNode.classList[\n                        isFolded ? \"remove\"\n                        : \"add\"\n                    ](unfoldedClass);\n                });\n\n                me.getTriggers([\"addItem\", \"removeItem\"]).map(\n                    isFolded ? tgg => tgg.disable()\n                    : tgg => tgg.enable()\n                );\n            };//}}}\n        };\n    };\n};\n","// src/decorators/export_to_target.deco.js\n// =======================================\n\nexport const export_to_target = function export_to_target_decorator(method, {kind}) {\n    if (kind == \"method\") {\n        return async function export_mtd({target, ...options}={}) {\n            const me = this;\n            const value = await method.call(me, options);\n            try {\n                await target.import({data: value});\n            } catch (error) {\n                // target not provided or invalid\n            };\n            return value;\n        };\n    };\n};\n","// src/decorators/import_from_target.deco.js\n// =========================================\n\nexport const import_from_target = function import_from_target_decorator(method, {kind}) {\n    if (kind == \"method\") {\n        return async function import_mtd({target, data, ...options}={}) {\n            const me = this;\n            try {\n                data = await target.export();\n            } catch (error) {\n                // target not provided or invalid\n            };\n            return await method.call(me, {data, ...options});\n        };\n    };\n};\n","// types/form.type.js\n// ==================\n\nimport {SmarkField} from \"../lib/component.js\";\nimport {action} from \"./trigger.type.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {getRoots, parseJSON} from \"../lib/helpers.js\";\n\n@foldable\nexport class form extends SmarkField {\n    async render() {//{{{\n        const me = this;\n        me.originalDisplayProp = me.targetNode.style.display;\n        // Enhance childs:\n        for (\n            const node\n            of getRoots(me.targetNode, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            if (!! newItem?._isField) {\n                if (me.children[newItem.name] !== undefined) throw me.renderError(\n                    'REPEATED_FIELD_NAME'\n                    , `Field name '${newItem.name}' used more than once in this form level.`\n                );\n                me.children[newItem.name] = newItem;\n                newItem.updateId();\n            };\n        };\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        const me = this;\n        return Object.fromEntries(\n            await Promise.all(Object.entries(me.children).map(\n                async ([key, child])=>[key, await child.export({silent: true})]\n            ))\n        );\n    };//}}}\n    @action\n    @import_from_target\n    async import({data = {}, focus = true} = {}) {//{{{\n        const me = this;\n        const dataConstructor = Object(data).constructor;\n        if (\n            dataConstructor !== {}.constructor // Not a plain object\n            && ! (data = parseJSON(data))      // Neither a (valid) JSON string\n        ) throw me.renderError(\n            'FORM_NOT_PLAIN_OBJECT'\n            , `Expected plain object or vailid JSON for form import, ${dataConstructor.name} given.`\n        );\n        const retv = Object.fromEntries(\n            await Promise.all(\n                Object.entries(me.children).map(\n                    async ([key, target]) => {\n                        // Could have used target.then(...) but, event\n                        // components' import() method SHOULD be async, it\n                        // would have failed in case it's not.\n                        // Forcing it to be async is not possible because\n                        // transpilers would break this check.\n                        // ...and, IMHO, this approach is better than a dirty\n                        // Promise.resolve(...)\n                        const value = await target.import({data: data[key], focus, silent: true});\n                        return [key, value];\n                    }\n                )\n            )\n        );\n        if (focus) me.focus();\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of Object.values(me.children)\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async clear({focus} = {}) {//{{{\n        const me = this;\n        return await me.import({data: {}, focus, silent: true});\n    };//}}}\n};\n","// types/list.decorators/smartdisabling.deco.js\n// ============================================\n\nasync function updateTriggers(context) {\n    await context.rendered;\n    for (const tg of context.getTriggers([\"removeItem\", \"addItem\"])) {\n        tg.targetNode.disabled = (\n            tg.options.action == \"removeItem\" ? (\n                context.children.length <= context.min_items\n                && tg.options.failback != \"clear\" // Unless clearing function\n            )\n            : context.children.length >= context.max_items\n        );\n    };\n};\n\nexport const smartdisabling = function list_smartdisabling_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class smartdisablingClass extends target {\n            async render(...args) {//{{{\n                const retv = await super.render(...args);\n                const me = this;\n                setTimeout(()=>updateTriggers(me), 1);\n                    // FIXME (Why do we need to delay it?)\n                    // Even more: Why it is even needed with min_items >= 1??\n\n                return retv;\n            };//}}}\n        };\n    } else if (kind == \"method\") {\n        return async function smartdisablingMethod(...args) {\n            const me = this;\n            const retv = await target.call(me, ...args);\n            updateTriggers(me);\n            return retv;\n        };\n    };\n};\n","\nconst sym_mux = Symbol(\"smart_mutex\");\n\nclass Mutex {\n    constructor() {\n        this.mtx = Promise.resolve();\n    };\n    lock() {\n        // Sync operation:\n        let nextResolve;\n        const nextMtx = new Promise(resolve => {\n            nextResolve = () => resolve();\n        });\n        const currMtx = this.mtx;\n        this.mtx = nextMtx;\n        // Async behaviour:\n        return currMtx.then(function unlock() {\n            return nextResolve\n        });\n    };\n}\n\nexport const mutex = function method_mutex_decorator(muxName) {\n    return function mutex_decorator(target, {kind}) {\n        if (kind == \"method\") {\n            return async function muxed_target(...args) {\n                const me = this;\n                if (! me[sym_mux]) me[sym_mux] = {};\n                if (! me[sym_mux][muxName]) me[sym_mux][muxName] = new Mutex();\n                const unlock = await me[sym_mux][muxName].lock(); // Await previous muxed call (if any)\n                let err, retv;\n                try {\n                    retv = await target.call(me, ...args);\n                } catch (error) {\n                    err = error;\n                };\n                unlock();\n                if (err) throw err;\n                return retv;\n            };\n\n        };\n    };\n};\n","// types/list.decorators/sortable.deco.js\n// ======================================\n\nimport {mutex} from \"../../decorators/mutex.deco.js\";\n\nexport const sortable = function list_sortable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class sortableTarget extends target {\n            async render(...args) {//{{{\n                const retv = await super.render(...args);\n                const me = this;\n\n                me.sortable = !! me.options.sortable;\n                me.templates.item.setAttribute(\"draggable\", me.sortable);\n                me.children.forEach(c=>c.targetNode.setAttribute(\"dragable\", me.sortable));\n                if (me.sortable) {\n                    let dragSource = null;\n                    let dragDest = null;\n                    me.targetNode.addEventListener(\"dragstart\", e => {\n                        if (dragSource === null) {\n                            dragSource = e.target\n                            e.stopPropagation();\n                        } else {\n                            // Single dragging at a time.\n                            e.preventDefault();\n                        };\n                    });\n                    me.targetNode.addEventListener(\"dragover\", e => e.preventDefault());\n                    me.targetNode.addEventListener(\"drop\", e => {\n                        if (! dragSource) return; // Already dropped\n                        let target = e.target;\n                        while (\n                            target.parentElement\n                            && target.parentElement != dragSource.parentElement\n                        ) target = target.parentElement;\n                        dragDest = target;\n                    });\n                    me.targetNode.addEventListener(\"dragend\", async () => {\n                        if (dragDest)  await me.move({\n                            from: me.getComponent(dragSource),\n                            to: me.getComponent(dragDest),\n                        });\n                        dragSource = null;\n                        dragDest = null;\n                    });\n                };\n\n                return retv;\n            };//}}}\n            @mutex(\"list_mutating\")\n            async move(options = {}) {//{{{\n                const me = this;\n                let {\n                    from,\n                    to,\n                } = options;\n\n                // // FIXME: Avoid nested sortables to interact.\n                // console.log({from, to}); // <--- See this!!!\n\n                //\n                // TODO: Convert to action!!!\n                //\n                if (\n                    to === null // Dropped outside\n                    || from === null // (Shouldn't happen)\n                ) return;\n                const fromi = Number(from?.name);\n                const toi = Number(to?.name);\n                if (fromi == toi) {\n                    return;\n                } else if (fromi < toi) {\n                    const newChunk = [\n                        ...me.children.slice(fromi + 1, toi + 1),\n                        me.children[fromi],\n                    ];\n                    me.children.splice(fromi, toi - fromi + 1, ...newChunk);\n                } else if (fromi > toi) {\n                    const newChunk = [\n                        me.children[fromi],\n                        ...me.children.slice(toi, fromi),\n                    ];\n                    me.children.splice(toi, fromi - toi + 1, ...newChunk);\n                };\n                const inc = fromi < toi ? 1 : -1;\n                const moveMethod = inc > 0 ? \"after\" : \"before\";\n                to.targetNode[moveMethod](from.targetNode);\n                me.renum();\n            };//}}}\n        };\n    };\n};\n","// types/list.type.js\n// ==================\n\n// TODO:\n// =====\n//\n// 👉 Keep first item in place:\n//    -------------------------\n//     \n//    For lists allowing 0 items, make first element disabled and not visible\n//    instead of completely removing from DOM.\n//\n//    This would avoid lots of visual layout issues.\n//\n\n\nimport {SmarkField} from \"../lib/component.js\";\nimport {smartdisabling} from \"./list.decorators/smartdisabling.deco.js\";\nimport {action} from \"./trigger.type.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {sortable} from \"./list.decorators/sortable.deco.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {mutex} from \"../decorators/mutex.deco.js\";\nimport {makeRoom, getRoots, parseJSON} from \"../lib/helpers.js\";\n\n\n// Private helpers:\n// ----------------\n\nfunction makeNonNavigable(target) {//{{{\n    if (\n        // Tabindex not explicitly defined:\n        target.getAttribute(\"tabindex\") === null\n    ) {\n        target.setAttribute(\"tabindex\", \"-1\");\n    };\n};//}}}\n\nfunction loadTemplates(me) {//{{{\n    const templates = {};\n    for (const child of [...me.targetNode.children]) {\n        const {role = \"item\"} = parseJSON(child.getAttribute(\"data-smark\")) || {};\n        switch (role) {\n            case \"empty_list\":\n            case \"header\":\n            case \"separator\":\n            case \"last_separator\":\n            case \"footer\":\n            case \"placeholder\": // (Only with max_items defined)\n                child.setAttribute(\"data-role\", role);\n            case \"item\": // (Default)\n                if (templates[role] !== undefined) throw me.renderError(\n                    'LIST_DUPLICATE_TEMPLATE'\n                    , `Repated list template role ${role}`\n                );\n                templates[role] = child;\n                templates[role].remove();\n            break;\n        };\n    };\n    if (me.targetNode.children.length) {\n        const {role = \"(unspecified)\"} = parseJSON(\n            me.targetNode.children[0].getAttribute(\"data-smark\")\n        ) || {};\n        throw me.renderError(\n            'LIST_UNKNOWN_TEMPLATE_ROLE'\n            , `Unknown list template role ${role}`\n        );\n    };\n    if (! templates.last_separator) {\n        templates.last_separator = templates.separator; // (If any)\n    };\n    if (\n        templates.item.querySelector(\"[id]\") !== null // Contains IDs\n    ) throw me.renderError(\n        'LIST_CONTAINS_ID'\n        , `List components are not allowed to contain elements with 'id' attribute`\n    );\n    return templates;\n};//}}}\n\n\n\n\n// List component type:\n// --------------------\n\n@foldable\n@sortable\n@smartdisabling\nexport class list extends SmarkField {\n    async #appendChild(child) {//{{{\n        const me = this;\n        if (me.templates.header) {\n            me.templates.header.after(child);\n        } else {\n            me.targetNode.appendChild(child);\n        };\n    };//}}}\n    async render () {//{{{\n        const me = this;\n        me.originalDisplayProp = me.targetNode.style.display;\n\n        me.min_items = Math.max(0,\n            typeof me.options.min_items == \"number\" ? me.options.min_items\n            : 1\n        );\n        me.max_items = Math.max(me.min_items,\n            typeof me.options.max_items == \"number\" ? me.options.max_items\n            : Infinity\n        );\n        me.children = [];\n        me.templates = loadTemplates(me);\n        me.placeholders = [];\n        const tplOptions = me.getNodeOptions(\n            me.templates.item\n            , {\n                type: me.options.of, // Allow to specify items type from list declaration.\n            }\n        );\n        if (\n            me.options.of\n            && tplOptions.type != me.options.of\n        ) throw me.renderError(\n            'LIST_ITEM_TYPE_MISSMATCH'\n            , `List item type missmatch`\n        );\n\n        for (const tpl of [\n            me.templates.header,\n            me.templates.footer,\n        ]) if (!! tpl) {\n            me.targetNode.appendChild(tpl);\n            // Enhance childs:\n            for (\n                const node\n                of getRoots(tpl, me.selector)\n            ) {\n                const newItem = await me.enhance(node);\n                if (!! newItem?._isField) {\n                    throw me.renderError(\n                        'FIELD_IN_WRONG_LIST_TEMPLATE'\n                        , `Fields are not allowed in list's template roles other than item.`\n                    );\n                };\n            };\n        };\n\n        // onRendered tweaks:\n        me.root.onRendered(async ()=>{\n            for(let i=0; i<me.min_items; i++) await me.addItem({silent: true});\n\n            // Initialize \"count\" actions and reinject empty_list template:\n            if (me.min_items == 0) await me.renum();\n\n            // Let screen readers know lists may change.\n            me.targetNode.setAttribute(\"aria-live\", \"polite\");\n            me.targetNode.setAttribute(\"aria-atomic\", \"true\");\n        });\n        return;\n    };//}}}\n    onTriggerRender({action, origin, context}) {//{{{\n        switch (action) {\n            case \"addItem\":\n            case \"removeItem\":\n                if (\n                    // Placed inside\n                    (1 + [...origin.parents].findIndex(p=>Object.is(p, context)))\n                    && origin.options.hotkey\n                ) {\n                    // Skip them in keyboard navigation.\n                    makeNonNavigable(origin.targetNode);\n                };\n                break;\n        };\n    };//}}}\n    @mutex(\"list_mutating\")\n    @action\n    @export_to_target\n    async export() {//{{{\n        const me = this;\n        const list = [];\n        const emptyChilds = [];\n        const stripEmpties = ! me.inherittedOption(\"exportEmpties\", false);\n        for (const child of me.children) {\n            if (stripEmpties && await child.isEmpty()) {\n                if (list.length < me.min_items) emptyChilds.push(child);\n                continue;\n            };\n            list.push(await child.export({silent: true}));\n        };\n        for (let i=0; list.length < me.min_items; i++) {\n            list.push(await emptyChilds[i].export({silent: true}));\n        };\n        return list;\n    };//}}}\n    @action\n    @import_from_target\n    async import({data = [], focus} = {}) {//{{{\n        const me = this;\n        // Auto-update in case of scalar to array template upgrade:\n        if (! (data instanceof Array)) data = [data];\n        // Load data:\n        for (\n            let i = 0;\n            i < Math.min(data.length, me.max_items); // Limit to allowed items\n            i++\n        ) {\n            if (me.children.length <= i) await me.addItem({silent: true}); // Make room on demand\n            await me.children[i].import({data: data[i], focus, silent: true});\n        };\n        // Remove extra items if possible (over min_items):\n        for (\n            let i = Math.max(data.length, me.min_items);\n            i < me.children.length;\n        ) await me.removeItem({silent: true});\n        // Report if data doesn't fit:\n        if (data.length > me.max_items) {\n            me.emit(\"error\", {\n                code: 'LIST_IMPORT_OVERFLOW',\n                message: `Trying to import array greater than list's max_items. Data beyond max_items ignored.`,\n                context: me,\n                data,\n                options: me.options,\n            });\n        };\n        // Clear items over imported data if min_items is greater:\n        for (\n            let i = data.length;\n            i < me.children.length; // (Due to min_items)\n            i++\n        ) me.children[i].clear({silent: true});\n        if (focus) me.focus();\n        return; // await me.export({silent: true});\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    @smartdisabling\n    async addItem(options = {}) {//{{{\n        const me = this;\n        // Parameters checking and resolution:{{{\n        options.action = \"addItem\";\n        options.origin ||= null; // (Internal call)\n        options.context ||= me;  // (Internal call)\n        options.source ||= null; // Source component to copy data from.\n        options.target ||= null; // Target child component to insert before/after.\n        options.position ||= \"after\";\n        options.autoscroll ||= null;   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n        options.failback ||= \"throw\";  // \"none\" / \"throw\" (default)\n        if (options.position != \"after\" && options.position != \"before\") throw me.renderError(\n            'LIST_WRONG_ADDITEM_POSITION'\n            , `Invalid value for addItem() position property: ${options.position}`\n        );\n        if (me.children.length >= me.max_items) {\n            switch (options.failback) {\n                case \"none\":\n                    break;\n                case \"throw\":\n                default:\n                    me.emit(\"error\", {\n                        code: 'LIST_MAX_ITEMS_REACHED',\n                        message: `Cannot add items over max_items boundary`,\n                        options,\n                    });\n            };\n            return;\n        };\n        if (me.children.length && ! options.target) options.target = ( // Auto target:\n            options.position == \"before\" ?  me.children[0] // Insert at the beginning\n            : me.children[me.children.length - 1]  // Append at the end\n        );\n        //}}}\n        // DOM element creation:{{{\n        const newItemTarget = me.templates.item.cloneNode(true);\n        //}}}\n        // addItem event emitting:{{{\n        const onRenderedCbks = [];\n            // Allow for handy callback instead of two separate event handlers\n        await me.emit(\"addItem\", {\n            action: options.action,\n                origin: options.origin,\n                context: options.context,\n                target: options.target,\n                position: options.position,\n                newItemTarget,\n                options, // <- Original options (including target)\n                onRendered: cbk => onRenderedCbks.push(cbk),\n        });\n        //}}}\n        // Child component creation and insertion:{{{\n        let newItem;\n        if (! me.children.length) {\n            await me.#appendChild(newItemTarget);\n            newItem = await me.enhance(newItemTarget, {type: \"form\", name: 0});\n            await newItem.rendered;\n            me.children.push(newItem);\n            newItem.name = 0;\n        } else {\n            me.children = (await Promise.all(\n                me.children.map(async (child, i)=>{\n                    if (! child.targetNode.isSameNode(options.target.targetNode)) return child;\n                    if (options.position == \"after\") {\n                        child.targetNode.after(newItemTarget);\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        return [child, newItem]; // Right order, flatted later...\n                    } else {\n                        child.targetNode.before(newItemTarget);\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        return [newItem, child]; // Right order, flatted later...\n                    };\n                })\n            ))\n                .flat()\n            ;\n        };\n        await me.renum();\n        //}}}\n        // Copy data from source component if specified:{{{\n        if (options.source) {\n            const sourceComponent = newItem.find(options.source);\n            if (!! sourceComponent) {\n                const data = await sourceComponent.export();\n                newItem.import({data, silent: true});\n            };\n        };\n        //}}}\n        // Autoscroll handling:{{{\n        if (options.autoscroll == \"elegant\" && !! newItem) {\n            makeRoom(newItem.targetNode, - newItem.offsetHeight);\n        } else {\n            const moveTarget = (\n                ! newItem ? null\n                : options.autoscroll == \"self\" ? newItem\n                : options.autoscroll == \"parent\" ? newItem.parent\n                : null\n            );\n            if (moveTarget) moveTarget.moveTo();\n        };\n        //}}}\n        // Execute \"onRendered\" callbacks:{{{\n        onRenderedCbks.forEach(cbk=>cbk(newItem));\n        //}}}\n        if (me.renderedSync) newItem.focus();\n        return newItem;\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    @smartdisabling\n    async removeItem(options = {}) {//{{{\n        const me = this;\n        options.action = \"removeItem\";\n        options.origin ||= null; // (Internal call)\n        options.context ||= me;  // (Internal call)\n        options.target ||= null; // Target child component to remove.\n        options.autoscroll ||= null;   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n        options.keep_non_empty ||= false;\n        options.failback ||= \"throw\";  // \"none\" / \"clear\" / \"throw\" (default)\n        if (! options.target) {\n            if (options.keep_non_empty) for (\n                const t of [...me.children]\n                .reverse() // Pick last first\n            ) if (await t.isEmpty()) {\n                options.target = t;\n                break;\n            };\n            if (! options.target) {\n                options.target = me.children[me.children.length - 1];\n                options.keep_non_empty = false;\n                // Allow non empty removal as last chance if no target\n                // specified.\n            };\n        };\n        const targets = (\n            options.target instanceof Array ? options.target\n            : [options.target]\n        );\n        for (const currentTarget of [...targets].reverse()) {\n            if (me.children.length <= me.min_items) {\n                switch (options.failback) {\n                    case \"none\":\n                        break;\n                    case \"clear\":\n                        await currentTarget.clear({silent: true});\n                        return;\n                    case \"throw\":\n                    default:\n                        me.emit(\"error\", {\n                            code: 'LIST_MIN_ITEMS_REACHED',\n                            message: `Cannot remove items under min_items boundary`,\n                            options,\n                        });\n                        return;\n                };\n            };\n            if (options.keep_non_empty && ! await currentTarget.isEmpty()) continue;\n            let oldItem = null;\n            let newFocusPosition = null;\n            const newChildren = me.children\n                .filter((child, i, all)=>{\n                    if (child.targetNode.isSameNode(currentTarget.targetNode)) {\n                        if (options.autoscroll == \"elegant\") {\n                            makeRoom(child.targetNode, child.targetNode.offsetHeight);\n                        } else {\n                            const moveTarget = (\n                                options.autoscroll == \"self\" ? child\n                                : options.autoscroll == \"parent\" ? child.parent\n                                : null\n                            );\n                            if (moveTarget) moveTarget.moveTo();\n                        };\n\n                        oldItem = child;\n\n                        newFocusPosition = (\n                            (all.length -i > 1) ? newFocusPosition = i // More above\n                            : i == 0 ? null           // No items left\n                            : i - 1                   // Removing last item\n                        );\n\n                        return false;\n                    };\n                    return true;\n                })\n            ;\n            // removeItem event emitting:{{{\n            const onRemovedCbks = [];\n                // Allow for handy callback instead of two separate event handlers\n            await me.emit(\"removeItem\", {\n                action: options.action,\n                origin: options.origin,\n                context: options.context,\n                target: currentTarget,  // <--- Effective target.\n                oldItem,                 // Child going to be removed.\n                oldItemTarget: oldItem.targetNode, // Its target (analogous to addItem event).\n                options,\n                onRemoved: cbk => onRemovedCbks.push(cbk),\n            });\n            //}}}\n\n            oldItem.targetNode.remove();\n            me.children = newChildren;\n            await me.renum();\n\n            // Execute \"onRemoved\" callbacks:{{{\n            onRemovedCbks.forEach(cbk=>cbk());\n            //}}}\n\n            if (newFocusPosition !== null) {\n                me.children[newFocusPosition].focus();\n            };\n\n        };\n\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of me.children\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async clear({focus} = {}) {//{{{\n        const me = this;\n        return await me.import({data: [], focus, silent: true});\n    };//}}}\n    @action\n    count({delta = 0} = {}) {//{{{\n        // Return number of children.\n        // But also it's sole existence allow reinjecting contents to it.\n        const me = this;\n        return me.children.length + Number(delta);\n    };//}}}\n    @action\n    position({target, offset = 1} = {}) {//{{{\n        return Number(target?.name) + Number(offset);\n    };//}}}\n    async renum(){//{{{\n        const me = this;\n\n        // Update child index:\n        for (const i in me.children) {\n            me.children[i].name = i;\n            me.children[i].updateId();\n        };\n\n        // Handle separators:\n        if (\n            !! me.templates.separator\n            || !! me.templates.last_separator\n        ) for (const i in me.children) {\n\n            const isLastNode = i >= me.children.length - 1;\n            const sepRole = (\n                i <= 0 ? null\n                : isLastNode ? \"last_separator\"\n                : \"separator\"\n            );\n\n            const currentNode = me.children[i].targetNode;\n            const prevNode = currentNode.previousElementSibling;\n            const prevNode_role = prevNode && prevNode.getAttribute(\"data-role\");\n            if (prevNode_role !== sepRole) {\n                if (!! prevNode_role) prevNode.remove();\n                const sepTemplate = me.templates[sepRole];\n                if (!! sepRole && !! sepTemplate) currentNode.parentElement.insertBefore(sepTemplate.cloneNode(true), currentNode);\n            };\n            if (isLastNode) { // LastItem\n                const nextNode = currentNode.nextElementSibling;\n                if (!! nextNode) nextNode.remove();\n            };\n\n        };\n\n        // Handle empty_list template:\n        if (me.templates.empty_list) {\n            if (me.children.length) {\n                me.templates.empty_list.remove(); // (from DOM)\n            } else {\n                await me.#appendChild(me.templates.empty_list);\n            };\n        };\n\n        // Handle placeholder template:\n        if (\n            me.templates.placeholder\n            && !! me.max_items // (Only if we have a finite padding limit)\n        ) {\n            let placeHoldersCount = (me.max_items || 0) - me.children.length;\n            if (\n                placeHoldersCount > 0\n                && me.children.length === 0\n                && !! me.templates.empty_list\n            ) placeHoldersCount--; // Discount the hole occupied by empty_list\n            if (me.placeholders.length < placeHoldersCount) {\n                for (let i = me.placeholders.length; i < placeHoldersCount; i++) {\n                    const placeholder = me.templates.placeholder.cloneNode(true);\n                    if (me.templates.footer) {\n                        me.templates.footer.before(placeholder);\n                    } else {\n                        me.targetNode.appendChild(placeholder);\n                    };\n                    me.placeholders.push(placeholder);\n                };\n            } else { // me.placeholders.length >= placeHoldersCount\n                for (let i = me.placeholders.length; i > placeHoldersCount; i--) {\n                    me.placeholders.pop().remove();\n                };\n            };\n        };\n\n        // Update counter triggers:\n        me.getTriggers(\"position\").forEach(tgg=>{\n            const me = this;\n            const args = tgg.getTriggerArgs();\n            tgg.targetNode.innerText = me.position({...args, silent: true});\n        });\n        me.getTriggers(\"count\").forEach(tgg=>{\n            const me = this;\n            const args = tgg.getTriggerArgs();\n            tgg.targetNode.innerText = me.count({...args, silent: true});\n        });\n    };//}}}\n};\n","// types/input.type.js\n// ===================\nimport {form} from \"./form.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {parseJSON} from \"../lib/helpers.js\";\nexport class input extends form {\n    constructor(...args) {//{{{\n        super(...args);\n        const me = this;\n        me.eventHooks.keydown.push(\n            function keydown_hook(ev) {\n                if (ev.defaultPrevented) return;\n                if (ev.originalEvent.key === \"Enter\") {\n                    const backwards = ev.originalEvent.shiftKey;\n                    if (\n                        ev.target.targetNode.tagName === \"TEXTAREA\"\n                        && ! ev.originalEvent.ctrlKey\n                        && ! backwards\n                    ) return; // Require Ctrl key to escape textareas.\n                    let nextField = (\n                        ! backwards ? ev.target.find(\".+1\") || ev.target.find(\"../.+1\")\n                        : ev.target.find(\".-1\") || ev.target.find(\"../.-1\")\n                    );\n                    if (nextField) {\n                        nextField.focus();\n                        ev.originalEvent.preventDefault();\n                        ev.originalEvent.stopPropagation();\n                    };\n                };\n            },\n        );\n    }; // }}}\n    async render() {//{{{\n        const me = this;\n        me.isSingleton = ! (\n            me.targetNode.tagName === \"INPUT\"\n            || me.targetNode.tagName === \"SELECT\"\n            || me.targetNode.tagName === \"TEXTAREA\"\n        );\n        me.isCheckbox = (\n            ! me.isSingleton\n            && String(me.targetNode.type).toLowerCase() == \"checkbox\"\n        );\n        if (me.isSingleton) {\n            await super.render();\n            const sons = Object.values(me.children);\n            if (sons.length != 1) throw me.renderError(\n                'NOT_A_SINGLETON'\n                , `Singleton forms are only allowed to contain exactly one`\n                + ` data field but ${sons.length} found.`\n            );\n            const son = sons[0];\n            if (me.options.type !== son.options.type) throw me.renderError(\n                'SINGLETON_TYPE_MISMATCH'\n                , `Singleton type (${me.options.type})`\n                + ` does not match child field type (${son.options.type}).`\n            );\n            me.targetFieldNode = son.targetNode;\n        } else {\n            me.targetFieldNode = me.targetNode;\n        };\n        return;\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        const me = this;\n        const nodeFld = me.targetFieldNode;\n        let retv;\n        if (me.isSingleton) {\n            retv = Object.values(await super.export())[0];\n        } else if (me.isCheckbox) {\n            retv = !! nodeFld.checked;\n        } else if (\n            me.options.encoding === \"json\"\n            && nodeFld.tagName.toUpperCase() === \"SELECT\"\n            && nodeFld.options[nodeFld.selectedIndex]?.getAttribute(\"value\") === null\n        ) {\n            // Keep fallback working when encoding is json and value attribute is not set.\n            // (and don't expetct <opton> inner text to be JSON)\n            retv = JSON.stringify(nodeFld.options[nodeFld.selectedIndex].text);\n        } else {\n            retv = nodeFld.value;\n        };\n        return (\n            me.options.encoding === \"json\" ? parseJSON(retv) || null\n            : retv\n        );\n    };//}}}\n    @action\n    @import_from_target\n    async import({data = \"\", focus = true} = {}) {//{{{\n        const me = this;\n        const nodeFld = me.targetFieldNode;\n        if (\n            typeof data === \"object\"\n            && me.options.type === \"input\"    // Not in a derivated field types\n            || me.options.encoding === \"json\" // JSON encoding specified\n        ) {\n            data ||= null;\n            const isTextarea = nodeFld.tagName.toUpperCase() === \"TEXTAREA\";\n            data = (\n                isTextarea ? JSON.stringify(data, null, 4) // Pretty print\n                : JSON.stringify(data) // Compact print\n            ) || \"\";\n        };\n        if (me.isSingleton) {\n            return await super.import({data: Object.fromEntries(\n                [[Object.keys(me.children)[0], data]]\n            ), focus});\n        } else if (me.isCheckbox) {\n            me.targetNode.checked = !! data;\n        } else if (\n            me.options.encoding === \"json\"\n            && nodeFld.tagName.toUpperCase() === \"SELECT\"\n        ) {\n            me.targetNode.value = (data || \"null\"); // Faster, but won't work if value attribute is not set.\n            if (nodeFld.selectedIndex === -1) {\n                // Fallback when value attribute is not set.\n                const parsed = parseJSON(data) || \"\";\n                const idx = Array.from(nodeFld.options).findIndex(\n                    opt => opt.text === parsed\n                );\n                if (idx !== -1) nodeFld.selectedIndex = idx;\n            };\n        } else {\n            me.targetNode.value = data;\n        };\n        if (focus) me.focus();\n        return me.targetNode.value;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = (\n            me.isCheckbox ? \"\" // Do not consider checkboxes.\n            : await me.export()\n        );\n        return ! value.trim().length;\n            // Native input's value type is always a string.\n    };//}}}\n    @action\n    async clear({focus} = {}) {//{{{\n        const me = this;\n        await me.import({\n            data: me.options.encoding === \"json\" ? null : \"\",\n            focus,\n        });\n    };//}}}\n};\n","// types/number.type.js\n// ====================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nexport class number extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"number\").toLowerCase() != \"number\"\n        ) throw me.renderError(\n            'NOT_A_NUMBER_FIELD'\n            , `Number inputs require an INPUT tag of type \"number\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"number\"; // Autofill\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        return (\n            data.length && ! isNaN(data) ? Number(data)\n            : null\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import({data = null, focus = true} = {}) {//{{{\n        const me = this;\n        const typename = typeof data;\n        if (me.isSingleton) return await super.import({data, focus}); // Overload only inner field\n        const retv =  await super.import({data:(\n            typename == \"number\" ? data\n            : typename == \"string\"\n                && data.length\n                && ! isNaN(data)\n                ? Number(data)\n            : null\n        ), focus});\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n","// types/date.type.js\n// ==================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nconst re_timePart = /T.*/;\nfunction parseDateStr(str) {//{{{\n    // Accept \"YYYYMMDD\":\n    if (str.length == 8) return new Date([\n        str.substring(0, 4),\n        str.substring(4, 6),\n        str.substring(6, 8),\n    ].join(\"-\"));\n\n    // Accept \"YYYY-MM-DD\" (like date inputs)\n    // > new Date(\"2023-11-30\")\n    // 2023-11-30T00:00:00.000Z\n    // ...but don't accept if not zero-padded:\n    // > new Date(\"2023-11-3\")\n    // 2023-11-02T23:00:00.000Z\n    if (\n        str.length == 10\n        && str[4] == \"-\"\n        && str[7] == \"-\"\n    ) return new Date(str);\n\n    // Also don't accept other locale dependant formats:\n    // > new Date(\"11/30/2023\")\n    // 2023-11-29T23:00:00.000Z\n\n    return NaN;\n};//}}}\nfunction ISODate(value) {//{{{\n    return value.toISOString().replace(re_timePart, \"\");\n};//}}}\nexport class date extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"date\").toLowerCase() != \"date\"\n        ) throw me.renderError(\n            'NOT_A_DATE_FIELD'\n            , `Date inputs require an INPUT tag of type \"date\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"date\"; // Autofill\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        const data = await super.export(...args);\n        if (me.isSingleton) return data; // Overload only inner field\n        if (! data.length) return null;\n        const value = parseDateStr(data);\n        return (\n            isNaN(value) ? null\n            : ISODate(value)\n        );\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import({data = null, focus = true} = {}) {//{{{\n        const me = this;\n        if (me.isSingleton) return await super.import({data, focus}); // Overload only inner field\n        const value = (\n            data instanceof Date ? data // Accept Date instance\n            : typeof data == \"number\" ? new Date(data) // Accept epoch\n            : ! data || (typeof data != \"string\") ? NaN // Reject nullish\n            : parseDateStr(data) // Handle strings\n        );\n        const retv = await super.import({data:(\n            isNaN(value) ? null\n            : ISODate(value)\n        ), focus});\n        return retv;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n","// types/radio.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nimport {export_to_target} from \"../decorators/export_to_target.deco.js\";\nimport {import_from_target} from \"../decorators/import_from_target.deco.js\";\nimport {randomId} from \"../lib/helpers.js\";\nexport class radio extends input {\n    constructor(...args) {\n        super(...args);\n        const me = this;\n        let master = me.parent.children[me.name];\n        let retv = me;\n        if (master) {\n            me.targetNode.setAttribute(\"name\", master.sharedNodeName);\n            master.radioButtons.push(me.targetNode);\n            retv = {}; // Not the master field.\n        } else {\n            master = me;\n            // Provide unique name for DOM navigation to work properly:\n            master.sharedNodeName = randomId();\n            master.targetNode.setAttribute(\"name\", master.sharedNodeName);\n            master.radioButtons = [\n                master.targetNode\n            ];\n        };\n        let changeEventHandler = onRadioInteraction.bind(master);\n        me.targetNode.addEventListener(\"click\", changeEventHandler);\n        me.targetNode.addEventListener(\"keydown\", changeEventHandler);\n        return retv;\n    };\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"radio\").toLowerCase() != \"radio\"\n        ) throw me.renderError(\n            'NOT_A_RADIO_FIELD'\n            , `Radio inputs require an INPUT tag of type \"radio\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"radio\"; // Autofill\n    };//}}}\n    @action\n    @export_to_target\n    async export() {//{{{\n        return this.radioButtons.find(r=>r.checked)?.value || null;\n    };//}}}\n    @action\n    @import_from_target\n    async import({data = null, focus = true} = {}) {//{{{\n        const selected = this.radioButtons.find(r=>r.value === data);\n        if (selected) {\n            selected.checked = true;\n        } else {\n            this.radioButtons.forEach(r=>r.checked = false);\n        };\n        if (focus) this.focus();\n    };//}}}\n    async isEmpty() {//{{{\n        return ! (1 + this.radioButtons.findIndex(r=>r.checked));\n    };//}}}\n};\n\nfunction onRadioInteraction(event) {//{{{\n    if (\n        event.type === \"click\"\n        || event.type === \"keydown\" && event.code === \"Delete\"\n        // NOTE: Some browsers also send fake click events for toggling radio\n        //       buttons.\n        //       This approach avoids to interfere with that behavior while\n        //       ensuring a consistent keyboard resetting method (through the\n        //       Delete key).\n    ) {\n        const me = this;\n        let checked = true; // All raddio buttons become checked on click.\n        const lastSelection = Object.is(me.lastClicked?.target, event.target);\n        if (lastSelection) checked = (\n            ! me.lastClicked.checked    // Click  => Toggle\n            && event.type !== \"keydown\" // Delete => Reset\n        );\n        me.lastClicked = {\n            target: event.target,\n            checked,\n        };\n        event.target.checked = checked;\n    };\n};//}}}\n","// types/color.type.js\n// ===================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nconst re_color = /^#([a-f0-9]{3}){1,2}$/i;\nconst disabled_style = `\n    opacity: .5;\n    background: repeating-linear-gradient(\n            45deg,\n            black,\n            black 10px,\n            white 10px,\n            white 20px\n        ),\n        black;\n    background-blend-mode: difference;\n`;\nexport class color extends input {\n    constructor(...args) {\n        super(...args);\n        // Add keydown hook to handle \"Delete\" key:\n        this.eventHooks.keydown.push ( ev => {\n            if (ev.defaultPrevented) return;\n            if (ev.originalEvent.key === \"Delete\") {\n                ev.target.clear();\n            };\n        });\n    };\n    async render() {//{{{\n        await super.render();\n        const me = this;\n\n        if (me.isSingleton) return; // (Only for real field)\n\n        // Check targetField's type attribute:\n        const targetTag = me.targetFieldNode.tagName;\n        const targetType = me.targetFieldNode.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"color\").toLowerCase() != \"color\"\n        ) throw me.renderError(\n            'NOT_A_COLOR_FIELD'\n            , `Color inputs require an INPUT tag of type \"color\".`\n        );\n        if (! targetType) me.targetFieldNode.type = \"color\"; // Autofill\n\n        // Iniitialize me.isDefined flag:\n        const valueAttr = me.targetFieldNode.getAttribute(\"value\");\n        me.isDefined = (\n            valueAttr !== null         // value property not defined\n            && valueAttr.trim() !== \"\" // value property defined (string)\n        );\n\n        // Remember original \"style\" attribute and update if appropriate:\n        me.defaultStyleAttr = me.targetFieldNode.getAttribute(\"style\") + \";\";\n        if (! me.isDefined) me.targetFieldNode.setAttribute(\n            \"style\"\n            , me.defaultStyleAttr + disabled_style\n        );\n\n        // Handle me.isDefined set:\n        const resetDefined = ev=>{\n            if (\n                ev.code    !== \"Enter\"\n                && ev.Code !== \"Space\"\n                && ev.code !== undefined // ev.type must be \"click\" or \"change\"\n                    // && ev.type !== \"click\" // Click event\n                    // && ev.type !== \"change\" // Change event\n            ) return;\n            me.isDefined = true;\n            me.targetFieldNode.setAttribute(\"style\", me.defaultStyleAttr);\n        };\n        me.targetFieldNode.addEventListener(\"keydown\", resetDefined);\n        me.targetFieldNode.addEventListener(\"click\", resetDefined);\n        me.targetFieldNode.addEventListener(\"change\", resetDefined);\n\n    };//}}}\n    @action\n    // (Done in parent class) @export_to_target\n    async export(...args) {//{{{\n        const me = this;\n        let data = await super.export(...args);\n        if (! me.isSingleton) data = (\n            me.isDefined && data.match(re_color) ? data.toLowerCase()\n            : null\n        );\n        return data;\n    };//}}}\n    @action\n    // (Done in parent class) @import_from_target\n    async import({data = null, focus = true} = {}) {//{{{\n        const me = this;\n        if (\n            ! me.isSingleton // Only for real field\n        ) {\n            if (\n                data === null              // Explicit null value\n                || ! data.match(re_color)  // Invalid color value\n            ) {\n                me.isDefined = false;\n                me.targetFieldNode.setAttribute(\n                    \"style\"\n                    , me.defaultStyleAttr + disabled_style\n                );\n            } else {\n                me.isDefined = true;\n                me.targetFieldNode.setAttribute(\"style\", me.defaultStyleAttr);\n            };\n        };\n        if (data.length == 4) data = `#${data[1]}${data[1]}${data[2]}${data[2]}${data[3]}${data[3]}`;\n        const value = await super.import({data, focus});\n        return (\n            me.isDefined ? value\n            : null\n        );\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n\n","// SmarkForm.js\n// ============\n\nimport {createType} from \"./lib/component.js\";\nimport {hotKeys_handler} from \"./lib/hotkeys.js\";\n\n// Import core component types and event handlers:\nimport {trigger, onTriggerClick} from \"./types/trigger.type.js\";\nimport {label} from \"./types/label.type.js\";\nimport {form} from \"./types/form.type.js\";\nimport {list} from \"./types/list.type.js\";\nimport {input} from \"./types/input.type.js\";\nimport {number} from \"./types/number.type.js\";\nimport {date} from \"./types/date.type.js\";\nimport {radio} from \"./types/radio.type.js\";\nimport {color} from \"./types/color.type.js\";\n\n\n// Load core component types:\nfor (const [name, controller] of Object.entries({\n    trigger,\n    label,\n    form,\n    list,\n    input,\n    number,\n    date,\n    radio,\n    color,\n})) createType(name,controller);\n\n\nclass SmarkForm extends form {\n    constructor(\n        targetNode\n        , {\n            customActions = {},\n            ...formOptions\n        } = {}\n    ) {\n        const options = {\n            ...formOptions,\n            name: \"\",\n            type: \"form\",\n        };\n        super(\n            targetNode\n            , options\n            , null // (Root has no parent)\n        );\n        const me = this;\n        me.setNodeOptions(me.targetNode, options);\n        me.actions = {\n            ...me.actions,\n            ...Object.fromEntries(\n                Object.entries(customActions)\n                    .map(([name, ctrl])=>[name, ctrl.bind(me)])\n            ),\n        };\n        me.targetNode.addEventListener(\n            \"click\"\n            , onTriggerClick.bind(me)\n            , true\n        );\n        new hotKeys_handler(me);\n    };\n    async render() {\n        const me = this;\n        me.targetNode.setAttribute(\"aria-busy\", \"true\");\n        await super.render();\n        me.targetNode.setAttribute(\"aria-busy\", \"false\");\n    };\n};\n\nSmarkForm.createType = createType;\n\nexport default SmarkForm;\n\n"],"names":["getRoots","target","selector","isTop","parentNode","n","isSameNode","querySelectorAll","filter","e","closest","makeRoom","element","pixels","parent","direction","scrollHeight","clientHeight","maxScroll","scrollTop","randomId","Math","random","toString","substring","parseJSON","str","JSON","parse","err","sym_local_events","Symbol","sym_all_events","re_actionEvHandler","re_localEvHandler","re_allEvHandler","supportedFieldEventTypes","registerEvHandler","evList","evType","evHandler","has","set","get","push","bind","this","events","targetComponentType","_ref","kind","constructor","optionsSrc","options","onOptionCallbacks","key","value","Object","entries","match","_len","arguments","length","args","Array","_key","super","me","Map","onLocal","onAll","on","eventHooks","parentStore","arrayStore","prop","defineProperty","Proxy","_dynamic","createArrayPuller","is","root","targetNode","addEventListener","ev","targetComponent","getComponent","evData","type","originalEvent","emit","evt","handler","listenLevel","targetHandlers","parents","parentHandlers","eventHook","legacy","disEnhance","tagName","toLowerCase","event","preventDefault","componentTypes","sym_smart","re_valid_typename_chars","re_has_wildcards","errors","Error","code","message","path","stack","split","slice","join","_SmarkComponent","SmarkComponent","property_name","undefined","validName","counter","isSingleton","names","n0","trim","actions","types","setNodeOptions","renderError","iterator","current","autoId","inherittedOption","setRendered","genId","p","replace","onRenderedTasks","renderedSync","rendered","Promise","resolve","children","render","task","setTimeout","onRendered","cbk","getNodeOptions","node","defaultOptions","dataset","opt","action","parentComponent","String","getAttribute","inferType","stringify","enhance","ctrl","parentElement","getPath","map","name","reverse","find","base","parts","x","firstWildcardPos","findIndex","re_pattern","wname","RegExp","pivotPath","restPath","pivot","child","_ref2","flat","Infinity","reduce","delta","parseInt","isNaN","keys","currentPosition","newKey","optName","defaultValue","moveTo","id","document","location","hash","window","history","pushState","pathname","getTriggers","myCurrentActions","actionKeys","Set","returnAll","tgg","getTriggerArgs","context","updateId","newId","values","focus","fname","targetFieldNode","static","_staticBlock","_initClass","_applyDecs","c","SmarkField","_isField","hasOwnProperty","setAttribute","createType","controller","prototype","hotKeys_handler","form","revealed","onStatusChange","reveal","ctrlKey","altKey","level","targettedTrigger","t","hotkey","stopPropagation","disabled","click","removeAttribute","component","activeContexts","activeContextsSet","candidateTriggers","ctx","distance","tg","sort","ta","tb","seen","candidate","times","targetMtd","addInitializer","async","defaultPrevented","silent","data","apply","trigger","triggerArgs","onTriggerRender","disable","enable","contextPath","targetPath","otherOptions","origin","onTriggerClick","mtd","label","allow_select","newItem","labelArgs","getLabelArgs","style","candidates","found","childName","foldable","_initProto","retv","fold","operation","folded","wasFolded","display","isFolded","originalDisplayProp","forEach","foldedClass","unfoldedClass","classList","export_to_target","method","call","import","error","import_from_target","export","_form","fromEntries","all","dataConstructor","isEmpty","clear","updateTriggers","min_items","failback","max_items","smartdisabling","sym_mux","Mutex","mtx","lock","nextResolve","nextMtx","currMtx","then","mutex","muxName","unlock","sortable","_moveDecs","templates","item","dragSource","dragDest","move","from","to","fromi","Number","toi","newChunk","splice","moveMethod","renum","_list","list","appendChild","header","after","_exportDecs","_addItemDecs","_removeItemDecs","max","role","remove","last_separator","separator","querySelector","loadTemplates","placeholders","tplOptions","of","tpl","footer","i","addItem","emptyChilds","stripEmpties","min","removeItem","source","position","autoscroll","newItemTarget","cloneNode","onRenderedCbks","before","sourceComponent","offsetHeight","moveTarget","keep_non_empty","targets","currentTarget","oldItem","newFocusPosition","newChildren","onRemovedCbks","oldItemTarget","onRemoved","count","offset","isLastNode","sepRole","currentNode","prevNode","previousElementSibling","prevNode_role","sepTemplate","insertBefore","nextNode","nextElementSibling","empty_list","placeholder","placeHoldersCount","pop","innerText","input","keydown","backwards","shiftKey","nextField","isCheckbox","sons","son","nodeFld","checked","encoding","toUpperCase","selectedIndex","text","parsed","idx","number","targetTag","targetType","typename","re_timePart","parseDateStr","Date","NaN","ISODate","toISOString","date","radio","master","sharedNodeName","radioButtons","changeEventHandler","onRadioInteraction","r","selected","lastClicked","re_color","disabled_style","color","valueAttr","isDefined","defaultStyleAttr","resetDefined","Code","SmarkForm","customActions","formOptions"],"mappings":"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"}