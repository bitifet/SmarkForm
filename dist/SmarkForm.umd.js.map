{"version":3,"file":"SmarkForm.umd.js","sources":["../src/lib/events.js","../src/lib/legacy.js","../src/lib/component.js","../src/lib/hotkeys.js","../src/types/trigger.type.js","../src/types/label.type.js","../src/lib/helpers.js","../src/decorators/foldable.deco.js","../src/types/form.type.js","../src/decorators/mutex.deco.js","../src/types/list.decorators/sortable.deco.js","../src/types/list.type.js","../src/types/input.type.js","../src/types/number.type.js","../src/types/date.type.js","../src/main.js"],"sourcesContent":["// lib/events.js\n// =============\n\nconst sym_local_events = Symbol(\"Events\");\nconst sym_all_events = Symbol(\"allEvents\");\nconst re_actionEvHandler = /^on(?:Before|After)Action_/;\nconst re_localEvHandler = /^onLocal_/;\nconst re_allEvHandler = /^onAll_/;\n\nfunction registerEvHandler(evList, evType, evHandler) {\n    const me = this;\n    if (! evList.has(evType)) evList.set(evType, []);\n    evList.get(evType).push(evHandler.bind(me));\n    return me; // Make chainable.\n};\n\nexport const events = function events_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class eventEnebledTarget extends target {\n            constructor(target, optionsSrc, ...args) {\n\n                // Capture before/after action event hanlers through\n                // onBeforeAction_xxx / onAfterAction_xxx options\n                // ...and onLocal_xxx / onAll_xxx regular event handlers.\n                const options = {};\n                const onOptionCallbacks = [];\n                for (\n                    const [key, value]\n                    of Object.entries(optionsSrc)\n                ) if (key.match(re_actionEvHandler)) {\n                    onOptionCallbacks.push([key.substring(2), value, \"onLocal\"])\n                } else if (key.match(re_localEvHandler)) {\n                    onOptionCallbacks.push([key.substring(8), value, \"onLocal\"])\n                } else if (key.match(re_allEvHandler)) {\n                    onOptionCallbacks.push([key.substring(6), value, \"onAll\"])\n                } else {\n                    // Threat the rest as regular options:\n                    options[key] = value;\n                };\n\n                // Call original constructor:\n                super(target, options, ...args);\n\n                // Events enhancing:\n                const me = this;\n                const ImRoot = Object.is(me, me.root);\n                me[sym_local_events] = new Map();\n                if (ImRoot) me.root[sym_all_events] = new Map();\n                me.onLocal = registerEvHandler.bind(me, me[sym_local_events]);\n                me.onAll = registerEvHandler.bind(me.root, me.root[sym_all_events]);\n                me.on = me.onLocal; // Handy and readable alias for local events.\n\n                // Setup action handlers provided through options:\n                for (\n                    const [evt, handler, listenLevel]\n                    of onOptionCallbacks\n                ) me[listenLevel](evt, handler);\n\n            };\n            async emit(evType, evData) {\n                const me = this;\n                const handlers = [ // Local handlers, then global ones:\n                    ...(me[sym_local_events].get(evType) || []),\n                    ...(me.root[sym_all_events].get(evType) || []),\n                ];\n                let defaultPrevented = false;\n                if (handlers.length) {\n                    let propagationStopped = false;\n                    evData.preventDefault = () => defaultPrevented = true;\n                    evData.stopPropagation = () => propagationStopped = true;\n                    for (const handler of handlers) {\n                        if (propagationStopped) break;\n                        await handler(evData);\n                    };\n                };\n                return ! defaultPrevented;\n            };\n        };\n    };\n};\n\n","// src/lib/legacy.js\n// =================\n\nexport default {\n    disEnhance(me) {\n\n        // Prevent <form>'s default behaviour:\n        if (me.target.tagName.toLowerCase()) {\n            me.target.addEventListener('submit', function(event) {\n\n                // Avoid form's regular submission:\n                event.preventDefault();\n\n                // More work may be needed to be done here (let's give it some\n                // more thought...)\n\n            });\n        };\n\n    },\n};\n","// lib/component.js\n// ================\nconst componentTypes = {};\n\nimport {events} from \"./events.js\";\nimport legacy from \"./legacy.js\";\n\nconst sym_smart = Symbol(\"smart_component\");\nconst re_valid_typename_chars = /^[a-z0-9_]+$/i;\nconst re_has_wildcards = /[\\*\\?]/;\nconst wild2regex = wname => new RegExp(//{{{\n    \"^\"\n    + wname\n        .replace(/\\*+/g, \".*\")\n        .replace(/\\?/g, \".\")\n    + \"$\"\n);//}}}\n\nconst errors = {\n    renderError: class renderError extends Error {//{{{\n        constructor(code, message, path) {\n            super(`RenderError(${path}): ${message}`);\n            this.code = code;\n            this.path = path;\n            this.stack = this.stack\n                .split(\"\\n\")\n                .slice(2)\n                .join(\"\\n\")\n            ;\n        };\n    },//}}}\n};\n\nfunction inferType(node, parentComponent) {//{{{\n    switch (node.tagName.toLowerCase()) {\n        case \"ul\":\n        case \"ol\":\n        case \"table\":\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n            return \"list\";\n        case \"input\":\n            const type = String(node.getAttribute(\"type\")||\"\").toLowerCase();\n            switch(type) {\n                case \"number\":\n                case \"date\":\n                    return type;\n            };\n        case \"textarea\":\n        case \"select\":\n            return \"input\";\n        case \"label\":\n            return \"label\";\n        default:\n            //if (parentComponent.options.type == \"list\") return \"form\";\n        case \"form\":\n            return \"form\";\n    };\n};//}}}\n\n@events\nexport class SmarkComponent {\n    constructor(//{{{\n        target\n        , {\n            property_name = \"smark\",\n            ...options\n        } = {}\n        , parent\n    ) {\n        const me = this;\n\n        me.validName = (function nameGenerator() {//{{{\n            let counter = 0;\n            return function(...names){\n                for (\n                    let n0 of names\n                ) if (\n                    typeof n0 == \"string\"\n                ) {\n                    n0 = n0.trim();\n                    if (n0.length) return n0;\n                };\n                return 'UNNAMED'+(++counter);\n            };\n        })();//}}}\n\n        me.actions = {};\n        me.property_name = property_name;\n        me.selector = `[data-${me.property_name}]`;\n        me.types = componentTypes;\n        me.target = target;\n        me.options = options;\n        me.setNodeOptions(me.target, me.options);\n\n        me.parent = parent;\n        if (! me.parent instanceof SmarkComponent) throw me.renderError(\n            'INVALID_PARENT'\n            , `Smark Components must have valid Smark Component parent.`\n        );\n        me.root = (\n            me.parent === null ? me\n            : me.parent.root\n        );\n\n        // Parents iterator:\n        me.parents = {};\n        me.parents[Symbol.iterator] = function* () {\n            let current = me;\n            while (current) {\n                yield current;\n                current = current.parent;\n            };\n        };\n\n        // Calculate prefix or disable autoId:\n        const autoId = me.inherittedOption(\"autoId\", false);\n        me.genId = (\n            autoId === false ? false\n                // Do not auto-generate IDs.\n            : autoId === true ? p => p.replace(/\\//g, \"_\")\n                // Use \"_path_in_underscore_style\".\n            : typeof autoId == \"string\" ? p => autoId+p.replace(/\\//g, \"_\")\n                // Use \"prefix\" + \"_path_in_underscore_style\".\n            : typeof autoId == \"function\" ? autoId\n                // Use fn(path) custom style.\n            : false\n                // Failback to disabled.\n        );\n\n        me.onRenderedTasks = [];\n\n        let setRendered;\n        me.rendered = new Promise(resolve => setRendered = resolve);\n\n        me.children = {};\n        me.target[sym_smart] = me;\n\n        (async ()=>{\n            await me.render();\n            for (\n                const task of me.onRenderedTasks\n            ) await task();\n            me.onRenderedTasks = null;\n            setRendered(true);\n        })();\n        if (me.options.onRendered) me.onRendered(me.options.onRendered);\n\n    };//}}}\n    onRendered(cbk) {//{{{\n        const me = this;\n        if (me.onRenderedTasks) {\n            me.onRenderedTasks.push(cbk.bind(me));\n        } else {\n            cbk.bind(me)();\n        };\n    };//}}}\n    getNodeOptions(node, defaultOptions) {//{{{\n        const me = this;\n        const optionsSrc = (\n            node.dataset[me.property_name] || \"\"\n        ).trim() || null;\n        const options = {\n            ...defaultOptions,\n            ...(()=>{\n                try {\n                    const opt = JSON.parse(optionsSrc);\n                    if (typeof opt != \"object\") throw new Error(\"NO_OBJECT\");\n                    return opt;\n                } catch (err) {\n                    return (\n                        optionsSrc.match(re_valid_typename_chars) ? {type: optionsSrc}\n                        : {}\n                    );\n                };\n            })(),\n        };\n        if (! options.action && ! options.type) options.type = inferType(node, me);\n        me.setNodeOptions(node, options);\n        return options;\n    };//}}}\n    setNodeOptions(node, options) {//{{{\n        const me = this;\n        node.dataset[me.property_name] = JSON.stringify(options);\n    };//}}}\n    async enhance(node, defaultOptions) {//{{{\n        const me = this;\n\n        // Sanityze and store options:{{{\n        let options = me.getNodeOptions(node, defaultOptions);\n        //}}}\n\n        // Prevent default behaviours:{{{\n        legacy.disEnhance(me);\n        //}}}\n\n        // Classify:{{{\n        if (options.action) {\n            if (! options.type) options.type = \"trigger\"; // Make type optional for triggers.\n            if (options.type != \"trigger\") throw me.renderError(\n                \"ACTION_IN_NON_TRIGGER\"\n                , `\"action\" property is only allowed for \"trigger\" components but \"${options.type}\" type specified.`\n            );\n        } else if (typeof options.type != \"string\") {\n            throw me.renderError(\n                \"NO_TYPE_PROVIDED\"\n                , `Invalid SmarkForm item: type is mandatory for non trigger components.`\n            );\n        };\n        //}}}\n\n        // Enhance:{{{\n        const ctrl = me.types[options.type];\n        if (! ctrl) throw me.renderError(\n            \"UNKNOWN_TYPE\"\n            , `Unimplemented SmarkForm component controller: ${options.type}`,\n        );\n        return new ctrl (\n            node\n            , options\n            , me\n        );\n        //}}}\n\n    };//}}}\n    getComponent(target) {//{{{\n        const me = this;\n        return (\n            target[sym_smart]\n            || target.parentElement?.closest(me.selector)[sym_smart]\n            || null\n        );\n    };//}}}\n    getPath() {//{{{\n        const me = this;\n        return (\n            [...me.parents].map(p=>p.name)\n            .reverse()\n            .join(\"/\") // Root parent being \"\" => Starting \"/\".\n            || \"/\" // No join (0 parents => root node)\n        );\n    };//}}}\n    find(path=\"\") { // {{{\n        let base=this;\n        if (path[0] == \"/\") while (base.parent) base = base.parent;\n        const parts = path\n            .split(\"/\")\n            .filter(x=>x)\n        ;\n\n        // (Recursive) Multi-match search (path with '*' wildcards):\n        // (Returns array of components)\n        const firstWildcardPos = parts.findIndex(p=>p.match(re_has_wildcards));\n        if (firstWildcardPos >= 0) {\n            const re_pattern = wild2regex(parts[firstWildcardPos]);\n            const pivotPath = parts.slice(0, firstWildcardPos).join(\"/\");\n            const restPath = parts.slice(firstWildcardPos + 1).join(\"/\");\n            const pivot = base.find(pivotPath);\n            const pivotChilds = Object.entries(pivot.children);\n            return pivotChilds\n                .filter(([name,child])=>child && name.match(re_pattern))\n                .map(([,child])=>child.find(restPath))\n                .flat(Infinity)\n            ;\n        };\n\n        // Straight search (wildcardless path)\n        // (Returns single component)\n        return parts.reduce(\n            ((current, name)=>(\n                current === undefined ? null\n                : name == \"..\" ? current.parent\n                : current.children[name]\n            ))\n            , base\n        )\n    ;\n    };//}}}\n    inherittedOption(optName, defaultValue) {//{{{\n        const me = this;\n        for (\n            const p of me.parents\n        ) if (\n            p.options[optName] !== undefined\n        ) return p.options[optName];\n        return defaultValue;\n    };//}}}\n    moveTo(){//{{{\n        const me = this;\n        if (! me.target.id) me.target.id = me.getPath();\n        document.location.hash = me.target.id;\n        // Avoid noisy url hash \"randomish\" effect:\n        window.history.pushState({}, undefined,window.location.pathname);\n            // Like 'document.location.hash = \"\"' but without leaving leading\n            // hash character.\n    };//}}}\n    getTriggers(actionNames = \"\") {//{{{\n        const me = this;\n        const myCurrentActions = [];\n        const actionKeys = new Set([actionNames]\n            .flat()\n            .map(String)\n            .filter(x=>x)\n        );\n        const returnAll = actionKeys.has(\"*\");\n        for (\n            const tgg\n            of [...me.root.target.querySelectorAll(me.selector)]\n                .map(target=>target[sym_smart])\n                .filter(x=>x) // Ignore not yet rendered.\n        ) {\n            const options = tgg.getTriggerArgs()\n            if (! options) continue; // Not a trigger\n            if (! Object.is(options.context, me)) continue;\n            if (\n                returnAll\n                || actionKeys.has(options.action)\n            ) myCurrentActions.push(tgg);\n        };\n        return myCurrentActions;\n    };//}}}\n    updateId() {//{{{\n        const me = this;\n        if (me.genId === false) return; // Abort if disabled.\n        const newId = me.genId(me.getPath());\n        if (me.target.id != newId) {\n            me.target.id = newId;\n            for (\n                const child\n                of Object.values(me.children)\n            ) child.updateId();\n        };\n        return me.target.id\n    };//}}}\n    focus() {//{{{\n        const me = this;\n        for (const fname in me.children) {\n            return me.children[fname].focus();\n        };\n        me.targetField.focus();\n    };//}}}\n    getTriggerArgs() {}; // Let's easily filter out non trigger compoenents.\n    // Error types:\n    renderError(code, message) {//{{{\n        const me = this;\n        return new errors.renderError(code, message, me.getPath());\n    };//}}}\n};\n\nexport class SmarkField extends SmarkComponent {\n    constructor(...args){\n        super(...args);\n        this._isField = true;\n    };\n};\n\nexport function createType(name, controller) {//{{{\n    if (componentTypes[name] !== undefined) throw new Error(\n        `Duplicate component type definition: ${name}`\n    );\n    if (! (controller.prototype instanceof SmarkComponent)) throw new Error(\n        `Bad component type implementation for: ${name}`\n    );\n    componentTypes[name] = controller;\n};//}}}\n\n","// lib/hotkeys.js\n// ==============\n\nexport class hotKeys_handler {\n    constructor(form) {\n        const me = this;\n        me.form = form;\n        me.revealed = null;\n        me.form.target.addEventListener(\n            \"keydown\"\n            , me.onKeydown.bind(me)\n            , true\n        );\n        me.form.target.addEventListener(\n            \"keyup\"\n            , me.onKeyup.bind(me)\n            , true\n        );\n        me.form.target.addEventListener(\n            \"focusout\"\n            , me.onFocusout.bind(me)\n            , true\n        );\n        me.form.target.addEventListener(\n            \"focusin\"\n            , me.onFocusin.bind(me)\n            , true\n        );\n    };\n    onKeydown(ev) {\n        const me = this;\n        if (ev.key == \"Control\") {\n            me.reveal(ev.target); // Activate and reveal.\n        } else if (ev.ctrlKey) {\n            const targettedTrigger = me.revealed.find(\n                t=>t.options.hotkey == ev.key\n            );\n            if (targettedTrigger) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                targettedTrigger.target.click();\n            };\n        };\n    };\n    onKeyup(ev) {\n        const me = this;\n        if (ev.key == \"Control\") {\n            me.reveal(false); // Deactivate\n        };\n    };\n    onFocusout(ev) {\n        const me = this;\n        if (me.revealed !== null) {\n            me.reveal(); // Unreveal, keep activated.\n        };\n    };\n    onFocusin(ev) {\n        const me = this;\n        if (me.revealed !== null) {\n            me.reveal(ev.target); // Update revealed triggers\n        };\n    };\n    reveal(target) {\n        const me = this;\n\n        // Conceal previous target triggers' hotkeys if any:\n        if (me.revealed !== null) {\n            for (const t of me.revealed) {\n                t.target.removeAttribute(\"data-hotkey\");\n            };\n            me.revealed.length = 0;\n        };\n\n        if (target === false) {\n            me.revealed = null; // Deactivate hot keys\n        };\n\n        if (target) {\n            // Reveal new target triggers' hotkeys:\n            const component = me.form.getComponent(target);\n\n            const context = (\n                component.parent.isSingleton ? component.parent\n                : component\n            );\n\n            me.revealed = [component, ...component.parents]\n                .flatMap(p=>p.getTriggers('*'))\n                .filter(\n                    t=>Object.is(t.getTriggerArgs()?.target?.target, context.target)\n                )\n            ;\n\n            for (const t of me.revealed) {\n                const {hotkey} = t.options;\n                if (hotkey) t.target.setAttribute('data-hotkey', hotkey);\n            };\n\n        };\n\n    };\n};\n","// types/trigger.type.js\n// =====================\nimport {SmarkComponent} from \"../lib/component.js\";\n\nconst beforeEvent = Symbol(\"beforeEventName\");\nconst afterEvent = Symbol(\"afterEventName\");\n\nexport const action = function action_decorator(targetMtd, {kind, name, addInitializer}) {\n    if (kind == \"method\") addInitializer(function registerAction() {\n        this.actions[name] = targetMtd.bind(this);\n        this.actions[name][beforeEvent] = `BeforeAction_${name}`;\n        this.actions[name][afterEvent] = `AfterAction_${name}`;\n    });\n};\n\n\nexport class trigger extends SmarkComponent {\n    constructor(node, options, ...args){\n        delete options.name; // Triggers are always unnamed.\n        return super(node, options, ...args);\n    };\n    render(){\n        const me = this;\n        me.parent.onRendered(()=>{\n            const triggerArgs = me.getTriggerArgs();\n            if (\n                typeof triggerArgs.context?.onTriggerRender == \"function\"\n            ) triggerArgs.context.onTriggerRender(triggerArgs);\n        });\n    };\n    disable() {//{{{\n        const me = this;\n        me.target.disabled = true;\n    };//}}}\n    enable() {//{{{\n        const me = this;\n        me.target.disabled = false;\n    };//}}}\n    getTriggerArgs() {//{{{\n        const me = this;\n        const parents = [...me.parents];\n        const {\n            // property: local variable\n            action: actionSpec,\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n        if (! actionSpec) return; // Not a trigger component.\n\n        // Allow binding triggers to specific component types:\n        // (Syntax \"type:action\")\n        let [actionName, targetType] = actionSpec.split(\":\").reverse();\n\n        const context = (\n            contextPath ? me.parent.find(contextPath)\n            : parents.find(p=>{\n                if (targetType && p.options.type != targetType) return false;\n                if (typeof p.actions[actionName] != \"function\") return false;\n                return true;\n            })\n        );\n\n        const target = (\n            targetPath ? context.find(targetPath) // Explicit target (context relative)\n            : contextPath ? null // Explicit context path => don't mind component position\n            : parents.find(p=>p.parent?.target.isSameNode(context?.target))\n        );\n\n        return {\n            action: actionName,\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n\nexport async function onTriggerClick(ev) {\n    const me = this;\n    const triggerComponent = me.getComponent(ev.target);\n    const options = triggerComponent.getTriggerArgs();\n    if (! options) return; // Not a trigger.\n    const {context, action} = options;\n    const mtd = context?.actions[action]\n    if (\n        typeof mtd != \"function\"\n    ) throw me.renderError(\n        \"UNKNOWN_ACTION\"\n        , `Unknown action ${action}`\n        + (context ? ` for ${context.options.type}` : \"\")\n    );\n    if (await me.emit(mtd[beforeEvent], options)) {\n        const data = await mtd(options);\n        me.emit(mtd[afterEvent], {...options, data});\n    };\n};\n\n\n","// types/label.type.js\n// ===================\nimport {SmarkComponent} from \"../lib/component.js\";\n\n// TODO:\n// =====\n//\n//   ðŸš€ Add support for (smarkform) fields contained in the label.\n//      ðŸ‘‰ Now we can just not enhance the label (<label>Bla bla bla<input\n//         data-smark></label>) and it will (in this case natively) work.\n//      ðŸ‘‰ ...but this does not allow us to use other SmarkForm fields such as\n//         forms and lists (since they can contain more than one native field\n//         which is not allowed by <label> tag.\n//      ðŸ’¡ But we can use different tag (with {data-smark=\"label\"}) and just\n//         create the native <label> tag around the text.\n//\n//   ðŸš€ Implement \"text templating\" feature.\n//      ðŸ‘‰ This should allow to include contextual data in the text of the\n//         label.\n//      âš¡ For example, list item position for list items...\n//\n\nexport class label extends SmarkComponent {\n    constructor(node, options, ...args){\n        delete options.name; // Labels are always unnamed.\n        return super(node, options, ...args);\n    };\n    render(){\n        const me = this;\n        me.parent.onRendered(()=>{\n            const labelArgs = me.getLabelArgs();\n            const {targetField} = labelArgs.target || {};\n            if (targetField) { // Apply only to native inputs (scalars)\n                if (! targetField.id) { // Ensure targetted field has an Id\n                    targetField.id = Math.random().toString(36).substring(2);\n                };\n                me.target.setAttribute(\"for\", targetField.id);\n            };\n        });\n    };\n    getLabelArgs() {//{{{\n        const me = this;\n        const parents = [...me.parents];\n        let context, target;\n\n        const {\n            // property: local variable\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n\n        if (! contextPath && ! targetPath) {\n            // Guess ;-)\n            context = me.parent;\n            const candidates = context.target.querySelectorAll(me.selector);\n            let found = false;\n            for (const childName in candidates) {\n                if (found) {\n                    let targetComponent = me.getComponent(candidates[childName]);\n                    if (targetComponent?._isField) {\n                        // FIXME : Dig deeper in case of non native field tags\n                        // (forms, lists, singletons...)\n                        // It may require to await for rendering or even listen\n                        // to events (lists with minItems = 0);\n                        target = targetComponent;\n                        break;\n                    };\n                } else if (\n                    Object.is(candidates[childName], me.target)\n                ) {\n                    found = true;;\n                };\n            };\n        } else {\n            context = (\n                contextPath ? me.parent.find(contextPath)\n                : me.parent\n            );\n            target = (\n                targetPath ? context.find(targetPath) // Explicit target (context relative)\n                : context\n            );\n        };\n\n        return {\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n","\"use strict\";\nexport function getRoots(target, selector){//{{{\n    const parent = target.parentNode;\n    const isTop = (\n        parent === null ? n => n === null\n        : n=>(n===null)||n.isSameNode(target)\n    );\n    return [\n        ...target.querySelectorAll(selector)\n    ].filter(\n        e=>isTop(e.parentNode.closest(selector))\n    );\n};//}}}\n\nexport function makeRoom(element, pixels) {//{{{\n    let parent = element.parentNode;\n    const direction = (\n        pixels >= 0 ? 1\n        : -1\n    );\n    while (parent) {\n        // Check if parent has vertical scroll bar\n        if (parent.scrollHeight > parent.clientHeight * direction) {\n            // Get the maximum amount that can be scrolled in this parent\n            var maxScroll = parent.scrollHeight - parent.clientHeight * direction;\n\n            // If desired amount is less than maximum scroll, perform scroll\n            if (pixels <= maxScroll * direction) {\n                parent.scrollTop += pixels;\n                return;\n            } else {\n              // If desired amount is greater than maximum scroll,\n              // scroll to maximum and subtract it from desired amount\n              parent.scrollTop = maxScroll;\n              pixels -= maxScroll;\n            };\n        };\n        parent = parent.parentNode;\n    };\n};//}}}\n\n","\nimport {action} from \"../types/trigger.type.js\";\n\nexport const foldable = function foldable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class foldableTarget extends target {\n            render(...args) {//{{{\n                const retv = super.render(...args);\n                const me = this;\n                me.root.onRendered(()=>{\n                    me.fold({operation: (\n                        !! me.options.folded ? \"fold\"\n                        : \"unfold\"\n                    )});\n                });\n                return retv;\n            };//}}}\n            @action\n            fold({//{{{\n                operation = \"toggle\", // Values: \"fold\" / \"unfold\" / \"toggle\"\n            } = {}) {\n                const me = this;\n                const wasFolded = me.target.style.display == \"none\";\n                const isFolded = (\n                    operation == \"fold\" ? true\n                    : operation == \"unfold\" ? false\n                    : ! wasFolded\n                );\n                me.target.style.display = (\n                    isFolded ? \"none\"\n                    : me.originalDisplayProp\n                );\n\n                me.getTriggers(\"fold\").forEach(tgg => {\n                    const {foldedClass, unfoldedClass} = tgg.options;\n                    if (foldedClass) tgg.target.classList[\n                        isFolded ? \"add\"\n                        : \"remove\"\n                    ](foldedClass);\n                    if (unfoldedClass) tgg.target.classList[\n                        isFolded ? \"remove\"\n                        : \"add\"\n                    ](unfoldedClass);\n                });\n\n                me.getTriggers([\"addItem\", \"removeItem\"]).map(\n                    isFolded ? tgg => tgg.disable()\n                    : tgg => tgg.enable()\n                );\n            };//}}}\n        };\n    };\n};\n","// types/form.type.js\n// ==================\n\nimport {SmarkField} from \"../lib/component.js\";\nimport {getRoots} from \"../lib/helpers.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {action} from \"./trigger.type.js\";\n\n@foldable\nexport class form extends SmarkField {\n    async render() {//{{{\n        const me = this;\n        me.originalDisplayProp = me.target.style.display;\n        // Enhance childs:\n        for (\n            const node\n            of getRoots(me.target, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            if (!! newItem._isField) {\n                newItem.name = me.validName(\n                    newItem.options.name\n                    , node.getAttribute(\"name\")\n                );\n                me.children[newItem.name] = newItem;\n                newItem.updateId();\n            };\n        };\n    };//}}}\n    @action\n    async export() {//{{{\n        const me = this;\n        return Object.fromEntries(\n            await Promise.all(Object.entries(me.children).map(\n                async ([key, child])=>[key, await child.export()]\n            ))\n        );\n    };//}}}\n    @action\n    async import({data = {}}) {//{{{\n        const me = this;\n        const dataConstructor = Object(data).constructor;\n        if (dataConstructor !== {}.constructor) throw me.renderError(\n            'FORM_NOT_PLAIN_OBJECT'\n            , `Expected plain object for form import, ${dataConstructor.name} given.`\n        );\n        return Object.fromEntries(\n            await Promise.all(\n                Object.entries(me.children).map(\n                    async ([key, target]) => {\n                        // Could have used target.then(...) but, event\n                        // components' import() method SHOULD be async, it\n                        // would have failed in case it's not.\n                        // Forcing it to be async is not possible because\n                        // transpilers would break this check.\n                        // ...and, IMHO, this approach is better than a dirty\n                        // Promise.resolve(...)\n                        const value = await target.import({data: data[key]});\n                        return [key, value];\n                    }\n                )\n            )\n        );\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of Object.values(me.children)\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async empty() {//{{{\n        const me = this;\n        return await me.import({data: {}});\n    };//}}}\n};\n","\nconst sym_mux = Symbol(\"smart_mutex\");\n\nclass Mutex {\n    constructor() {\n        this.mtx = Promise.resolve();\n    };\n    lock() {\n        // Sync operation:\n        let nextResolve;\n        const nextMtx = new Promise(resolve => {\n            nextResolve = () => resolve();\n        });\n        const currMtx = this.mtx;\n        this.mtx = nextMtx;\n        // Async behaviour:\n        return currMtx.then(function unlock() {\n            return nextResolve\n        });\n    };\n}\n\nexport const mutex = function method_mutex_generator(muxName) {\n    return function mutex_decorator(target, {kind}) {\n        if (kind == \"method\") {\n            return async function muxed_target(...args) {\n                const me = this;\n                if (! me[sym_mux]) me[sym_mux] = {};\n                if (! me[sym_mux][muxName]) me[sym_mux][muxName] = new Mutex();\n                const unlock = await me[sym_mux][muxName].lock(); // Await previous muxed call (if any)\n                let err, retv;\n                try {\n                    retv = await target.call(me, ...args);\n                } catch (error) {\n                    err = error;\n                };\n                unlock();\n                if (err) throw err;\n                return retv;\n            };\n\n        };\n    };\n};\n","// types/list.decorators/sortable.deco.js\n// ======================================\n\nimport {mutex} from \"../../decorators/mutex.deco.js\";\n\nexport const sortable = function list_sortable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class sortableTarget extends target {\n            render(...args) {//{{{\n                const retv = super.render(...args);\n                const me = this;\n\n                me.sortable = !! me.options.sortable;\n                me.itemTpl.setAttribute(\"draggable\", me.sortable);\n                me.children.forEach(c=>c.target.setAttribute(\"dragable\", me.sortable));\n                if (me.sortable) {\n                    let dragSource = null;\n                    let dragDest = null;\n                    me.target.addEventListener(\"dragstart\", e => {\n                        if (dragSource === null) {\n                            dragSource = e.target\n                            e.stopPropagation();\n                        } else {\n                            // Single dragging at a time.\n                            e.preventDefault();\n                        };\n                    });\n                    me.target.addEventListener(\"dragover\", e => e.preventDefault());\n                    me.target.addEventListener(\"drop\", e => {\n                        if (! dragSource) return; // Already dropped\n                        let target = e.target;\n                        while (\n                            target.parentElement\n                            && target.parentElement != dragSource.parentElement\n                        ) target = target.parentElement;\n                        dragDest = target;\n                    });\n                    me.target.addEventListener(\"dragend\", async () => {\n                        if (dragDest)  await me.move({\n                            from: me.getComponent(dragSource),\n                            to: me.getComponent(dragDest),\n                        });\n                        dragSource = null;\n                        dragDest = null;\n                    });\n                };\n\n                return retv;\n            };//}}}\n            @mutex(\"list_mutating\")\n            async move(options = {}) {//{{{\n                const me = this;\n                let {\n                    from,\n                    to,\n                } = options;\n\n                // // FIXME: Avoid nested sortables to interact.\n                // console.log({from, to}); // <--- See this!!!\n\n                //\n                // TODO: Convert to action!!!\n                //\n                if (\n                    to === null // Dropped outside\n                    || from === null // (Shouldn't happen)\n                ) return;\n                const fromi = Number(from?.name);\n                const toi = Number(to?.name);\n                if (fromi == toi) {\n                    return;\n                } else if (fromi < toi) {\n                    const newChunk = [\n                        ...me.children.slice(fromi + 1, toi + 1),\n                        me.children[fromi],\n                    ].map((c, i)=>{\n                        c.name = i+fromi;\n                        c.updateId();\n                        return c;\n                    });\n                    me.children.splice(fromi, toi - fromi + 1, ...newChunk);\n                } else if (fromi > toi) {\n                    const newChunk = [\n                        me.children[fromi],\n                        ...me.children.slice(toi, fromi),\n                    ].map((c, i)=>{\n                        c.name = i+toi;\n                        c.updateId();\n                        return c;\n                    });\n                    me.children.splice(toi, fromi - toi + 1, ...newChunk);\n                };\n                const inc = fromi < toi ? 1 : -1;\n                const moveMethod = inc > 0 ? \"after\" : \"before\";\n                to.target[moveMethod](from.target);\n            };//}}}\n        };\n    };\n};\n","// types/list.type.js\n// ==================\n\n// TODO:\n// =====\n//\n// ðŸ‘‰ Keep first item in place:\n//    -------------------------\n//     \n//    For lists allowing 0 items, make first element disabled and not visible\n//    instead of completely removing from DOM.\n//\n//    This would avoid lots of visual layout issues.\n//\n\n\nimport {SmarkField} from \"../lib/component.js\";\nimport {makeRoom} from \"../lib/helpers.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {sortable} from \"./list.decorators/sortable.deco.js\";\nimport {action} from \"./trigger.type.js\";\nimport {mutex} from \"../decorators/mutex.deco.js\";\n\n\n// Helpers:\n// --------\n\nfunction makeNonNavigable(target) {//{{{\n    if (\n        // Tabindex not explicitly defined:\n        target.getAttribute(\"tabindex\") === null\n    ) {\n        target.setAttribute(\"tabindex\", \"-1\");\n    };\n};//}}}\n\n\n// List component type:\n// --------------------\n\n@foldable\n@sortable\nexport class list extends SmarkField {\n    render () {//{{{\n        const me = this;\n        me.originalDisplayProp = me.target.style.display;\n\n        me.min_items = Math.max(0,\n            typeof me.options.min_items == \"number\" ? me.options.min_items\n            : 1\n        );\n        me.max_items = Math.max(me.min_items,\n            typeof me.options.max_items == \"number\" ? me.options.max_items\n            : Infinity\n        );\n        me.children = [];\n        const numChilds = me.target.children.length;\n        if (numChilds != 1) throw me.renderError(\n            'LIST_WRONG_NUM_CHILDREN'\n            , `List components must contain exactly 1 direct children, but ${numChilds} given`\n        );\n        me.itemTpl = me.target.children[0];\n        if (\n            me.itemTpl.querySelector(\"[id]\") !== null // Contains IDs\n        ) throw me.renderError(\n            'LIST_CONTAINS_ID'\n            , `List components are not allowed to contain elements with 'id' attribute`\n        );\n        const tplOptions = me.getNodeOptions(\n            me.itemTpl\n            , {\n                type: me.options.of, // Allow to specify items type from list declaration.\n            }\n        );\n        if (\n            me.options.of\n            && tplOptions.type != me.options.of\n        ) throw me.renderError(\n            'LIST_ITEM_TYPE_MISSMATCH'\n            , `List item type missmatch`\n        );\n\n        // onRendered tweaks:\n        me.root.onRendered(async ()=>{\n            for(let i=0; i<me.min_items; i++) await me.addItem();\n            if (me.min_items == 0) {\n                // Update \"count\" actions in case of not already updated by\n                // me.addItem:\n                me.getTriggers(\"count\").forEach(\n                    tgg=>tgg.target.innerText = String(me.children.length)\n                );\n            };\n            // Let screen readers know lists may change.\n            me.target.setAttribute(\"aria-live\", \"polite\");\n            me.target.setAttribute(\"aria-atomic\", \"true\");\n        });\n        me.itemTpl.remove();\n        return;\n    };//}}}\n    onTriggerRender({action, origin}) {//{{{\n        switch (action) {\n            case \"addItem\":\n            case \"removeItem\":\n                makeNonNavigable(origin.target);\n                break;\n        };\n    };//}}}\n    @mutex(\"list_mutating\")\n    @action\n    async export() {//{{{\n        const me = this;\n        const list = [];\n        const stripEmpties = ! me.inherittedOption(\"exportEmpties\", false);\n        for (const child of me.children) {\n            if (stripEmpties && await child.isEmpty()) continue;\n            list.push(await child.export())\n        };\n        return list;\n    };//}}}\n    @action\n    async import({data = []}) {//{{{\n        const me = this;\n        // Auto-update in case of scalar to array template upgrade:\n        if (! data instanceof Array) data = [data];\n        // Load data:\n        for (\n            let i = 0;\n            i < Math.min(data.length, me.max_items); // Limit to allowed items\n            i++\n        ) {\n            if (me.children.length <= i) await me.addItem(); // Make room on demand\n            await me.children[i].import({data: data[i]});\n        };\n        // Remove extra items if possible (over min_items):\n        for (\n            let i = Math.max(data.length, me.min_items);\n            i < me.children.length;\n        ) await me.removeItem();\n        // Report if data doesn't fit:\n        if (data.length > me.max_items) {\n            me.emit(\"error\", {\n                code: 'LIST_IMPORT_OVERFLOW',\n                message: `Trying to import array greater than list's max_items. Data beyond max_items ignored.`,\n                context: me,\n                data,\n                options: me.options,\n            });\n        };\n        // Clear items over imported data if min_items is greater:\n        for (\n            let i = data.length;\n            i < me.children.length; // (Due to min_items)\n            i++\n        ) me.children[i].empty();\n        return; // await me.export();\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    async addItem(options = {}) {//{{{\n        const me = this;\n        // Parameters checking and resolution:{{{\n        let {\n            action,\n            origin = null, // (Internal call)\n            context = me,  // (Internal call)\n            target,\n            position = \"after\",\n            autoscroll,   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n        } = options;\n        if (position != \"after\" && position != \"before\") throw me.renderError(\n            'LIST_WRONG_ADDITEM_POSITION'\n            , `Invalid value for addItem() position property: ${position}`\n        );\n        if (me.children.length >= me.max_items) {\n            me.emit(\"error\", {\n                code: 'LIST_MAX_ITEMS_REACHED',\n                message: `Cannot add items over max_items boundary`,\n                options,\n            });\n            return;\n        };\n        if (me.children.length && ! target) target = ( // Auto target:\n            position == \"before\" ?  me.children[0] // Insert at the beginning\n            : me.children[me.children.length - 1]  // Append at the end\n        );\n        //}}}\n        // DOM element creation:{{{\n        const newItemTarget = me.itemTpl.cloneNode(true);\n        //}}}\n        // addItem event emitting:{{{\n        const onRenderedCbks = [];\n            // Allow for handy callback instead of two separate event handlers\n        await me.emit(\"addItem\", {\n                action,\n                origin,\n                context,\n                target,  // <--- Effective target.\n                position,\n                newItemTarget,\n                options, // <- Original options (including target)\n                onRendered: cbk => onRenderedCbks.push(cbk),\n        });\n        //}}}\n        // Child component creation and insertion:{{{\n        let newItem;\n        if (! me.children.length) {\n            me.target.appendChild(newItemTarget);\n            newItem = await me.enhance(newItemTarget, {type: \"form\", name: 0});\n            await newItem.rendered;\n            me.children.push(newItem);\n            newItem.name = 0;\n            newItem.updateId();\n        } else {\n            me.children = (await Promise.all(\n                me.children.map(async (child, i)=>{\n                    if (! child.target.isSameNode(target.target)) return child;\n                    if (position == \"after\") {\n                        child.target.after(newItemTarget);\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        return [child, newItem]; // Right order, flatted later...\n                    } else {\n                        child.target.before(newItemTarget);\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        return [newItem, child]; // Right order, flatted later...\n                    };\n                })\n            ))\n                .flat()\n                .map((c,i)=>{\n                    c.name = i;\n                    c.updateId();\n                    return c;\n                })\n            ;\n        };\n        //}}}\n        // Autoscroll handling:{{{\n        if (autoscroll == \"elegant\" && !! newItem) {\n            makeRoom(newItem.target, - newItem.offsetHeight);\n        } else {\n            const moveTarget = (\n                ! newItem ? null\n                : autoscroll == \"self\" ? newItem\n                : autoscroll == \"parent\" ? newItem.parent\n                : null\n            );\n            if (moveTarget) moveTarget.moveTo();\n        };\n        //}}}\n        // Execute \"onRendered\" callbacks:{{{\n        onRenderedCbks.forEach(cbk=>cbk(newItem));\n        //}}}\n        me.getTriggers(\"count\").forEach(\n            tgg=>tgg.target.innerText = String(me.children.length)\n        );\n        newItem.focus();\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    async removeItem(options = {}) {//{{{\n        const me = this;\n        let {\n            action,\n            origin = null, // (Internal call)\n            context = me,  // (Internal call)\n            target,\n            autoscroll,   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n            keep_non_empty,\n            failback,\n        } = options;\n        if (! target) {\n            if (keep_non_empty) for (\n                const t of [...me.children]\n                .reverse() // Pick last first\n            ) if (await t.isEmpty()) {\n                target = t;\n                break;\n            };\n            if (! target) {\n                target = me.children[me.children.length - 1];\n                keep_non_empty = false;\n                // Allow non empty removal as last chance if no target\n                // specified.\n            };\n        };\n        const targets = (\n            target instanceof Array ? target\n            : [target]\n        );\n        for (const currentTarget of [...targets].reverse()) {\n            if (me.children.length <= me.min_items) {\n                switch (failback) {\n                    case \"none\":\n                        break;\n                    case \"clear\":\n                        await currentTarget.empty();\n                        return;\n                    case \"throw\":\n                    default:\n                        me.emit(\"error\", {\n                            code: 'LIST_MIN_ITEMS_REACHED',\n                            message: `Cannot remove items under min_items boundary`,\n                            options,\n                        });\n                        return;\n                };\n            };\n            if (keep_non_empty && ! await currentTarget.isEmpty()) continue;\n            let oldItem = null;\n            let newFocusPosition = null;\n            const newChildren = me.children\n                .filter((child, i, all)=>{\n                    if (child.target.isSameNode(currentTarget.target)) {\n                        if (autoscroll == \"elegant\") {\n                            makeRoom(child.target, child.target.offsetHeight);\n                        } else {\n                            const moveTarget = (\n                                autoscroll == \"self\" ? child\n                                : autoscroll == \"parent\" ? child.parent\n                                : null\n                            );\n                            if (moveTarget) moveTarget.moveTo();\n                        };\n\n                        oldItem = child;\n\n                        newFocusPosition = (\n                            (all.length -i > 1) ? newFocusPosition = i // More above\n                            : i == 0 ? null           // No items left\n                            : i - 1                   // Removing last item\n                        );\n\n                        return false;\n                    };\n                    return true;\n                })\n                .map((c,i)=>{\n                    c.name = i;\n                    c.updateId();\n                    return c;\n                })\n            ;\n            // removeItem event emitting:{{{\n            const onRemovedCbks = [];\n                // Allow for handy callback instead of two separate event handlers\n            await me.emit(\"removeItem\", {\n                action,\n                origin,\n                context,\n                target: currentTarget,  // <--- Effective target.\n                oldItem,                 // Child going to be removed.\n                oldItemTarget: oldItem.target, // Its target (analogous to addItem event).\n                options,\n                onRemoved: cbk => onRemovedCbks.push(cbk),\n            });\n            //}}}\n\n            oldItem.target.remove();\n            me.children = newChildren;\n\n            me.getTriggers(\"count\").forEach(\n                tgg=>tgg.target.innerText = String(me.children.length)\n            );\n\n            // Execute \"onRemoved\" callbacks:{{{\n            onRemovedCbks.forEach(cbk=>cbk());\n            //}}}\n\n            if (newFocusPosition !== null) {\n                me.children[newFocusPosition].focus();\n            };\n\n        };\n\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of me.children\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async empty() {//{{{\n        const me = this;\n        return await me.import({data: []});\n    };//}}}\n    @action\n    count() {//{{{\n        // Return number of children.\n        // But also it's sole existence allow reinjecting contents to it.\n        const me = this;\n        return me.children.length;\n    };//}}}\n};\n","// types/input.type.js\n// ===================\nimport {form} from \"./form.type.js\";\nimport {action} from \"./trigger.type.js\";\nexport class input extends form {\n    async render() {//{{{\n        const me = this;\n        me.isSingleton = ! (\n            me.target.tagName === \"INPUT\"\n            || me.target.tagName === \"SELECT\"\n            || me.target.tagName === \"TEXTAREA\"\n        );\n        me.isCheckbox = (\n            ! me.isSingleton\n            && String(me.target.type).toLowerCase() == \"checkbox\"\n        );\n        if (me.isSingleton) {\n            await super.render();\n            const numFields = Object.keys(me.children).length;\n            if (numFields != 1) throw me.renderError(\n                'NOT_A_SINGLETON'\n                , `Singleton forms are only allowed to contain exactly one`\n                + ` data field but ${numFields} found.`\n            );\n        }\n        me.targetField = (\n            me.isSingleton ? Object.values(me.children)[0].target\n            : me.target\n        );\n        // console.log(\"New input!!!!\", {\n        //     target: me.target,\n        //     parent: me.parent,\n        //     options: me.options,\n        //     inputField: me.inputField,\n        // });\n        return;\n    };//}}}\n    @action\n    async export() {//{{{\n        const me = this;\n        return (\n            me.isSingleton ? Object.values(await super.export())[0]\n            : me.isCheckbox ? !!me.target.checked\n            : me.target.value\n        );\n    };//}}}\n    @action\n    async import({data = \"\"}) {//{{{\n        const me = this;\n        if (me.isSingleton) {\n            return await super.import({data: Object.fromEntries(\n                [[Object.keys(me.children)[0], data]]\n            )});\n        } else if (me.isCheckbox) {\n            me.target.checked = !! data;\n        } else {\n            me.target.value = data;\n        };\n        // me.target.dispatchEvent(\n        //     new customEvent(\"change\", {})\n        // );\n        return me.target.value;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = (\n            me.isCheckbox ? \"\" // Do not consider checkboxes.\n            : await me.export()\n        );\n        return ! value.trim().length;\n            // Native input's value type is always a string.\n    };//}}}\n    @action\n    async empty() {//{{{\n        const me = this;\n        await me.import({data: \"\"});\n    };//}}}\n};\n","// types/number.type.js\n// ====================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nexport class number extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetField.tagName;\n        const targetType = me.targetField.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"number\").toLowerCase() != \"number\"\n        ) throw me.renderError(\n            'NOT_A_NUMBER_FIELD'\n            , `Number inputs require an INPUT tag of type \"number\".`\n        );\n        if (! targetType) me.targetField.type = \"number\"; // Autofill\n    };//}}}\n    @action\n    async export() {//{{{\n        const data = await super.export();\n        return (\n            data.length && ! isNaN(data) ? Number(data)\n            : null\n        );\n    };//}}}\n    @action\n    async import({data = null}) {//{{{\n        const typename = typeof data;\n        return await super.import({data:(\n            typename == \"number\" ? data\n            : typename == \"string\"\n                && data.length\n                && ! isNaN(data)\n                ? Number(data)\n            : null\n        )});\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n","// types/date.type.js\n// ==================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nconst re_timePart = /T.*/;\nfunction parseDateStr(str) {//{{{\n    // Accept \"YYYYMMDD\":\n    if (str.length == 8) return new Date([\n        str.substring(0, 4),\n        str.substring(4, 6),\n        str.substring(6, 8),\n    ].join(\"-\"));\n\n    // Accept \"YYYY-MM-DD\" (like date inputs)\n    // > new Date(\"2023-11-30\")\n    // 2023-11-30T00:00:00.000Z\n    // ...but don't accept if not zero-padded:\n    // > new Date(\"2023-11-3\")\n    // 2023-11-02T23:00:00.000Z\n    if (\n        str.length == 10\n        && str[4] == \"-\"\n        && str[7] == \"-\"\n    ) return new Date(str);\n\n    // Also don't accept other locale dependant formats:\n    // > new Date(\"11/30/2023\")\n    // 2023-11-29T23:00:00.000Z\n\n    return NaN;\n};//}}}\nfunction ISODate(value) {//{{{\n    return value.toISOString().replace(re_timePart, \"\");\n};//}}}\nexport class date extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetField.tagName;\n        const targetType = me.targetField.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"date\").toLowerCase() != \"date\"\n        ) throw me.renderError(\n            'NOT_A_DATE_FIELD'\n            , `Date inputs require an INPUT tag of type \"date\".`\n        );\n        if (! targetType) me.targetField.type = \"date\"; // Autofill\n    };//}}}\n    @action\n    async export() {//{{{\n        const data = await super.export();\n        if (! data.length) return null;\n        const value = parseDateStr(data);\n        return (\n            isNaN(value) ? null\n            : ISODate(value)\n        );\n    };//}}}\n    @action\n    async import({data = null}) {//{{{\n        const value = (\n            data instanceof Date ? data // Accept Date instance\n            : typeof data == \"number\" ? new Date(data) // Accept epoch\n            : ! data || (typeof data != \"string\") ? NaN // Reject nullish\n            : parseDateStr(data) // Handle strings\n        );\n        return await super.import({data:(\n            isNaN(value) ? null\n            : ISODate(value)\n        )});\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n","// SmarkForm.js\n// ============\n\nimport {createType} from \"./lib/component.js\";\nimport {hotKeys_handler} from \"./lib/hotkeys.js\";\n\n// Import core component types and event handlers:\nimport {trigger, onTriggerClick} from \"./types/trigger.type.js\";\nimport {label} from \"./types/label.type.js\";\nimport {form} from \"./types/form.type.js\";\nimport {list} from \"./types/list.type.js\";\nimport {input} from \"./types/input.type.js\";\nimport {number} from \"./types/number.type.js\";\nimport {date} from \"./types/date.type.js\";\n\n\n// Load core component types:\nfor (const [name, controller] of Object.entries({\n    trigger,\n    label,\n    form,\n    list,\n    input,\n    number,\n    date,\n})) createType(name,controller);\n\n\nclass SmarkForm extends form {\n    constructor(\n        target\n        , {\n            customActions = {},\n            ...formOptions\n        } = {}\n    ) {\n        const options = {\n            ...formOptions,\n            name: \"\",\n            type: \"form\",\n        };\n        super(\n            target\n            , options\n            , null // (Root has no parent)\n        );\n        const me = this;\n        me.setNodeOptions(me.target, options);\n        me.actions = {\n            ...me.actions,\n            ...Object.fromEntries(\n                Object.entries(customActions)\n                    .map(([name, ctrl])=>[name, ctrl.bind(me)])\n            ),\n        };\n        me.target.addEventListener(\n            \"click\"\n            , onTriggerClick.bind(me)\n            , true\n        );\n        new hotKeys_handler(me);\n    };\n    async render() {\n        const me = this;\n        me.target.setAttribute(\"aria-busy\", \"true\");\n        await super.render();\n        me.target.setAttribute(\"aria-busy\", \"false\");\n    };\n};\n\nSmarkForm.createType = createType;\n\nexport default SmarkForm;\n\n"],"names":["sym_local_events","Symbol","sym_all_events","re_actionEvHandler","re_localEvHandler","re_allEvHandler","registerEvHandler","evList","evType","evHandler","me","this","has","set","get","push","bind","events","events_decorator","target","_ref","kind","eventEnebledTarget","constructor","optionsSrc","options","onOptionCallbacks","key","value","Object","entries","match","substring","_len","arguments","length","args","Array","_key","super","ImRoot","is","root","Map","onLocal","onAll","on","evt","handler","listenLevel","emit","evData","handlers","defaultPrevented","propagationStopped","preventDefault","stopPropagation","legacy","disEnhance","tagName","toLowerCase","addEventListener","event","componentTypes","sym_smart","re_valid_typename_chars","re_has_wildcards","wild2regex","wname","RegExp","replace","errors","renderError","Error","code","message","path","stack","split","slice","join","inferType","node","parentComponent","type","String","getAttribute","_SmarkComponent","SmarkComponent","static","_initClass","_applyDecs","c","property_name","undefined","parent","validName","nameGenerator","counter","names","n0","trim","actions","selector","types","setNodeOptions","parents","iterator","current","autoId","inherittedOption","setRendered","genId","p","onRenderedTasks","rendered","Promise","resolve","children","render","task","onRendered","cbk","getNodeOptions","defaultOptions","dataset","opt","JSON","parse","err","action","stringify","enhance","ctrl","getComponent","parentElement","closest","getPath","map","name","reverse","find","base","parts","filter","x","firstWildcardPos","findIndex","re_pattern","pivotPath","restPath","pivot","pivotChilds","child","_ref2","flat","Infinity","reduce","optName","defaultValue","moveTo","id","document","location","hash","window","history","pushState","pathname","getTriggers","actionNames","myCurrentActions","actionKeys","Set","returnAll","tgg","querySelectorAll","getTriggerArgs","context","updateId","newId","values","focus","fname","targetField","SmarkField","_isField","createType","controller","prototype","hotKeys_handler","form","revealed","onKeydown","onKeyup","onFocusout","onFocusin","ev","reveal","ctrlKey","targettedTrigger","t","hotkey","click","removeAttribute","component","isSingleton","flatMap","setAttribute","beforeEvent","afterEvent","action_decorator","targetMtd","addInitializer","registerAction","trigger","triggerArgs","onTriggerRender","disable","disabled","enable","actionSpec","contextPath","targetPath","otherOptions","actionName","targetType","isSameNode","origin","async","onTriggerClick","triggerComponent","mtd","data","label","labelArgs","getLabelArgs","Math","random","toString","candidates","found","childName","targetComponent","getRoots","isTop","parentNode","n","e","makeRoom","element","pixels","direction","scrollHeight","clientHeight","maxScroll","scrollTop","foldable","foldable_decorator","_initProto","foldableTarget","retv","fold","operation","folded","wasFolded","style","display","isFolded","originalDisplayProp","forEach","foldedClass","unfoldedClass","classList","_form","newItem","export","fromEntries","all","import","dataConstructor","_ref3","await","isEmpty","empty","sym_mux","Mutex","mtx","lock","nextResolve","nextMtx","currMtx","then","unlock","mutex","method_mutex_generator","muxName","mutex_decorator","muxed_target","call","error","sortable","list_sortable_decorator","_moveDecs","sortableTarget","itemTpl","dragSource","dragDest","move","from","to","fromi","Number","toi","newChunk","i","splice","inc","moveMethod","_list","makeNonNavigable","list","_exportDecs","_addItemDecs","_removeItemDecs","min_items","max","max_items","numChilds","querySelector","tplOptions","of","addItem","innerText","remove","stripEmpties","min","removeItem","position","autoscroll","newItemTarget","cloneNode","onRenderedCbks","after","before","appendChild","offsetHeight","moveTarget","keep_non_empty","failback","targets","currentTarget","oldItem","newFocusPosition","newChildren","onRemovedCbks","oldItemTarget","onRemoved","count","input","isCheckbox","numFields","keys","checked","number","targetTag","isNaN","typename","re_timePart","parseDateStr","str","Date","NaN","ISODate","toISOString","date","SmarkForm","customActions","formOptions"],"mappings":"qrJAGA,CAAA,MAAMA,EAAmBC,OAAO,UAC1BC,EAAiBD,OAAO,aACxBE,EAAqB,6BACrBC,EAAoB,YACpBC,EAAkB,UAExB,SAASC,EAAkBC,EAAQC,EAAQC,GACvC,MAAMC,EAAKC,KAGX,OAFMJ,EAAOK,IAAIJ,IAASD,EAAOM,IAAIL,EAAQ,IAC7CD,EAAOO,IAAIN,GAAQO,KAAKN,EAAUO,KAAKN,IAChCA,CACX,CAEO,MAAMO,EAAS,SAASC,EAAiBC,EAAMC,GAAU,IAARC,KAACA,GAAKD,EAC1D,GAAY,SAARC,EACA,OAAO,MAAMC,UAA2BH,EACpCI,WAAAA,CAAYJ,EAAQK,GAKhB,MAAMC,EAAU,CAAA,EACVC,EAAoB,GAC1B,IACI,MAAOC,EAAKC,KACTC,OAAOC,QAAQN,GAChBG,EAAII,MAAM5B,GACZuB,EAAkBX,KAAK,CAACY,EAAIK,UAAU,GAAIJ,EAAO,YAC1CD,EAAII,MAAM3B,GACjBsB,EAAkBX,KAAK,CAACY,EAAIK,UAAU,GAAIJ,EAAO,YAC1CD,EAAII,MAAM1B,GACjBqB,EAAkBX,KAAK,CAACY,EAAIK,UAAU,GAAIJ,EAAO,UAGjDH,EAAQE,GAAOC,EAGnB,IAAAK,IAAAA,EAAAC,UAAAC,OArB+BC,MAAIC,MAAAJ,EAAAA,EAAAA,OAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,EAAAJ,GAAAA,UAAAI,GAsBnCC,MAAMpB,EAAQM,KAAYW,GAG1B,MAAM1B,EAAKC,KACL6B,EAASX,OAAOY,GAAG/B,EAAIA,EAAGgC,MAChChC,EAAGV,GAAoB,IAAI2C,IACvBH,IAAQ9B,EAAGgC,KAAKxC,GAAkB,IAAIyC,KAC1CjC,EAAGkC,QAAUtC,EAAkBU,KAAKN,EAAIA,EAAGV,IAC3CU,EAAGmC,MAAQvC,EAAkBU,KAAKN,EAAGgC,KAAMhC,EAAGgC,KAAKxC,IACnDQ,EAAGoC,GAAKpC,EAAGkC,QAGX,IACI,MAAOG,EAAKC,EAASC,KAClBvB,EACLhB,EAAGuC,GAAaF,EAAKC,EAE3B,CACA,UAAME,CAAK1C,EAAQ2C,GACf,MAAMzC,EAAKC,KACLyC,EAAW,IACT1C,EAAGV,GAAkBc,IAAIN,IAAW,MACpCE,EAAGgC,KAAKxC,GAAgBY,IAAIN,IAAW,IAE/C,IAAI6C,GAAmB,EACvB,GAAID,EAASjB,OAAQ,CACjB,IAAImB,GAAqB,EACzBH,EAAOI,eAAiB,IAAMF,GAAmB,EACjDF,EAAOK,gBAAkB,IAAMF,GAAqB,EACpD,IAAK,MAAMN,KAAWI,EAAU,CAC5B,GAAIE,EAAoB,YAClBN,EAAQG,EAClB,CACJ,CACA,OAASE,CACb,EAGZ,EC5EA,IAAeI,EAAA,CACXC,UAAAA,CAAWhD,GAGHA,EAAGS,OAAOwC,QAAQC,eAClBlD,EAAGS,OAAO0C,iBAAiB,UAAU,SAASC,GAG1CA,EAAMP,gBAKV,GAGR,SCjBJ,MAAMQ,EAAiB,CAAA,EAKjBC,EAAY/D,OAAO,mBACnBgE,EAA0B,gBAC1BC,EAAmB,SACnBC,EAAaC,GAAS,IAAIC,OAC5B,IACED,EACGE,QAAQ,OAAQ,MAChBA,QAAQ,MAAO,KAClB,KAGAC,EACW,MAAMC,UAAoBC,MACnClD,WAAAA,CAAYmD,EAAMC,EAASC,GACvBrC,MAAM,eAAeqC,OAAUD,KAC/BhE,KAAK+D,KAAOA,EACZ/D,KAAKiE,KAAOA,EACZjE,KAAKkE,MAAQlE,KAAKkE,MACbC,MAAM,MACNC,MAAM,GACNC,KAAK,KAEd,GAIR,SAASC,EAAUC,EAAMC,GACrB,OAAQD,EAAKvB,QAAQC,eACjB,IAAK,KACL,IAAK,KACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACD,MAAO,OACX,IAAK,QACD,MAAMwB,EAAOC,OAAOH,EAAKI,aAAa,SAAS,IAAI1B,cACnD,OAAOwB,GACH,IAAK,SACL,IAAK,OACD,OAAOA,EAEnB,IAAK,WACL,IAAK,SACD,MAAO,QACX,IAAK,QACD,MAAO,QACX,QAGI,MAAO,OAEnB,CAAE,IAAAG,EAEF,MAAAC,EAC4BC,UAAAF,EAAAG,GAAAC,EAAAhF,KAAA,GAAA,CAD3BM,IAAM2E,EAEHrE,WAAAA,CACIJ,GAMF,IALI0E,cACEA,EAAgB,WACbpE,GACNS,UAAAC,OAAAD,QAAA4D,IAAA5D,UAAA4D,GAAA5D,UAAG,GAAA,GACF6D,EAAM7D,UAAAC,OAAAD,EAAAA,kBAAA4D,EAER,MAAMpF,EAAKC,KA0BX,GAxBAD,EAAGsF,UAAa,SAASC,IACrB,IAAIC,EAAU,EACd,OAAO,WAAkB,IAAA,IAAAjE,EAAAC,UAAAC,OAANgE,EAAK9D,IAAAA,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAL6D,EAAK7D,GAAAJ,UAAAI,GACpB,IACI,IAAI8D,KAAMD,EACZ,GACe,iBAANC,IAEPA,EAAKA,EAAGC,OACJD,EAAGjE,QAAQ,OAAOiE,EAE1B,MAAO,aAAaF,GAXZ,GAehBxF,EAAG4F,QAAU,GACb5F,EAAGmF,cAAgBA,EACnBnF,EAAG6F,SAAW,SAAS7F,EAAGmF,iBAC1BnF,EAAG8F,MAAQzC,EACXrD,EAAGS,OAASA,EACZT,EAAGe,QAAUA,EACbf,EAAG+F,eAAe/F,EAAGS,OAAQT,EAAGe,SAEhCf,EAAGqF,OAASA,GACNrF,EAAGqF,kBAAkBP,EAAgB,MAAM9E,EAAG8D,YAChD,iBACE,4DAEN9D,EAAGgC,KACe,OAAdhC,EAAGqF,OAAkBrF,EACnBA,EAAGqF,OAAOrD,KAIhBhC,EAAGgG,QAAU,GACbhG,EAAGgG,QAAQzG,OAAO0G,UAAY,YAC1B,IAAIC,EAAUlG,EACd,KAAOkG,SACGA,EACNA,EAAUA,EAAQb,QAK1B,MAAMc,EAASnG,EAAGoG,iBAAiB,UAAU,GAgB7C,IAAIC,EAfJrG,EAAGsG,OACY,IAAXH,KAEa,IAAXA,EAAkBI,GAAKA,EAAE3C,QAAQ,MAAO,KAEvB,iBAAVuC,EAAqBI,GAAKJ,EAAOI,EAAE3C,QAAQ,MAAO,KAExC,mBAAVuC,GAAuBA,GAMpCnG,EAAGwG,gBAAkB,GAGrBxG,EAAGyG,SAAW,IAAIC,SAAQC,GAAWN,EAAcM,IAEnD3G,EAAG4G,SAAW,GACd5G,EAAGS,OAAO6C,GAAatD,EAEvB,iBACUA,EAAG6G,SACT,IACI,MAAMC,KAAQ9G,EAAGwG,sBACbM,IACR9G,EAAGwG,gBAAkB,KACrBH,GAAY,EACf,EAPD,GAQIrG,EAAGe,QAAQgG,YAAY/G,EAAG+G,WAAW/G,EAAGe,QAAQgG,WAExD,CACAA,UAAAA,CAAWC,GACP,MAAMhH,EAAKC,KACPD,EAAGwG,gBACHxG,EAAGwG,gBAAgBnG,KAAK2G,EAAI1G,KAAKN,IAEjCgH,EAAI1G,KAAKN,EAATgH,EAER,CACAC,cAAAA,CAAezC,EAAM0C,GACjB,MAAMlH,EAAKC,KACLa,GACF0D,EAAK2C,QAAQnH,EAAGmF,gBAAkB,IACpCQ,QAAU,KACN5E,EAAU,IACTmG,KACA,MACC,IACI,MAAME,EAAMC,KAAKC,MAAMxG,GACvB,GAAkB,iBAAPsG,EAAiB,MAAM,IAAIrD,MAAM,aAC5C,OAAOqD,CACV,CAAC,MAAOG,GACL,OACIzG,EAAWO,MAAMkC,GAA2B,CAACmB,KAAM5D,GACjD,EAEV,CACH,EAXE,IAeP,OAFMC,EAAQyG,QAAYzG,EAAQ2D,OAAM3D,EAAQ2D,KAAOH,EAAUC,IACjExE,EAAG+F,eAAevB,EAAMzD,GACjBA,CACX,CACAgF,cAAAA,CAAevB,EAAMzD,GACjB,MAAMf,EAAKC,KACXuE,EAAK2C,QAAQnH,EAAGmF,eAAiBkC,KAAKI,UAAU1G,EACpD,CACA,aAAM2G,CAAQlD,EAAM0C,GAChB,MAAMlH,EAAKC,KAGX,IAAIc,EAAUf,EAAGiH,eAAezC,EAAM0C,GAQtC,GAJAnE,EAAOC,WAAWhD,GAIde,EAAQyG,QAER,GADMzG,EAAQ2D,OAAM3D,EAAQ2D,KAAO,WACf,WAAhB3D,EAAQ2D,KAAmB,MAAM1E,EAAG8D,YACpC,wBACE,mEAAmE/C,EAAQ2D,8BAE9E,GAA2B,iBAAhB3D,EAAQ2D,KACtB,MAAM1E,EAAG8D,YACL,mBACE,yEAMV,MAAM6D,EAAO3H,EAAG8F,MAAM/E,EAAQ2D,MAC9B,IAAMiD,EAAM,MAAM3H,EAAG8D,YACjB,eACE,iDAAiD/C,EAAQ2D,QAE/D,OAAO,IAAIiD,EACPnD,EACEzD,EACAf,EAIV,CACA4H,YAAAA,CAAanH,GACT,MAAMT,EAAKC,KACX,OACIQ,EAAO6C,IACJ7C,EAAOoH,eAAeC,QAAQ9H,EAAG6F,UAAUvC,IAC3C,IAEX,CACAyE,OAAAA,GACI,MAAM/H,EAAKC,UACX,MACI,IAFOA,KAEA+F,SAASgC,KAAIzB,GAAGA,EAAE0B,OACxBC,UACA5D,KAAK,MACH,GAEX,CACA6D,IAAAA,GAAc,IAATjE,EAAI1C,UAAAC,OAAA,QAAA2D,IAAA5D,UAAA,GAAAA,UAAA,GAAC,GACF4G,EAAKnI,KACT,GAAe,KAAXiE,EAAK,GAAW,KAAOkE,EAAK/C,QAAQ+C,EAAOA,EAAK/C,OACpD,MAAMgD,EAAQnE,EACTE,MAAM,KACNkE,QAAOC,GAAGA,IAKTC,EAAmBH,EAAMI,WAAUlC,GAAGA,EAAElF,MAAMmC,KACpD,GAAIgF,GAAoB,EAAG,CACvB,MAAME,EAAajF,EAAW4E,EAAMG,IAC9BG,EAAYN,EAAMhE,MAAM,EAAGmE,GAAkBlE,KAAK,KAClDsE,EAAWP,EAAMhE,MAAMmE,EAAmB,GAAGlE,KAAK,KAClDuE,EAAQT,EAAKD,KAAKQ,GAClBG,EAAc3H,UACpB,OADoBA,OAAOC,QAAQyH,EAAMjC,UAEpC0B,QAAO5H,IAAA,IAAEuH,EAAKc,GAAMrI,EAAA,OAAGqI,GAASd,EAAK5G,MAAMqH,EAAW,IACtDV,KAAIgB,IAAA,IAAGD,CAAAA,GAAMC,EAAA,OAAGD,EAAMZ,KAAKS,EAAS,IACpCK,KAAKC,IAEd,CAIA,OAAOb,EAAMc,QACR,CAACjD,EAAS+B,SACK7C,IAAZc,EAAwB,KACd,MAAR+B,EAAe/B,EAAQb,OACvBa,EAAQU,SAASqB,IAErBG,EAGV,CACAhC,gBAAAA,CAAiBgD,EAASC,GACtB,MAAMrJ,EAAKC,KACX,IACI,MAAMsG,KAAKvG,EAAGgG,QAChB,QACyBZ,IAAvBmB,EAAExF,QAAQqI,GACZ,OAAO7C,EAAExF,QAAQqI,GACnB,OAAOC,CACX,CACAC,MAAAA,GACI,MAAMtJ,EAAKC,KACLD,EAAGS,OAAO8I,KAAIvJ,EAAGS,OAAO8I,GAAKvJ,EAAG+H,WACtCyB,SAASC,SAASC,KAAO1J,EAAGS,OAAO8I,GAEnCI,OAAOC,QAAQC,UAAU,CAAE,OAAEzE,EAAUuE,OAAOF,SAASK,SAG3D,CACAC,WAAAA,GAA8B,IAAlBC,EACR,MAAMhK,EAAKC,KACLgK,EAAmB,GACnBC,EAAa,IAAIC,IAAI,CAHR3I,UAAAC,OAAA,QAAA2D,IAAA5D,UAAA,GAAAA,UAAA,GAAG,IAIjByH,OACAjB,IAAIrD,QACJ2D,QAAOC,GAAGA,KAET6B,EAAYF,EAAWhK,IAAI,KACjC,IACI,MAAMmK,IACH,IAAIrK,EAAGgC,KAAKvB,OAAO6J,iBAAiBtK,EAAG6F,WACrCmC,KAAIvH,GAAQA,EAAO6C,KACnBgF,QAAOC,GAAGA,IACjB,CACE,MAAMxH,EAAUsJ,EAAIE,iBACdxJ,IACAI,OAAOY,GAAGhB,EAAQyJ,QAASxK,KAE7BoK,GACGF,EAAWhK,IAAIa,EAAQyG,UAC5ByC,EAAiB5J,KAAKgK,GAC5B,CACA,OAAOJ,CACX,CACAQ,QAAAA,GACI,MAAMzK,EAAKC,KACX,IAAiB,IAAbD,EAAGsG,MAAiB,OACxB,MAAMoE,EAAQ1K,EAAGsG,MAAMtG,EAAG+H,WAC1B,GAAI/H,EAAGS,OAAO8I,IAAMmB,EAAO,CACvB1K,EAAGS,OAAO8I,GAAKmB,EACf,IACI,MAAM3B,KACH5H,OAAOwJ,OAAO3K,EAAG4G,UACtBmC,EAAM0B,UACZ,CACA,OAAOzK,EAAGS,OAAO8I,EACrB,CACAqB,KAAAA,GACI,MAAM5K,EAAKC,KACX,IAAK,MAAM4K,KAAS7K,EAAG4G,SACnB,OAAO5G,EAAG4G,SAASiE,GAAOD,QAE9B5K,EAAG8K,YAAYF,OACnB,CACAL,cAAAA,GAAkB,CAElBzG,WAAAA,CAAYE,EAAMC,GACd,MAAMjE,EAAKC,UACX,OAAO,IAAI4D,EAAmBG,EAAMC,EADzBhE,KACqC8H,UACpD,CAAChD,SAAAC,IAGE,MAAM+F,UAAmBjG,EAC5BjE,WAAAA,GACIgB,SAAML,WACNvB,KAAK+K,UAAW,CACpB,EAGG,SAASC,EAAWhD,EAAMiD,GAC7B,QAA6B9F,IAAzB/B,EAAe4E,GAAqB,MAAM,IAAIlE,MAC9C,wCAAwCkE,KAE5C,KAAOiD,EAAWC,qBAAqBrG,GAAiB,MAAM,IAAIf,MAC9D,0CAA0CkE,KAE9C5E,EAAe4E,GAAQiD,CAC3B,CC1WO,MAAME,EACTvK,WAAAA,CAAYwK,GACR,MAAMrL,EAAKC,KACXD,EAAGqL,KAAOA,EACVrL,EAAGsL,SAAW,KACdtL,EAAGqL,KAAK5K,OAAO0C,iBACX,UACEnD,EAAGuL,UAAUjL,KAAKN,IAClB,GAENA,EAAGqL,KAAK5K,OAAO0C,iBACX,QACEnD,EAAGwL,QAAQlL,KAAKN,IAChB,GAENA,EAAGqL,KAAK5K,OAAO0C,iBACX,WACEnD,EAAGyL,WAAWnL,KAAKN,IACnB,GAENA,EAAGqL,KAAK5K,OAAO0C,iBACX,UACEnD,EAAG0L,UAAUpL,KAAKN,IAClB,EAEV,CACAuL,SAAAA,CAAUI,GACN,MAAM3L,EAAKC,KACX,GAAc,WAAV0L,EAAG1K,IACHjB,EAAG4L,OAAOD,EAAGlL,aACV,GAAIkL,EAAGE,QAAS,CACnB,MAAMC,EAAmB9L,EAAGsL,SAASnD,MACjC4D,GAAGA,EAAEhL,QAAQiL,QAAUL,EAAG1K,MAE1B6K,IACAH,EAAG9I,iBACH8I,EAAG7I,kBACHgJ,EAAiBrL,OAAOwL,QAEhC,CACJ,CACAT,OAAAA,CAAQG,GACJ,MAAM3L,EAAKC,KACG,WAAV0L,EAAG1K,KACHjB,EAAG4L,QAAO,EAElB,CACAH,UAAAA,CAAWE,GACP,MAAM3L,EAAKC,KACS,OAAhBD,EAAGsL,UACHtL,EAAG4L,QAEX,CACAF,SAAAA,CAAUC,GACN,MAAM3L,EAAKC,KACS,OAAhBD,EAAGsL,UACHtL,EAAG4L,OAAOD,EAAGlL,OAErB,CACAmL,MAAAA,CAAOnL,GACH,MAAMT,EAAKC,KAGX,GAAoB,OAAhBD,EAAGsL,SAAmB,CACtB,IAAK,MAAMS,KAAK/L,EAAGsL,SACfS,EAAEtL,OAAOyL,gBAAgB,eAE7BlM,EAAGsL,SAAS7J,OAAS,CACzB,CAMA,IAJe,IAAXhB,IACAT,EAAGsL,SAAW,MAGd7K,EAAQ,CAER,MAAM0L,EAAYnM,EAAGqL,KAAKzD,aAAanH,GAEjC+J,EACF2B,EAAU9G,OAAO+G,YAAcD,EAAU9G,OACvC8G,EAGNnM,EAAGsL,SAAW,CAACa,KAAcA,EAAUnG,SAClCqG,SAAQ9F,GAAGA,EAAEwD,YAAY,OACzBzB,QACGyD,GAAG5K,OAAOY,GAAGgK,EAAExB,kBAAkB9J,QAAQA,OAAQ+J,EAAQ/J,UAIjE,IAAK,MAAMsL,KAAK/L,EAAGsL,SAAU,CACzB,MAAMU,OAACA,GAAUD,EAAEhL,QACfiL,GAAQD,EAAEtL,OAAO6L,aAAa,cAAeN,EACrD,CAEJ,CAEJ,EChGJ,MAAMO,EAAchN,OAAO,mBACrBiN,EAAajN,OAAO,kBAEbiI,EAAS,SAASiF,EAAiBC,EAAShM,GAAgC,IAA9BC,KAACA,EAAIsH,KAAEA,EAAI0E,eAAEA,GAAejM,EACvE,UAARC,GAAkBgM,GAAe,SAASC,IAC1C3M,KAAK2F,QAAQqC,GAAQyE,EAAUpM,KAAKL,MACpCA,KAAK2F,QAAQqC,GAAMsE,GAAe,gBAAgBtE,IAClDhI,KAAK2F,QAAQqC,GAAMuE,GAAc,eAAevE,GACpD,GACJ,EAGO,MAAM4E,UAAgB/H,EACzBjE,WAAAA,CAAY2D,EAAMzD,UACPA,EAAQkH,KAAM,IAAA1G,IAAAA,EAAAC,UAAAC,OADKC,MAAIC,MAAAJ,EAAAA,EAAAA,OAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,EAAAJ,GAAAA,UAAAI,GAE9B,OAAOC,MAAM2C,EAAMzD,KAAYW,EACnC,CACAmF,MAAAA,GACI,MAAM7G,EAAKC,KACXD,EAAGqF,OAAO0B,YAAW,KACjB,MAAM+F,EAAc9M,EAAGuK,iBAE4B,mBAAxCuC,EAAYtC,SAASuC,iBAC9BD,EAAYtC,QAAQuC,gBAAgBD,EAAY,GAE1D,CACAE,OAAAA,GACI,MAAMhN,EAAKC,eACRQ,OAAOwM,UAAW,CACzB,CACAC,MAAAA,GACI,MAAMlN,EAAKC,eACRQ,OAAOwM,UAAW,CACzB,CACA1C,cAAAA,GACI,MAAMvK,EAAKC,KACL+F,EAAU,IAAIhG,EAAGgG,UAGnBwB,OAAQ2F,EACR3C,QAAS4C,EACT3M,OAAQ4M,KACLC,GACHtN,EAAGe,QACP,IAAMoM,EAAY,OAIlB,IAAKI,EAAYC,GAAcL,EAAW/I,MAAM,KAAK8D,UAErD,MAAMsC,EACF4C,EAAcpN,EAAGqF,OAAO8C,KAAKiF,GAC3BpH,EAAQmC,MAAK5B,KACPiH,GAAcjH,EAAExF,QAAQ2D,MAAQ8I,IACA,mBAAzBjH,EAAEX,QAAQ2H,KAKvB9M,EACF4M,EAAa7C,EAAQrC,KAAKkF,GACxBD,EAAc,KACdpH,EAAQmC,MAAK5B,GAAGA,EAAElB,QAAQ5E,OAAOgN,WAAWjD,GAAS/J,UAG3D,MAAO,CACH+G,OAAQ+F,EACRG,OAAQ1N,EACRwK,UACA/J,YACG6M,EAGX,EAGGK,eAAeC,EAAejC,GACjC,MAAM3L,EAAKC,KACL4N,EAAmB7N,UACnBe,EADmBf,EAAG4H,aAAa+D,EAAGlL,QACX8J,iBACjC,IAAMxJ,EAAS,OACf,MAAMyJ,QAACA,EAAOhD,OAAEA,GAAUzG,EACpB+M,EAAMtD,GAAS5E,QAAQ4B,GAC7B,GACkB,mBAAPsG,EACT,MAAM9N,EAAG8D,YACP,iBACE,kBAAkB0D,KACjBgD,EAAU,QAAQA,EAAQzJ,QAAQ2D,OAAS,KAElD,SAAU1E,EAAGwC,KAAKsL,EAAIvB,GAAcxL,GAAU,CAC1C,MAAMgN,QAAaD,EAAI/M,GACvBf,EAAGwC,KAAKsL,EAAItB,GAAa,IAAIzL,EAASgN,QAC1C,CACJ,CC5EO,MAAMC,UAAclJ,EACvBjE,WAAAA,CAAY2D,EAAMzD,UACPA,EAAQkH,KAAM,IAAA1G,IAAAA,EAAAC,UAAAC,OADKC,MAAIC,MAAAJ,EAAAA,EAAAA,OAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,EAAAJ,GAAAA,UAAAI,GAE9B,OAAOC,MAAM2C,EAAMzD,KAAYW,EACnC,CACAmF,MAAAA,GACI,MAAM7G,EAAKC,KACXD,EAAGqF,OAAO0B,YAAW,KACjB,MAAMkH,EAAYjO,EAAGkO,gBACfpD,YAACA,GAAemD,EAAUxN,QAAU,GACtCqK,IACMA,EAAYvB,KACduB,EAAYvB,GAAK4E,KAAKC,SAASC,SAAS,IAAI/M,UAAU,IAE1DtB,EAAGS,OAAO6L,aAAa,MAAOxB,EAAYvB,IAC9C,GAER,CACA2E,YAAAA,GACI,MAAMlO,EAAKC,KAEX,IAAIuK,EAAS/J,EADOT,EAAGgG,QAGvB,MAEIwE,QAAS4C,EACT3M,OAAQ4M,KACLC,GACHtN,EAAGe,QAEP,GAAMqM,GAAiBC,EAuBnB7C,EACI4C,EAAcpN,EAAGqF,OAAO8C,KAAKiF,GAC3BpN,EAAGqF,OAET5E,EACI4M,EAAa7C,EAAQrC,KAAKkF,GACxB7C,MA7ByB,CAE/BA,EAAUxK,EAAGqF,OACb,MAAMiJ,EAAa9D,EAAQ/J,OAAO6J,iBAAiBtK,EAAG6F,UACtD,IAAI0I,GAAQ,EACZ,IAAK,MAAMC,KAAaF,EACpB,GAAIC,EAAO,CACP,IAAIE,EAAkBzO,EAAG4H,aAAa0G,EAAWE,IACjD,GAAIC,GAAiBzD,SAAU,CAK3BvK,EAASgO,EACT,KACJ,CACJ,MACItN,OAAOY,GAAGuM,EAAWE,GAAYxO,EAAGS,UAEpC8N,GAAQ,EAGpB,CAWA,MAAO,CACHb,OAAQ1N,EACRwK,UACA/J,YACG6M,EAGX,EC3FG,SAASoB,EAASjO,EAAQoF,GAC7B,MAAMR,EAAS5E,UACTkO,EACS,OAFAlO,EAAOmO,WAEAC,GAAW,OAANA,EACrBA,GAAQ,OAAJA,GAAWA,EAAEpB,WAAWhN,GAElC,MAAO,IACAA,EAAO6J,iBAAiBzE,IAC7ByC,QACEwG,GAAGH,EAAMG,EAAEF,WAAW9G,QAAQjC,KAEtC,CAEO,SAASkJ,EAASC,EAASC,GAC9B,IAAI5J,EAAS2J,EAAQJ,WACrB,MAAMM,EACFD,GAAU,EAAI,GACX,EAEP,KAAO5J,GAAQ,CAEX,GAAIA,EAAO8J,aAAe9J,EAAO+J,aAAeF,EAAW,CAEvD,IAAIG,EAAYhK,EAAO8J,aAAe9J,EAAO+J,aAAeF,EAG5D,GAAID,GAAUI,EAAYH,EAEtB,YADA7J,EAAOiK,WAAaL,GAKtB5J,EAAOiK,UAAYD,EACnBJ,GAAUI,CAEhB,CACAhK,EAASA,EAAOuJ,UACpB,CACJ,CCpCO,MAAMW,EAAW,SAASC,EAAmB/O,EAAMC,GAAU,IAARC,KAACA,GAAKD,EAC9D,GAAY,SAARC,EAAiB,CAAA,IAAA8O,EACjB,OAAO,MAAMC,UAAuBjP,EAAOsE,UAAA0K,GAAAxK,EAYtCuC,KAAAA,CAAAA,CAAAA,iBAAMsH,EAAAjO,WAAAA,GAAAgB,SAAAL,WAAAiO,EAAAxP,KAAA,CAXP4G,MAAAA,GACI,MAAM8I,EAAO9N,MAAMgF,UAAOrF,WACpBxB,EAAKC,KAOX,OANAD,EAAGgC,KAAK+E,YAAW,KACf/G,EAAG4P,KAAK,CAACC,UACF7P,EAAGe,QAAQ+O,OAAS,OACrB,UACH,IAEAH,CACX,CAEAC,IAAAA,GAEQ,IAFHC,UACDA,EAAY,UACfrO,UAAAC,OAAAD,QAAA4D,IAAA5D,UAAA4D,GAAA5D,UAAG,GAAA,GACA,MAAMxB,EAAKC,KACL8P,EAAuC,QAA3B/P,EAAGS,OAAOuP,MAAMC,QAC5BC,EACW,QAAbL,GACe,UAAbA,IACEE,EAER/P,EAAGS,OAAOuP,MAAMC,QACZC,EAAW,OACTlQ,EAAGmQ,oBAGTnQ,EAAG+J,YAAY,QAAQqG,SAAQ/F,IAC3B,MAAMgG,YAACA,EAAWC,cAAEA,GAAiBjG,EAAItJ,QACrCsP,GAAahG,EAAI5J,OAAO8P,UACxBL,EAAW,MACT,UACJG,GACEC,GAAejG,EAAI5J,OAAO8P,UAC1BL,EAAW,SACT,OACJI,EAAc,IAGpBtQ,EAAG+J,YAAY,CAAC,UAAW,eAAe/B,IACtCkI,EAAW7F,GAAOA,EAAI2C,UACpB3C,GAAOA,EAAI6C,SAErB,EAER,CACJ,UC9CyCsD,EAEzC,MAAAnF,UAC0BN,EAAWhG,WAAA+J,GAAAW,GAAAvK,GAAAsL,EAAAxL,IAAAC,SAoBhCuC,EAAM,EAAA,UAAA,CASNA,EAmCAA,EAAAA,UAAAA,CAAAA,eAjEJ+H,KAAQ1O,WAAAA,GAAAgB,SAAAL,WAAAiO,EAAAxP,KAAA,CAEL,YAAM4G,GACF,MAAM7G,EAAKC,KACXD,EAAGmQ,oBAAsBnQ,EAAGS,OAAOuP,MAAMC,QAEzC,IACI,MAAMzL,KACHkK,EAAS1O,EAAGS,OAAQT,EAAG6F,UAC5B,CACE,MAAM4K,QAAgBzQ,EAAG0H,QAAQlD,GAC1BiM,EAAQzF,WACXyF,EAAQxI,KAAOjI,EAAGsF,UACdmL,EAAQ1P,QAAQkH,KACdzD,EAAKI,aAAa,SAExB5E,EAAG4G,SAAS6J,EAAQxI,MAAQwI,EAC5BA,EAAQhG,WAEhB,CACJ,CACA,YACMiG,GACF,MAAM1Q,EAAKC,KACX,OAAOkB,OAAOwP,kBACJjK,QAAQkK,IAAIzP,OAAOC,QAAQpB,EAAG4G,UAAUoB,KAC1C2F,UAAA,IAAQ1M,EAAK8H,GAAMrI,EAAA,MAAG,CAACO,QAAW8H,EAAM2H,SAAS,KAG7D,CACA,YACMG,CAAM7H,GAAc,IAAb+E,KAACA,EAAO,CAAC,GAAE/E,EACpB,MAAMhJ,EAAKC,KACL6Q,EAAkB3P,OAAO4M,GAAMlN,YACrC,GAAIiQ,IAAoB,CAAE,EAACjQ,YAAa,MAAMb,EAAG8D,YAC7C,wBACE,0CAA0CgN,EAAgB7I,eAEhE,OAAO9G,OAAOwP,kBACJjK,QAAQkK,IACVzP,OAAOC,QAAQpB,EAAG4G,UAAUoB,KACxB2F,UAAyB,IAAjB1M,EAAKR,GAAOsQ,EAQhB,MAAM7P,EAAQ8P,UACd,MAAO,CAAC/P,QADYR,EAAOoQ,OAAO,CAAC9C,KAAMA,EAAK9M,KAC3B,KAKvC,CACA,aAAMgQ,GACF,MAAMjR,EAAKC,KACX,IACI,MAAM8I,KAAS5H,OAAOwJ,OAAO3K,EAAG4G,UAClC,UACUmC,EAAMkI,UAChB,OAAO,EACT,OAAO,CACX,CACA,WACMC,GACF,MAAMlR,EAAKC,KACX,aAAaD,EAAG6Q,OAAO,CAAC9C,KAAM,CAAC,GACnC,CAAChJ,SAAAC,IC5EL,MAAMmM,EAAU5R,OAAO,eAEvB,MAAM6R,EACFvQ,WAAAA,GACIZ,KAAKoR,IAAM3K,QAAQC,SACvB,CACA2K,IAAAA,GAEI,IAAIC,EACJ,MAAMC,EAAU,IAAI9K,SAAQC,IACxB4K,EAAcA,IAAM5K,GAAS,IAE3B8K,EAAUxR,KAAKoR,IAGrB,OAFApR,KAAKoR,IAAMG,EAEJC,EAAQC,MAAK,SAASC,IACzB,OAAOJ,CACX,GACJ,EAGG,MAAMK,EAAQ,SAASC,EAAuBC,GACjD,OAAO,SAASC,EAAgBtR,EAAMC,GAAU,IAARC,KAACA,GAAKD,EAC1C,GAAY,UAARC,EACA,OAAOgN,eAAeqE,IAClB,MAAMhS,EAAKC,KACLD,EAAGmR,KAAUnR,EAAGmR,GAAW,IAC3BnR,EAAGmR,GAASW,KAAU9R,EAAGmR,GAASW,GAAW,IAAIV,GACvD,MAAMO,QAAe3R,EAAGmR,GAASW,GAASR,OAC1C,IAAI/J,EAAKoI,EACT,IAAI,IAAA,IAAApO,EAAAC,UAAAC,OAN8BC,EAAIC,IAAAA,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,GAAAJ,UAAAI,GAOlC+N,QAAalP,EAAOwR,KAAKjS,KAAO0B,EACnC,CAAC,MAAOwQ,GACL3K,EAAM2K,CACV,CAEA,GADAP,IACIpK,EAAK,MAAMA,EACf,OAAOoI,GAKvB,ECtCawC,EAAW,SAASC,EAAwB3R,EAAMC,GAAU,IAARC,KAACA,GAAKD,EACnE,GAAY,SAARC,EAAiB,CAAA,IAAA8O,EAAA4C,EACjB,OAAO,MAAMC,UAAuB7R,EAAOsE,UAAA0K,GAAAxK,EAAAoN,KAAAA,CAAAA,CAAAA,iBAAAvD,EAAAjO,WAAAA,GAAAgB,SAAAL,WAAAiO,EAAAxP,KAAA,CACvC,EAAAoS,EAyCCT,EAAM,iBAzCS,aACZ,MAAMjC,EAAO9N,MAAMgF,UAAOrF,WACpBxB,EAAKC,KAKX,GAHAD,EAAGmS,WAAcnS,EAAGe,QAAQoR,SAC5BnS,EAAGuS,QAAQjG,aAAa,YAAatM,EAAGmS,UACxCnS,EAAG4G,SAASwJ,SAAQlL,GAAGA,EAAEzE,OAAO6L,aAAa,WAAYtM,EAAGmS,YACxDnS,EAAGmS,SAAU,CACb,IAAIK,EAAa,KACbC,EAAW,KACfzS,EAAGS,OAAO0C,iBAAiB,aAAa2L,IACjB,OAAf0D,GACAA,EAAa1D,EAAErO,OACfqO,EAAEhM,mBAGFgM,EAAEjM,gBACN,IAEJ7C,EAAGS,OAAO0C,iBAAiB,YAAY2L,GAAKA,EAAEjM,mBAC9C7C,EAAGS,OAAO0C,iBAAiB,QAAQ2L,IAC/B,IAAM0D,EAAY,OAClB,IAAI/R,EAASqO,EAAErO,OACf,KACIA,EAAOoH,eACJpH,EAAOoH,eAAiB2K,EAAW3K,eACxCpH,EAASA,EAAOoH,cAClB4K,EAAWhS,CAAM,IAErBT,EAAGS,OAAO0C,iBAAiB,WAAWwK,UAC9B8E,SAAiBzS,EAAG0S,KAAK,CACzBC,KAAM3S,EAAG4H,aAAa4K,GACtBI,GAAI5S,EAAG4H,aAAa6K,KAExBD,EAAa,KACbC,EAAW,IAAI,GAEvB,CAEA,OAAO9C,CACX,CACA,UACM+C,GAAmB,IAAd3R,EAAOS,UAAAC,OAAA,QAAA2D,IAAA5D,UAAA,GAAAA,UAAA,GAAG,CAAA,EACjB,MAAMxB,EAAKC,KACX,IAAI0S,KACAA,EAAIC,GACJA,GACA7R,EAQJ,GACW,OAAP6R,GACY,OAATD,EACL,OACF,MAAME,EAAQC,OAAOH,GAAM1K,MACrB8K,EAAMD,OAAOF,GAAI3K,MACvB,GAAI4K,GAASE,EACT,OACG,GAAIF,EAAQE,EAAK,CACpB,MAAMC,EAAW,IACVhT,EAAG4G,SAASvC,MAAMwO,EAAQ,EAAGE,EAAM,GACtC/S,EAAG4G,SAASiM,IACd7K,KAAI,CAAC9C,EAAG+N,KACN/N,EAAE+C,KAAOgL,EAAEJ,EACX3N,EAAEuF,WACKvF,KAEXlF,EAAG4G,SAASsM,OAAOL,EAAOE,EAAMF,EAAQ,KAAMG,EAClD,MAAO,GAAIH,EAAQE,EAAK,CACpB,MAAMC,EAAW,CACbhT,EAAG4G,SAASiM,MACT7S,EAAG4G,SAASvC,MAAM0O,EAAKF,IAC5B7K,KAAI,CAAC9C,EAAG+N,KACN/N,EAAE+C,KAAOgL,EAAEF,EACX7N,EAAEuF,WACKvF,KAEXlF,EAAG4G,SAASsM,OAAOH,EAAKF,EAAQE,EAAM,KAAMC,EAChD,CACA,MAAMG,EAAMN,UACNO,GADMP,EAAQE,EAAM,GAAK,GACN,EAAI,QAAU,SACvCH,EAAGnS,OAAO2S,GAAYT,EAAKlS,OAC/B,EAER,CACJ,gBC5DA4S,QAXA,SAASC,EAAiB7S,GAGkB,OAApCA,EAAOmE,aAAa,aAEpBnE,EAAO6L,aAAa,WAAY,KAExC,CAMA,MAAAiH,WAE0BxI,EAAWhG,WAAA+J,GAAAW,GAAAvK,GAAAmO,EAAArO,IAAAC,EAAAuO,KAAAA,CAAAA,CAAAA,EA6EhChM,EAAAA,UAAAA,CAAAA,eAAMiM,EAAA,EAAA,WAAA,CAAAC,EAAA,EAAA,cAAA,CA2QNlM,EAKAA,EAAAA,SAAAA,CAAAA,EA/VJ+H,EAAAA,UAAAA,CAAAA,EACA4C,KAAQtR,WAAAA,GAAAgB,SAAAL,WAAAiO,EAAAxP,KAAA,CAEL,EAAAuT,EAgEC5B,CAAAA,EAAM,iBACNpK,GAAMiM,EAAA,CAgDNjM,EACAoK,EAAM,kBAAgB8B,EAAA,CAsGtBlM,EACAoK,EAAM,kBAzNG,aACN,MAAM5R,EAAKC,KACXD,EAAGmQ,oBAAsBnQ,EAAGS,OAAOuP,MAAMC,QAEzCjQ,EAAG2T,UAAYxF,KAAKyF,IAAI,EACW,iBAAxB5T,EAAGe,QAAQ4S,UAAwB3T,EAAGe,QAAQ4S,UACnD,GAEN3T,EAAG6T,UAAY1F,KAAKyF,IAAI5T,EAAG2T,UACQ,iBAAxB3T,EAAGe,QAAQ8S,UAAwB7T,EAAGe,QAAQ8S,UACnD3K,KAENlJ,EAAG4G,SAAW,GACd,MAAMkN,EAAY9T,EAAGS,OAAOmG,SAASnF,OACrC,GAAiB,GAAbqS,EAAgB,MAAM9T,EAAG8D,YACzB,0BACE,+DAA+DgQ,WAGrE,GADA9T,EAAGuS,QAAUvS,EAAGS,OAAOmG,SAAS,GAES,OAArC5G,EAAGuS,QAAQwB,cAAc,QAC3B,MAAM/T,EAAG8D,YACP,mBACE,2EAEN,MAAMkQ,EAAahU,EAAGiH,eAClBjH,EAAGuS,QACD,CACE7N,KAAM1E,EAAGe,QAAQkT,KAGzB,GACIjU,EAAGe,QAAQkT,IACRD,EAAWtP,MAAQ1E,EAAGe,QAAQkT,GACnC,MAAMjU,EAAG8D,YACP,2BACE,4BAIN9D,EAAGgC,KAAK+E,YAAW4G,UACf,IAAI,IAAIsF,EAAE,EAAGA,EAAEjT,EAAG2T,UAAWV,UAAWjT,EAAGkU,UACvB,GAAhBlU,EAAG2T,WAGH3T,EAAG+J,YAAY,SAASqG,SACpB/F,GAAKA,EAAI5J,OAAO0T,UAAYxP,OAAO3E,EAAG4G,SAASnF,UAIvDzB,EAAGS,OAAO6L,aAAa,YAAa,UACpCtM,EAAGS,OAAO6L,aAAa,cAAe,OAAO,IAEjDtM,EAAGuS,QAAQ6B,QAEf,CACArH,eAAAA,CAAerM,GAAmB,IAAlB8G,OAACA,EAAMkG,OAAEA,GAAOhN,EAC5B,OAAQ8G,GACJ,IAAK,UACL,IAAK,aACD8L,EAAiB5F,EAAOjN,QAGpC,CACA,YAEMiQ,GACF,MAAM1Q,EAAKC,KACLsT,EAAO,GACPc,GAAiBrU,EAAGoG,iBAAiB,iBAAiB,GAC5D,IAAK,MAAM2C,KAAS/I,EAAG4G,SACfyN,SAAsBtL,EAAMkI,WAChCsC,EAAKlT,WAAW0I,EAAM2H,UAE1B,OAAO6C,CACX,CACA,YACM1C,CAAM7H,GAAc,IAAb+E,KAACA,EAAO,IAAG/E,EACpB,MAAMhJ,EAAKC,MAEL8N,aAAgBpM,QAAOoM,EAAO,CAACA,IAErC,IACI,IAAIkF,EAAI,EACRA,EAAI9E,KAAKmG,IAAIvG,EAAKtM,OAAQzB,EAAG6T,WAC7BZ,IAEIjT,EAAG4G,SAASnF,QAAUwR,SAASjT,EAAGkU,gBAChClU,EAAG4G,SAASqM,GAAGpC,OAAO,CAAC9C,KAAMA,EAAKkF,KAG5C,IACI,IAAIA,EAAI9E,KAAKyF,IAAI7F,EAAKtM,OAAQzB,EAAG2T,WACjCV,EAAIjT,EAAG4G,SAASnF,cACZzB,EAAGuU,aAEPxG,EAAKtM,OAASzB,EAAG6T,WACjB7T,EAAGwC,KAAK,QAAS,CACbwB,KAAM,uBACNC,QAAS,uFACTuG,QAASxK,EACT+N,OACAhN,QAASf,EAAGe,UAIpB,IACI,IAAIkS,EAAIlF,EAAKtM,OACbwR,EAAIjT,EAAG4G,SAASnF,OAChBwR,IACFjT,EAAG4G,SAASqM,GAAG/B,OAErB,CACA,aAEMgD,GAAsB,IAAdnT,EAAOS,UAAAC,OAAA,QAAA2D,IAAA5D,UAAA,GAAAA,UAAA,GAAG,CAAA,EACpB,MAAMxB,EAAKC,KAEX,IAAIuH,OACAA,EAAMkG,OACNA,EAAS,KAAIlD,QACbA,EAAUxK,EAAES,OACZA,EAAM+T,SACNA,EAAW,QAAOC,WAClBA,GACA1T,EACJ,GAAgB,SAAZyT,GAAmC,UAAZA,EAAsB,MAAMxU,EAAG8D,YACtD,8BACE,kDAAkD0Q,KAExD,GAAIxU,EAAG4G,SAASnF,QAAUzB,EAAG6T,UAMzB,YALA7T,EAAGwC,KAAK,QAAS,CACbwB,KAAM,yBACNC,QAAS,2CACTlD,YAIJf,EAAG4G,SAASnF,SAAYhB,IAAQA,EACpB,UAAZ+T,EAAwBxU,EAAG4G,SAAS,GAClC5G,EAAG4G,SAAS5G,EAAG4G,SAASnF,OAAS,IAIvC,MAAMiT,EAAgB1U,EAAGuS,QAAQoC,WAAU,GAGrCC,EAAiB,GAcvB,IAAInE,EAmCJ,SA/CMzQ,EAAGwC,KAAK,UAAW,CACjBgF,SACAkG,SACAlD,UACA/J,SACA+T,WACAE,gBACA3T,UACAgG,WAAYC,GAAO4N,EAAevU,KAAK2G,KAKzChH,EAAG4G,SAASnF,OAQdzB,EAAG4G,gBAAkBF,QAAQkK,IACzB5Q,EAAG4G,SAASoB,KAAI2F,MAAO5E,EAAOkK,IACpBlK,EAAMtI,OAAOgN,WAAWhN,EAAOA,QACrB,SAAZ+T,GACAzL,EAAMtI,OAAOoU,MAAMH,GACnBjE,QAAgBzQ,EAAG0H,QAAQgN,EAAe,CAAChQ,KAAM,eAC3C+L,EAAQhK,SACP,CAACsC,EAAO0H,KAEf1H,EAAMtI,OAAOqU,OAAOJ,GACpBjE,QAAgBzQ,EAAG0H,QAAQgN,EAAe,CAAChQ,KAAM,eAC3C+L,EAAQhK,SACP,CAACgK,EAAS1H,IAVgCA,MAcxDE,OACAjB,KAAI,CAAC9C,EAAE+N,KACJ/N,EAAE+C,KAAOgL,EACT/N,EAAEuF,WACKvF,MA3BflF,EAAGS,OAAOsU,YAAYL,GACtBjE,QAAgBzQ,EAAG0H,QAAQgN,EAAe,CAAChQ,KAAM,OAAQuD,KAAM,UACzDwI,EAAQhK,SACdzG,EAAG4G,SAASvG,KAAKoQ,GACjBA,EAAQxI,KAAO,EACfwI,EAAQhG,YA4BM,WAAdgK,GAA8BhE,EAC9B1B,EAAS0B,EAAQhQ,QAAUgQ,EAAQuE,kBAChC,CACH,MAAMC,EACAxE,EACc,QAAdgE,EAAuBhE,EACT,UAAdgE,EAAyBhE,EAAQpL,OACjC,KAHU,KAKZ4P,GAAYA,EAAW3L,QAC/B,CAGAsL,EAAexE,SAAQpJ,GAAKA,EAAIyJ,KAEhCzQ,EAAG+J,YAAY,SAASqG,SACpB/F,GAAKA,EAAI5J,OAAO0T,UAAYxP,OAAO3E,EAAG4G,SAASnF,UAEnDgP,EAAQ7F,OACZ,CACA,gBAEM2J,GAAyB,IAAdxT,EAAOS,UAAAC,OAAA,QAAA2D,IAAA5D,UAAA,GAAAA,UAAA,GAAG,CAAA,EACvB,MAAMxB,EAAKC,KACX,IAAIuH,OACAA,EAAMkG,OACNA,EAAS,KAAIlD,QACbA,EAAUxK,EAAES,OACZA,EAAMgU,WACNA,EAAUS,eACVA,EAAcC,SACdA,GACApU,EACJ,IAAMN,EAAQ,CACV,GAAIyU,EAAgB,IAChB,MAAMnJ,IAAK,IAAI/L,EAAG4G,UACjBsB,UACH,SAAU6D,EAAEkF,UAAW,CACrBxQ,EAASsL,EACT,KACJ,CACMtL,IACFA,EAAST,EAAG4G,SAAS5G,EAAG4G,SAASnF,OAAS,GAC1CyT,GAAiB,EAIzB,CACA,MAAME,EACF3U,aAAkBkB,MAAQlB,EACxB,CAACA,GAEP,IAAK,MAAM4U,IAAiB,IAAID,GAASlN,UAAW,CAChD,GAAIlI,EAAG4G,SAASnF,QAAUzB,EAAG2T,UACzB,OAAQwB,GACJ,IAAK,OACD,MACJ,IAAK,QAED,kBADME,EAAcnE,QAGxB,QAMI,YALAlR,EAAGwC,KAAK,QAAS,CACbwB,KAAM,yBACNC,QAAS,+CACTlD,YAKhB,GAAImU,UAA0BG,EAAcpE,UAAW,SACvD,IAAIqE,EAAU,KACVC,EAAmB,KACvB,MAAMC,EAAcxV,EAAG4G,SAClB0B,QAAO,CAACS,EAAOkK,EAAGrC,KACf,GAAI7H,EAAMtI,OAAOgN,WAAW4H,EAAc5U,QAAS,CAC/C,GAAkB,WAAdgU,EACA1F,EAAShG,EAAMtI,OAAQsI,EAAMtI,OAAOuU,kBACjC,CACH,MAAMC,EACY,QAAdR,EAAuB1L,EACP,UAAd0L,EAAyB1L,EAAM1D,OAC/B,KAEF4P,GAAYA,EAAW3L,QAC/B,CAUA,OARAgM,EAAUvM,EAEVwM,EACK3E,EAAInP,OAAQwR,EAAI,EAAKsC,EAAmBtC,EAClC,GAALA,EAAS,KACTA,EAAI,GAGH,CACX,CACA,OAAO,CAAI,IAEdjL,KAAI,CAAC9C,EAAE+N,KACJ/N,EAAE+C,KAAOgL,EACT/N,EAAEuF,WACKvF,KAITuQ,EAAgB,SAEhBzV,EAAGwC,KAAK,aAAc,CACxBgF,SACAkG,SACAlD,UACA/J,OAAQ4U,EACRC,UACAI,cAAeJ,EAAQ7U,OACvBM,UACA4U,UAAW3O,GAAOyO,EAAcpV,KAAK2G,KAIzCsO,EAAQ7U,OAAO2T,SACfpU,EAAG4G,SAAW4O,EAEdxV,EAAG+J,YAAY,SAASqG,SACpB/F,GAAKA,EAAI5J,OAAO0T,UAAYxP,OAAO3E,EAAG4G,SAASnF,UAInDgU,EAAcrF,SAAQpJ,GAAKA,MAGF,OAArBuO,GACAvV,EAAG4G,SAAS2O,GAAkB3K,OAGtC,CAEJ,CACA,aAAMqG,GACF,MAAMjR,EAAKC,KACX,IACI,MAAM8I,KAAS/I,EAAG4G,SACpB,UACUmC,EAAMkI,UAChB,OAAO,EACT,OAAO,CACX,CACA,WACMC,GACF,MAAMlR,EAAKC,KACX,aAAaD,EAAG6Q,OAAO,CAAC9C,KAAM,IAClC,CAEA6H,KAAAA,GAGI,MAAM5V,EAAKC,UACX,OADWA,KACD2G,SAASnF,MACvB,CAACsD,SAAAC,ICzYE,MAAM6Q,WAAcxK,EAAKtG,UAAA0K,GAAAxK,EAAAhF,KAAA,CAAA,CAiC3BuH,EAAM,EAAA,UAAA,CASNA,EAAM,EAAA,UAAA,CA0BNA,EAAM,EAAA,UAAA,IAAAsH,EAAAjO,WAAAA,GAAAgB,SAAAL,WAAAiO,EAAAxP,KAAA,CAnEP,YAAM4G,GACF,MAAM7G,EAAKC,KAUX,GATAD,EAAGoM,cACuB,UAAtBpM,EAAGS,OAAOwC,SACe,WAAtBjD,EAAGS,OAAOwC,SACY,aAAtBjD,EAAGS,OAAOwC,SAEjBjD,EAAG8V,YACG9V,EAAGoM,aACsC,YAAxCzH,OAAO3E,EAAGS,OAAOiE,MAAMxB,cAE1BlD,EAAGoM,YAAa,OACVvK,MAAMgF,SACZ,MAAMkP,EAAY5U,OAAO6U,KAAKhW,EAAG4G,UAAUnF,OAC3C,GAAiB,GAAbsU,EAAgB,MAAM/V,EAAG8D,YACzB,kBAEE,0EAAmBiS,WAE7B,CACA/V,EAAG8K,YACC9K,EAAGoM,YAAcjL,OAAOwJ,OAAO3K,EAAG4G,UAAU,GAAGnG,OAC7CT,EAAGS,MASb,CACA,YACMiQ,GACF,MAAM1Q,EAAKC,KACX,OACID,EAAGoM,YAAcjL,OAAOwJ,aAAa9I,MAAM6O,UAAU,GACnD1Q,EAAG8V,aAAe9V,EAAGS,OAAOwV,QAC5BjW,EAAGS,OAAOS,KAEpB,CACA,YACM2P,CAAMnQ,GAAc,IAAbqN,KAACA,EAAO,IAAGrN,EACpB,MAAMV,EAAKC,KACX,OAAID,EAAGoM,kBACUvK,MAAMgP,OAAO,CAAC9C,KAAM5M,OAAOwP,YACpC,CAAC,CAACxP,OAAO6U,KAAKhW,EAAG4G,UAAU,GAAImH,QAE5B/N,EAAG8V,WACV9V,EAAGS,OAAOwV,UAAalI,EAEvB/N,EAAGS,OAAOS,MAAQ6M,EAKf/N,EAAGS,OAAOS,MACrB,CACA,aAAM+P,GACF,MAAMjR,EAAKC,KACLiB,EACFlB,UAGJ,QAHIA,EAAG8V,WAAa,SACR9V,EAAG0Q,UAEA/K,OAAOlE,MAE1B,CACA,WACMyP,GACF,MAAMlR,EAAKC,WACLD,EAAG6Q,OAAO,CAAC9C,KAAM,IAC3B,ECxEG,MAAMmI,WAAeL,GAAM9Q,UAAA0K,GAAAxK,SAe7BuC,EAAM,EAAA,UAAA,CAQNA,EAAM,EAAA,WAAA,IAAAsH,EAAAjO,WAAAA,GAAAgB,SAAAL,WAAAiO,EAAAxP,KAAA,CAtBP,YAAM4G,SACIhF,MAAMgF,SACZ,MAAM7G,EAAKC,KACLkW,EAAYnW,EAAG8K,YAAY7H,QAC3BuK,EAAaxN,EAAG8K,YAAYlG,aAAa,QAC/C,GACiB,SAAbuR,GAC6C,WAAzC3I,GAAc,UAAUtK,cAC9B,MAAMlD,EAAG8D,YACP,qBACE,wDAEA0J,IAAYxN,EAAG8K,YAAYpG,KAAO,SAC5C,CACA,YACMgM,GACF,MAAM3C,QAAalM,MAAM6O,SACzB,OACI3C,EAAKtM,SAAY2U,MAAMrI,GAAQ+E,OAAO/E,GACpC,IAEV,CACA,YACM8C,CAAMnQ,GAAgB,IAAfqN,KAACA,EAAO,MAAKrN,EACtB,MAAM2V,SAAkBtI,EACxB,aAAalM,MAAMgP,OAAO,CAAC9C,KACX,UAAZsI,EAAuBtI,EACT,UAAZsI,GACKtI,EAAKtM,SACH2U,MAAMrI,GACT+E,OAAO/E,GACX,MAEV,CACA,aAAMkD,GACF,MAAMjR,EAAKC,KACLiB,EAAQ8P,UACd,OAAiB,aADGhR,EAAG0Q,QAE3B,ECvCJ,MAAM4F,GAAc,MACpB,SAASC,GAAaC,GAElB,OAAkB,GAAdA,EAAI/U,OAAoB,IAAIgV,KAAK,CACjCD,EAAIlV,UAAU,EAAG,GACjBkV,EAAIlV,UAAU,EAAG,GACjBkV,EAAIlV,UAAU,EAAG,IACnBgD,KAAK,MASW,IAAdkS,EAAI/U,QACS,KAAV+U,EAAI,IACM,KAAVA,EAAI,GACF,IAAIC,KAAKD,GAMXE,GACX,CACA,SAASC,GAAQzV,GACb,OAAOA,EAAM0V,cAAchT,QAAQ0S,GAAa,GACpD,CACO,MAAMO,WAAahB,GAAM9Q,UAAA0K,GAAAxK,SAe3BuC,EAAM,EAAA,UAAA,CAUNA,EAAM,EAAA,WAAA,IAAAsH,EAAAjO,WAAAA,GAAAgB,SAAAL,WAAAiO,EAAAxP,KAAA,CAxBP,YAAM4G,SACIhF,MAAMgF,SACZ,MAAM7G,EAAKC,KACLkW,EAAYnW,EAAG8K,YAAY7H,QAC3BuK,EAAaxN,EAAG8K,YAAYlG,aAAa,QAC/C,GACiB,SAAbuR,GAC2C,SAAvC3I,GAAc,QAAQtK,cAC5B,MAAMlD,EAAG8D,YACP,mBACE,oDAEA0J,IAAYxN,EAAG8K,YAAYpG,KAAO,OAC5C,CACA,YACMgM,GACF,MAAM3C,QAAalM,MAAM6O,SACzB,IAAM3C,EAAKtM,OAAQ,OAAO,KAC1B,MAAMP,EAAQqV,GAAaxI,GAC3B,OACIqI,MAAMlV,GAAS,KACbyV,GAAQzV,EAElB,CACA,YACM2P,CAAMnQ,GAAgB,IAAfqN,KAACA,EAAO,MAAKrN,EACtB,MAAMQ,EACF6M,aAAgB0I,KAAO1I,EACN,iBAARA,EAAmB,IAAI0I,KAAK1I,GACjCA,GAAwB,iBAARA,EAClBwI,GAAaxI,GADyB2I,IAG5C,aAAa7U,MAAMgP,OAAO,CAAC9C,KACvBqI,MAAMlV,GAAS,KACbyV,GAAQzV,IAElB,CACA,aAAM+P,GACF,MAAMjR,EAAKC,KACLiB,EAAQ8P,UACd,OAAiB,aADGhR,EAAG0Q,QAE3B,EC3DJ,IAAK,MAAOzI,EAAMiD,KAAe/J,OAAOC,QAAQ,CAC5CyL,UACAmB,aACA3C,OACAkI,EACAsC,SACAK,UACAW,UACA5L,EAAWhD,EAAKiD,GAGpB,MAAM4L,WAAkBzL,EACpBxK,WAAAA,CACIJ,GAKF,IAJIsW,cACEA,EAAgB,CAAE,KACfC,GACNxV,UAAAC,OAAAD,QAAA4D,IAAA5D,UAAA4D,GAAA5D,UAAG,GAAA,GAEJ,MAAMT,EAAU,IACTiW,EACH/O,KAAM,GACNvD,KAAM,QAEV7C,MACIpB,EACEM,EACA,MAEN,MAAMf,EAAKC,KACXD,EAAG+F,eAAe/F,EAAGS,OAAQM,GAC7Bf,EAAG4F,QAAU,IACN5F,EAAG4F,WACHzE,OAAOwP,YACNxP,OAAOC,QAAQ2V,GACV/O,KAAItH,IAAA,IAAEuH,EAAMN,GAAKjH,EAAA,MAAG,CAACuH,EAAMN,EAAKrH,KAAKN,GAAI,MAGtDA,EAAGS,OAAO0C,iBACN,QACEyK,EAAetN,KAAKN,IACpB,GAEN,IAAIoL,EAAgBpL,EACxB,CACA,YAAM6G,GACF,MAAM7G,EAAKC,KACXD,EAAGS,OAAO6L,aAAa,YAAa,cAC9BzK,MAAMgF,SACZ7G,EAAGS,OAAO6L,aAAa,YAAa,QACxC,EAG6B,OAAjCwK,GAAU7L,WAAaA,EAAU6L,EAAA"}