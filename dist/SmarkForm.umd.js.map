{"version":3,"file":"SmarkForm.umd.js","sources":["../src/lib/events.js","../src/lib/legacy.js","../src/lib/component.js","../src/types/trigger.type.js","../src/lib/helpers.js","../src/decorators/foldable.deco.js","../src/types/form.type.js","../src/decorators/mutex.deco.js","../src/types/list.type.js","../src/types/list.decorators/sortable.deco.js","../src/types/input.type.js","../src/types/number.type.js","../src/types/date.type.js","../src/main.js"],"sourcesContent":["// lib/events.js\n// =============\n\nconst sym_local_events = Symbol(\"Events\");\nconst sym_all_events = Symbol(\"allEvents\");\nconst re_actionEvHandler = /^on(?:Before|After)Action_/;\nconst re_localEvHandler = /^onLocal_/;\nconst re_allEvHandler = /^onAll_/;\n\nfunction registerEvHandler(evList, evType, evHandler) {\n    const me = this;\n    if (! evList.has(evType)) evList.set(evType, []);\n    evList.get(evType).push(evHandler.bind(me));\n    return me; // Make chainable.\n};\n\nexport const events = function events_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class eventEnebledTarget extends target {\n            constructor(target, optionsSrc, ...args) {\n\n                // Capture before/after action event hanlers through\n                // onBeforeAction_xxx / onAfterAction_xxx options\n                // ...and onLocal_xxx / onAll_xxx regular event handlers.\n                const options = {};\n                const onOptionCallbacks = [];\n                for (\n                    const [key, value]\n                    of Object.entries(optionsSrc)\n                ) if (key.match(re_actionEvHandler)) {\n                    onOptionCallbacks.push([key.substring(2), value, \"onLocal\"])\n                } else if (key.match(re_localEvHandler)) {\n                    onOptionCallbacks.push([key.substring(8), value, \"onLocal\"])\n                } else if (key.match(re_allEvHandler)) {\n                    onOptionCallbacks.push([key.substring(6), value, \"onAll\"])\n                } else {\n                    // Threat the rest as regular options:\n                    options[key] = value;\n                };\n\n                // Call original constructor:\n                super(target, options, ...args);\n\n                // Events enhancing:\n                const me = this;\n                const ImRoot = Object.is(me, me.root);\n                me[sym_local_events] = new Map();\n                if (ImRoot) me.root[sym_all_events] = new Map();\n                me.onLocal = registerEvHandler.bind(me, me[sym_local_events]);\n                me.onAll = registerEvHandler.bind(me.root, me.root[sym_all_events]);\n                me.on = me.onLocal; // Handy and readable alias for local events.\n\n                // Setup action handlers provided through options:\n                for (\n                    const [evt, handler, listenLevel]\n                    of onOptionCallbacks\n                ) me[listenLevel](evt, handler);\n\n            };\n            async emit(evType, evData) {\n                const me = this;\n                const handlers = [ // Local handlers, then global ones:\n                    ...(me[sym_local_events].get(evType) || []),\n                    ...(me.root[sym_all_events].get(evType) || []),\n                ];\n                let defaultPrevented = false;\n                if (handlers.length) {\n                    let propagationStopped = false;\n                    evData.preventDefault = () => defaultPrevented = true;\n                    evData.stopPropagation = () => propagationStopped = true;\n                    for (const handler of handlers) {\n                        if (propagationStopped) break;\n                        await handler(evData);\n                    };\n                };\n                return ! defaultPrevented;\n            };\n        };\n    };\n};\n\n","// src/lib/legacy.js\n// =================\n\nexport default {\n    disEnhance(me) {\n\n        // Prevent <form>'s default behaviour:\n        if (me.target.tagName.toLowerCase()) {\n            me.target.addEventListener('submit', function(event) {\n\n                // Avoid form's regular submission:\n                event.preventDefault();\n\n                // More work may be needed to be done here (let's give it some\n                // more thought...)\n\n            });\n        };\n\n    },\n};\n","// lib/component.js\n// ================\nconst componentTypes = {};\n\nimport {events} from \"./events.js\";\nimport legacy from \"./legacy.js\";\n\nconst sym_smart = Symbol(\"smart_component\");\nconst re_valid_typename_chars = /^[a-z0-9_]+$/i;\nconst re_has_wildcards = /[\\*\\?]/;\nconst wild2regex = wname => new RegExp(//{{{\n    \"^\"\n    + wname\n        .replace(/\\*+/g, \".*\")\n        .replace(/\\?/g, \".\")\n    + \"$\"\n);//}}}\n\nconst errors = {\n    renderError: class renderError extends Error {//{{{\n        constructor(code, message, path) {\n            super(`RenderError(${path}): ${message}`);\n            this.code = code;\n            this.path = path;\n            this.stack = this.stack\n                .split(\"\\n\")\n                .slice(2)\n                .join(\"\\n\")\n            ;\n        };\n    },//}}}\n};\n\nfunction inferType(node, parentComponent) {//{{{\n    switch (node.tagName.toLowerCase()) {\n        case \"ul\":\n        case \"ol\":\n        case \"table\":\n        case \"thead\":\n        case \"tbody\":\n        case \"tfoot\":\n            return \"list\";\n        case \"input\":\n            const type = String(node.getAttribute(\"type\")||\"\").toLowerCase();\n            switch(type) {\n                case \"number\":\n                case \"date\":\n                    return type;\n            };\n        case \"textarea\":\n        case \"select\":\n            return \"input\";\n        default:\n            //if (parentComponent.options.type == \"list\") return \"form\";\n        case \"form\":\n            return \"form\";\n    };\n};//}}}\n\n@events\nexport class SmarkComponent {\n    constructor(//{{{\n        target\n        , {\n            property_name = \"smark\",\n            ...options\n        } = {}\n        , parent\n    ) {\n        const me = this;\n\n        me.validName = (function nameGenerator() {//{{{\n            let counter = 0;\n            return function(...names){\n                for (\n                    let n0 of names\n                ) if (\n                    typeof n0 == \"string\"\n                ) {\n                    n0 = n0.trim();\n                    if (n0.length) return n0;\n                };\n                return 'UNNAMED'+(++counter);\n            };\n        })();//}}}\n\n        me.actions = {};\n        me.property_name = property_name;\n        me.selector = `[data-${me.property_name}]`;\n        me.types = componentTypes;\n        me.target = target;\n        me.options = options;\n        me.setNodeOptions(me.target, me.options);\n\n        me.parent = parent;\n        if (! me.parent instanceof SmarkComponent) throw me.renderError(\n            'INVALID_PARENT'\n            , `Smark Components must have valid Smark Component parent.`\n        );\n        me.root = (\n            me.parent === null ? me\n            : me.parent.root\n        );\n\n        // Parents iterator:\n        me.parents = {};\n        me.parents[Symbol.iterator] = function* () {\n            let current = me;\n            while (current) {\n                yield current;\n                current = current.parent;\n            };\n        };\n\n        // Calculate prefix or disable autoId:\n        const autoId = me.inherittedOption(\"autoId\", false);\n        me.genId = (\n            autoId === false ? false\n                // Do not auto-generate IDs.\n            : autoId === true ? p => p.replace(/\\//g, \"_\")\n                // Use \"_path_in_underscore_style\".\n            : typeof autoId == \"string\" ? p => autoId+p.replace(/\\//g, \"_\")\n                // Use \"prefix\" + \"_path_in_underscore_style\".\n            : typeof autoId == \"function\" ? autoId\n                // Use fn(path) custom style.\n            : false\n                // Failback to disabled.\n        );\n\n        me.onRenderedTasks = [];\n\n        let setRendered;\n        me.rendered = new Promise(resolve => setRendered = resolve);\n\n        me.children = {};\n        me.target[sym_smart] = me;\n\n        (async ()=>{\n            await me.render();\n            for (\n                const task of me.onRenderedTasks\n            ) await task();\n            me.onRenderedTasks = null;\n            setRendered(true);\n        })();\n        if (me.options.onRendered) me.onRendered(me.options.onRendered);\n\n    };//}}}\n    onRendered(cbk) {//{{{\n        const me = this;\n        if (me.onRenderedTasks) {\n            me.onRenderedTasks.push(cbk.bind(me));\n        } else {\n            cbk.bind(me)();\n        };\n    };//}}}\n    getNodeOptions(node, defaultOptions) {//{{{\n        const me = this;\n        const optionsSrc = (\n            node.dataset[me.property_name] || \"\"\n        ).trim() || null;\n        const options = {\n            ...defaultOptions,\n            ...(()=>{\n                try {\n                    const opt = JSON.parse(optionsSrc);\n                    if (typeof opt != \"object\") throw new Error(\"NO_OBJECT\");\n                    return opt;\n                } catch (err) {\n                    return (\n                        optionsSrc.match(re_valid_typename_chars) ? {type: optionsSrc}\n                        : {}\n                    );\n                };\n            })(),\n        };\n        if (! options.action && ! options.type) options.type = inferType(node, me);\n        me.setNodeOptions(node, options);\n        return options;\n    };//}}}\n    setNodeOptions(node, options) {//{{{\n        const me = this;\n        node.dataset[me.property_name] = JSON.stringify(options);\n    };//}}}\n    async enhance(node, defaultOptions) {//{{{\n        const me = this;\n\n        // Sanityze and store options:{{{\n        let options = me.getNodeOptions(node, defaultOptions);\n        //}}}\n\n        // Prevent default behaviours:{{{\n        legacy.disEnhance(me);\n        //}}}\n\n        // Classify:{{{\n        if (options.action) {\n            if (! options.type) options.type = \"trigger\"; // Make type optional for triggers.\n            if (options.type != \"trigger\") throw me.renderError(\n                \"ACTION_IN_NON_TRIGGER\"\n                , `\"action\" property is only allowed for \"trigger\" components but \"${options.type}\" type specified.`\n            );\n            delete options.name; // Triggers are always unnamed.\n        } else if (typeof options.type != \"string\") {\n            throw me.renderError(\n                \"NO_TYPE_PROVIDED\"\n                , `Invalid SmarkForm item: type is mandatory for non trigger components.`\n            );\n        };\n        //}}}\n\n        // Enhance:{{{\n        const ctrl = me.types[options.type];\n        if (! ctrl) throw me.renderError(\n            \"UNKNOWN_TYPE\"\n            , `Unimplemented SmarkForm component controller: ${options.type}`,\n        );\n        return new ctrl (\n            node\n            , options\n            , me\n        );\n        //}}}\n\n    };//}}}\n    getComponent(target) {//{{{\n        const me = this;\n        return (\n            target[sym_smart]\n            || target.parentElement?.closest(me.selector)[sym_smart]\n            || null\n        );\n    };//}}}\n    getPath() {//{{{\n        const me = this;\n        return (\n            [...me.parents].map(p=>p.name)\n            .reverse()\n            .join(\"/\") // Root parent being \"\" => Starting \"/\".\n            || \"/\" // No join (0 parents => root node)\n        );\n    };//}}}\n    find(path=\"\") { // {{{\n        let base=this;\n        if (path[0] == \"/\") while (base.parent) base = base.parent;\n        const parts = path\n            .split(\"/\")\n            .filter(x=>x)\n        ;\n\n        // (Recursive) Multi-match search (path with '*' wildcards):\n        // (Returns array of components)\n        const firstWildcardPos = parts.findIndex(p=>p.match(re_has_wildcards));\n        if (firstWildcardPos >= 0) {\n            const re_pattern = wild2regex(parts[firstWildcardPos]);\n            const pivotPath = parts.slice(0, firstWildcardPos).join(\"/\");\n            const restPath = parts.slice(firstWildcardPos + 1).join(\"/\");\n            const pivot = base.find(pivotPath);\n            const pivotChilds = Object.entries(pivot.children);\n            return pivotChilds\n                .filter(([name,child])=>child && name.match(re_pattern))\n                .map(([,child])=>child.find(restPath))\n                .flat(Infinity)\n            ;\n        };\n\n        // Straight search (wildcardless path)\n        // (Returns single component)\n        return parts.reduce(\n            ((current, name)=>(\n                current === undefined ? null\n                : name == \"..\" ? current.parent\n                : current.children[name]\n            ))\n            , base\n        )\n    ;\n    };//}}}\n    inherittedOption(optName, defaultValue) {//{{{\n        const me = this;\n        for (\n            const p of me.parents\n        ) if (\n            p.options[optName] !== undefined\n        ) return p.options[optName];\n        return defaultValue;\n    };//}}}\n    moveTo(){//{{{\n        const me = this;\n        if (! me.target.id) me.target.id = me.getPath();\n        document.location.hash = me.target.id;\n        // Avoid noisy url hash \"randomish\" effect:\n        window.history.pushState({}, undefined,window.location.pathname);\n            // Like 'document.location.hash = \"\"' but without leaving leading\n            // hash character.\n    };//}}}\n    getTriggers(actionNames = null) {//{{{\n        const me = this;\n        const myCurrentActions = [];\n        for (\n            const acc\n            of [...me.root.target.querySelectorAll(me.selector)]\n                .map(target=>target[sym_smart])\n                .filter(x=>x) // Ignore not yet rendered.\n        ) {\n            const options = acc.getTriggerArgs()\n            if (! options) continue; // Not a trigger\n            if (! Object.is(options.context, me)) continue;\n            if ( // Matches actionName string or any in actionName array:\n                actionNames\n                && ! (1 + [actionNames].flat().findIndex(n=>n==options.action))\n            ) continue;\n            myCurrentActions.push(acc);\n        };\n        return myCurrentActions;\n    };//}}}\n    updateId() {//{{{\n        const me = this;\n        if (me.genId === false) return; // Abort if disabled.\n        const newId = me.genId(me.getPath());\n        if (me.target.id != newId) {\n            me.target.id = newId;\n            for (\n                const child\n                of Object.values(me.children)\n            ) child.updateId();\n        };\n        return me.target.id\n    };//}}}\n    getTriggerArgs() {}; // Let's easily filter out non trigger compoenents.\n    // Error types:\n    renderError(code, message) {//{{{\n        const me = this;\n        return new errors.renderError(code, message, me.getPath());\n    };//}}}\n};\n\nexport function createType(name, controller) {//{{{\n    if (componentTypes[name] !== undefined) throw new Error(\n        `Duplicate component type definition: ${name}`\n    );\n    if (! (controller.prototype instanceof SmarkComponent)) throw new Error(\n        `Bad component type implementation for: ${name}`\n    );\n    componentTypes[name] = controller;\n};//}}}\n\n","// types/trigger.type.js\n// =====================\nimport {SmarkComponent} from \"../lib/component.js\";\n\nconst beforeEvent = Symbol(\"beforeEventName\");\nconst afterEvent = Symbol(\"afterEventName\");\n\nexport const action = function action_decorator(targetMtd, {kind, name, addInitializer}) {\n    if (kind == \"method\") addInitializer(function registerAction() {\n        this.actions[name] = targetMtd.bind(this);\n        this.actions[name][beforeEvent] = `BeforeAction_${name}`;\n        this.actions[name][afterEvent] = `AfterAction_${name}`;\n    });\n};\n\n\nexport class trigger extends SmarkComponent {\n    render(){\n        const me = this;\n        me.parent.onRendered(()=>{\n            const triggerArgs = me.getTriggerArgs();\n            if (\n                typeof triggerArgs.context?.onTriggerRender == \"function\"\n            ) triggerArgs.context.onTriggerRender(triggerArgs);\n        });\n    };\n    disable() {//{{{\n        const me = this;\n        me.target.disabled = true;\n    };//}}}\n    enable() {//{{{\n        const me = this;\n        me.target.disabled = false;\n    };//}}}\n    getTriggerArgs() {//{{{\n        const me = this;\n        const parents = [...me.parents];\n        const {\n            // property: local variable\n            action: actionSpec,\n            context: contextPath,     // Define context component\n            target: targetPath,       // Define targetted child component\n            ...otherOptions\n        } = me.options;\n        if (! actionSpec) return; // Not a trigger component.\n\n        // Allow binding triggers to specific component types:\n        // (Syntax \"type:action\")\n        let [actionName, targetType] = actionSpec.split(\":\").reverse();\n\n        const context = (\n            contextPath ? me.parent.find(contextPath)\n            : parents.find(p=>{\n                if (targetType && p.options.type != targetType) return false;\n                if (typeof p.actions[actionName] != \"function\") return false;\n                return true;\n            })\n        );\n\n        const target = (\n            targetPath ? context.find(targetPath) // Explicit target (context relative)\n            : contextPath ? null // Explicit context path => don't mind component position\n            : parents.find(p=>p.parent?.target.isSameNode(context?.target))\n        );\n\n        return {\n            action: actionName,\n            origin: me,\n            context,\n            target,\n            ...otherOptions,\n        };\n\n    };//}}}\n};\n\nexport async function onTriggerClick(ev) {\n    const me = this;\n    const triggerComponent = me.getComponent(ev.target);\n    const options = triggerComponent.getTriggerArgs();\n    if (! options) return; // Not a trigger.\n    const {context, action} = options;\n    const mtd = context?.actions[action]\n    if (\n        typeof mtd != \"function\"\n    ) throw me.renderError(\n        \"UNKNOWN_ACTION\"\n        , `Unknown action ${action}`\n        + (context ? ` for ${context.options.type}` : \"\")\n    );\n    if (await me.emit(mtd[beforeEvent], options)) {\n        const data = await mtd(options);\n        me.emit(mtd[afterEvent], {...options, data});\n    };\n};\n\n\n","\nexport function getRoots(target, selector){//{{{\n    const parent = target.parentNode;\n    const isTop = (\n        parent === null ? n => n === null\n        : n=>(n===null)||n.isSameNode(target)\n    );\n    return [\n        ...target.querySelectorAll(selector)\n    ].filter(\n        e=>isTop(e.parentNode.closest(selector))\n    );\n};//}}}\n\nexport function makeRoom(element, pixels) {//{{{\n    let parent = element.parentNode;\n    const direction = (\n        pixels >= 0 ? 1\n        : -1\n    );\n    while (parent) {\n        // Check if parent has vertical scroll bar\n        if (parent.scrollHeight > parent.clientHeight * direction) {\n            // Get the maximum amount that can be scrolled in this parent\n            var maxScroll = parent.scrollHeight - parent.clientHeight * direction;\n\n            // If desired amount is less than maximum scroll, perform scroll\n            if (pixels <= maxScroll * direction) {\n                parent.scrollTop += pixels;\n                return;\n            } else {\n              // If desired amount is greater than maximum scroll,\n              // scroll to maximum and subtract it from desired amount\n              parent.scrollTop = maxScroll;\n              pixels -= maxScroll;\n            };\n        };\n        parent = parent.parentNode;\n    };\n};//}}}\n\n","\nimport {action} from \"../types/trigger.type.js\";\n\nexport const foldable = function foldable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class foldableTarget extends target {\n            render(...args) {//{{{\n                const retv = super.render(...args);\n                const me = this;\n                me.root.onRendered(()=>{\n                    me.fold({operation: (\n                        !! me.options.folded ? \"fold\"\n                        : \"unfold\"\n                    )});\n                });\n                return retv;\n            };//}}}\n            @action\n            fold({//{{{\n                operation = \"toggle\", // Values: \"fold\" / \"unfold\" / \"toggle\"\n            } = {}) {\n                const me = this;\n                const wasFolded = me.target.style.display == \"none\";\n                const isFolded = (\n                    operation == \"fold\" ? true\n                    : operation == \"unfold\" ? false\n                    : ! wasFolded\n                );\n                me.target.style.display = (\n                    isFolded ? \"none\"\n                    : me.originalDisplayProp\n                );\n\n                me.getTriggers(\"fold\").forEach(acc => {\n                    const {foldedClass, unfoldedClass} = acc.options;\n                    if (foldedClass) acc.target.classList[\n                        isFolded ? \"add\"\n                        : \"remove\"\n                    ](foldedClass);\n                    if (unfoldedClass) acc.target.classList[\n                        isFolded ? \"remove\"\n                        : \"add\"\n                    ](unfoldedClass);\n                });\n\n                me.getTriggers([\"addItem\", \"removeItem\"]).map(\n                    isFolded ? acc => acc.disable()\n                    : acc => acc.enable()\n                );\n            };//}}}\n        };\n    };\n};\n","// types/form.type.js\n// ==================\n\nimport {SmarkComponent} from \"../lib/component.js\";\nimport {getRoots} from \"../lib/helpers.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {action} from \"./trigger.type.js\";\n\n@foldable\nexport class form extends SmarkComponent {\n    async render() {//{{{\n        const me = this;\n        me.originalDisplayProp = me.target.style.display;\n        // Enhance childs:\n        for (\n            const node\n            of getRoots(me.target, me.selector)\n        ) {\n            const newItem = await me.enhance(node);\n            if (newItem.options.type != \"trigger\") {\n                newItem.name = me.validName(\n                    newItem.options.name\n                    , node.getAttribute(\"name\")\n                );\n                me.children[newItem.name] = newItem;\n                newItem.updateId();\n            };\n        };\n    };//}}}\n    @action\n    async export() {//{{{\n        const me = this;\n        return Object.fromEntries(\n            await Promise.all(Object.entries(me.children).map(\n                async ([key, child])=>[key, await child.export()]\n            ))\n        );\n    };//}}}\n    @action\n    async import({data = {}}) {//{{{\n        const me = this;\n        const dataConstructor = Object(data).constructor;\n        if (dataConstructor !== {}.constructor) throw me.renderError(\n            'FORM_NOT_PLAIN_OBJECT'\n            , `Expected plain object for form import, ${dataConstructor.name} given.`\n        );\n        return Object.fromEntries(\n            await Promise.all(\n                Object.entries(me.children).map(\n                    async ([key, target]) => {\n                        // Could have used target.then(...) but, event\n                        // components' import() method SHOULD be async, it\n                        // would have failed in case it's not.\n                        // Forcing it to be async is not possible because\n                        // transpilers would break this check.\n                        // ...and, IMHO, this approach is better than a dirty\n                        // Promise.resolve(...)\n                        const value = await target.import({data: data[key]});\n                        return [key, value];\n                    }\n                )\n            )\n        );\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of Object.values(me.children)\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async empty() {//{{{\n        const me = this;\n        return await me.import({data: {}});\n    };//}}}\n};\n","\nconst sym_mux = Symbol(\"smart_mutex\");\n\nclass Mutex {\n    constructor() {\n        this.mtx = Promise.resolve();\n    };\n    lock() {\n        // Sync operation:\n        let nextResolve;\n        const nextMtx = new Promise(resolve => {\n            nextResolve = () => resolve();\n        });\n        const currMtx = this.mtx;\n        this.mtx = nextMtx;\n        // Async behaviour:\n        return currMtx.then(function unlock() {\n            return nextResolve\n        });\n    };\n}\n\nexport const mutex = function method_mutex_generator(muxName) {\n    return function mutex_decorator(target, {kind}) {\n        if (kind == \"method\") {\n            return async function muxed_target(...args) {\n                const me = this;\n                if (! me[sym_mux]) me[sym_mux] = {};\n                if (! me[sym_mux][muxName]) me[sym_mux][muxName] = new Mutex();\n                const unlock = await me[sym_mux][muxName].lock(); // Await previous muxed call (if any)\n                let err, retv;\n                try {\n                    retv = await target.call(me, ...args);\n                } catch (error) {\n                    err = error;\n                };\n                unlock();\n                if (err) throw err;\n                return retv;\n            };\n\n        };\n    };\n};\n","// types/list.type.js\n// ==================\n\n// TODO:\n// =====\n//\n// ðŸ‘‰ Keep first item in place:\n//    -------------------------\n//     \n//    For lists allowing 0 items, make first element disabled and not visible\n//    instead of completely removing from DOM.\n//\n//    This would avoid lots of visual layout issues.\n//\n\n\nimport {SmarkComponent} from \"../lib/component.js\";\nimport {makeRoom} from \"../lib/helpers.js\";\nimport {foldable} from \"../decorators/foldable.deco.js\";\nimport {sortable} from \"./list.decorators/sortable.deco.js\";\nimport {action} from \"./trigger.type.js\";\nimport {mutex} from \"../decorators/mutex.deco.js\";\n\n\n// Helpers:\n// --------\n\nfunction makeNonNavigable(target) {//{{{\n    if (\n        // Tabindex not explicitly defined:\n        target.getAttribute(\"tabindex\") === null\n    ) {\n        target.setAttribute(\"tabindex\", \"-1\");\n    };\n};//}}}\n\n\n// List component type:\n// --------------------\n\n@foldable\n@sortable\nexport class list extends SmarkComponent {\n    render () {//{{{\n        const me = this;\n        me.originalDisplayProp = me.target.style.display;\n\n        me.min_items = Math.max(0,\n            typeof me.options.min_items == \"number\" ? me.options.min_items\n            : 1\n        );\n        me.max_items = Math.max(me.min_items,\n            typeof me.options.max_items == \"number\" ? me.options.max_items\n            : Infinity\n        );\n        me.children = [];\n        const numChilds = me.target.children.length;\n        if (numChilds != 1) throw me.renderError(\n            'LIST_WRONG_NUM_CHILDREN'\n            , `List components must contain exactly 1 direct children, but ${numChilds} given`\n        );\n        me.itemTpl = me.target.children[0];\n        if (\n            me.itemTpl.querySelector(\"[id]\") !== null // Contains IDs\n        ) throw me.renderError(\n            'LIST_CONTAINS_ID'\n            , `List components are not allowed to contain elements with 'id' attribute`\n        );\n        const tplOptions = me.getNodeOptions(\n            me.itemTpl\n            , {\n                type: me.options.of, // Allow to specify items type from list declaration.\n            }\n        );\n        if (\n            me.options.of\n            && tplOptions.type != me.options.of\n        ) throw me.renderError(\n            'LIST_ITEM_TYPE_MISSMATCH'\n            , `List item type missmatch`\n        );\n        // onRendered tweaks:\n        me.root.onRendered(async ()=>{\n            for(let i=0; i<me.min_items; i++) await me.addItem();\n            if (me.min_items == 0) {\n                // Update \"count\" actions in case of not already updated by\n                // me.addItem:\n                me.getTriggers(\"count\").forEach(\n                    acc=>acc.target.innerText = String(me.children.length)\n                );\n            };\n        });\n        me.itemTpl.remove();\n        return;\n    };//}}}\n    onTriggerRender({action, origin}) {//{{{\n        switch (action) {\n            case \"addItem\":\n            case \"removeItem\":\n                makeNonNavigable(origin.target);\n                break;\n        };\n    };//}}}\n    @mutex(\"list_mutating\")\n    @action\n    async export() {//{{{\n        const me = this;\n        const list = [];\n        const stripEmpties = ! me.inherittedOption(\"exportEmpties\", false);\n        for (const child of me.children) {\n            if (stripEmpties && await child.isEmpty()) continue;\n            list.push(await child.export())\n        };\n        return list;\n    };//}}}\n    @action\n    async import({data = []}) {//{{{\n        const me = this;\n        // Auto-update in case of scalar to array template upgrade:\n        if (! data instanceof Array) data = [data];\n        // Load data:\n        for (\n            let i = 0;\n            i < Math.min(data.length, me.max_items); // Limit to allowed items\n            i++\n        ) {\n            if (me.children.length <= i) await me.addItem(); // Make room on demand\n            await me.children[i].import({data: data[i]});\n        };\n        // Remove extra items if possible (over min_items):\n        for (\n            let i = Math.max(data.length, me.min_items);\n            i < me.children.length;\n        ) await me.removeItem();\n        // Report if data doesn't fit:\n        if (data.length > me.max_items) {\n            me.emit(\"error\", {\n                code: 'LIST_IMPORT_OVERFLOW',\n                message: `Trying to import array greater than list's max_items. Data beyond max_items ignored.`,\n                context: me,\n                data,\n                options: me.options,\n            });\n        };\n        // Clear items over imported data if min_items is greater:\n        for (\n            let i = data.length;\n            i < me.children.length; // (Due to min_items)\n            i++\n        ) me.children[i].empty();\n        return; // await me.export();\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    async addItem(options = {}) {//{{{\n        const me = this;\n        // Parameters checking and resolution:{{{\n        let {\n            action,\n            origin = null, // (Internal call)\n            context = me,  // (Internal call)\n            target,\n            position = \"after\",\n            autoscroll,   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n        } = options;\n        if (position != \"after\" && position != \"before\") throw me.renderError(\n            'LIST_WRONG_ADDITEM_POSITION'\n            , `Invalid value for addItem() position property: ${position}`\n        );\n        if (me.children.length >= me.max_items) {\n            me.emit(\"error\", {\n                code: 'LIST_MAX_ITEMS_REACHED',\n                message: `Cannot add items over max_items boundary`,\n                options,\n            });\n            return;\n        };\n        if (me.children.length && ! target) target = ( // Auto target:\n            position == \"before\" ?  me.children[0] // Insert at the beginning\n            : me.children[me.children.length - 1]  // Append at the end\n        );\n        //}}}\n        // DOM element creation:{{{\n        const newItemTarget = me.itemTpl.cloneNode(true);\n        //}}}\n        // addItem event emitting:{{{\n        const onRenderedCbks = [];\n            // Allow for handy callback instead of two separate event handlers\n        await me.emit(\"addItem\", {\n                action,\n                origin,\n                context,\n                target,  // <--- Effective target.\n                position,\n                newItemTarget,\n                options, // <- Original options (including target)\n                onRendered: cbk => onRenderedCbks.push(cbk),\n        });\n        //}}}\n        // Child component creation and insertion:{{{\n        let newItem;\n        if (! me.children.length) {\n            me.target.appendChild(newItemTarget);\n            newItem = await me.enhance(newItemTarget, {type: \"form\", name: 0});\n            await newItem.rendered;\n            me.children.push(newItem);\n            newItem.name = 0;\n            newItem.updateId();\n        } else {\n            me.children = (await Promise.all(\n                me.children.map(async (child, i)=>{\n                    if (! child.target.isSameNode(target.target)) return child;\n                    if (position == \"after\") {\n                        child.target.after(newItemTarget);\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        return [child, newItem]; // Right order, flatted later...\n                    } else {\n                        child.target.before(newItemTarget);\n                        newItem = await me.enhance(newItemTarget, {type: \"form\"});\n                        await newItem.rendered;\n                        return [newItem, child]; // Right order, flatted later...\n                    };\n                })\n            ))\n                .flat()\n                .map((c,i)=>{\n                    c.name = i;\n                    c.updateId();\n                    return c;\n                })\n            ;\n        };\n        //}}}\n        // Autoscroll handling:{{{\n        if (autoscroll == \"elegant\" && !! newItem) {\n            makeRoom(newItem.target, - newItem.offsetHeight);\n        } else {\n            const moveTarget = (\n                ! newItem ? null\n                : autoscroll == \"self\" ? newItem\n                : autoscroll == \"parent\" ? newItem.parent\n                : null\n            );\n            if (moveTarget) moveTarget.moveTo();\n        };\n        //}}}\n        // Execute \"onRendered\" callbacks:{{{\n        onRenderedCbks.forEach(cbk=>cbk(newItem));\n        //}}}\n        me.getTriggers(\"count\").forEach(\n            acc=>acc.target.innerText = String(me.children.length)\n        );\n    };//}}}\n    @action\n    @mutex(\"list_mutating\")\n    async removeItem(options = {}) {//{{{\n        const me = this;\n        let {\n            action,\n            origin = null, // (Internal call)\n            context = me,  // (Internal call)\n            target,\n            autoscroll,   // \"elegant\" / \"self\" / \"parent\" / (falsy)\n            keep_non_empty,\n            failback,\n        } = options;\n        if (! target) {\n            if (keep_non_empty) for (\n                const t of [...me.children]\n                .reverse() // Pick last first\n            ) if (await t.isEmpty()) {\n                target = t;\n                break;\n            };\n            if (! target) {\n                target = me.children[me.children.length - 1];\n                keep_non_empty = false;\n                // Allow non empty removal as last chance if no target\n                // specified.\n            };\n        };\n        const targets = (\n            target instanceof Array ? target\n            : [target]\n        );\n        for (const currentTarget of [...targets].reverse()) {\n            if (me.children.length <= me.min_items) {\n                switch (failback) {\n                    case \"none\":\n                        break;\n                    case \"clear\":\n                        await currentTarget.empty();\n                        return;\n                    case \"throw\":\n                    default:\n                        me.emit(\"error\", {\n                            code: 'LIST_MIN_ITEMS_REACHED',\n                            message: `Cannot remove items under min_items boundary`,\n                            options,\n                        });\n                        return;\n                };\n            };\n            if (keep_non_empty && ! await currentTarget.isEmpty()) continue;\n            let oldItem = null;\n            const newChildren = me.children\n                .filter(child=>{\n                    if (child.target.isSameNode(currentTarget.target)) {\n                        if (autoscroll == \"elegant\") {\n                            makeRoom(child.target, child.target.offsetHeight);\n                        } else {\n                            const moveTarget = (\n                                autoscroll == \"self\" ? child\n                                : autoscroll == \"parent\" ? child.parent\n                                : null\n                            );\n                            if (moveTarget) moveTarget.moveTo();\n                        };\n\n                        oldItem = child;\n                        return false;\n                    };\n                    return true;\n                })\n                .map((c,i)=>{\n                    c.name = i;\n                    c.updateId();\n                    return c;\n                })\n            ;\n            // removeItem event emitting:{{{\n            const onRemovedCbks = [];\n                // Allow for handy callback instead of two separate event handlers\n            await me.emit(\"removeItem\", {\n                action,\n                origin,\n                context,\n                target: currentTarget,  // <--- Effective target.\n                oldItem,                 // Child going to be removed.\n                oldItemTarget: oldItem.target, // Its target (analogous to addItem event).\n                options,\n                onRemoved: cbk => onRemovedCbks.push(cbk),\n            });\n            //}}}\n\n            oldItem.target.remove();\n            me.children = newChildren;\n\n            me.getTriggers(\"count\").forEach(\n                acc=>acc.target.innerText = String(me.children.length)\n            );\n\n            // Execute \"onRemoved\" callbacks:{{{\n            onRemovedCbks.forEach(cbk=>cbk());\n            //}}}\n\n        };\n\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        for (\n            const child of me.children\n        ) if (\n            ! await child.isEmpty()\n        ) return false;\n        return true;\n    };//}}}\n    @action\n    async empty() {//{{{\n        const me = this;\n        return await me.import({data: []});\n    };//}}}\n    @action\n    count() {//{{{\n        // Return number of children.\n        // But also it's sole existence allow reinjecting contents to it.\n        const me = this;\n        return me.children.length;\n    };//}}}\n};\n","// types/list.decorators/sortable.deco.js\n// ======================================\n\nimport {mutex} from \"../../decorators/mutex.deco.js\";\n\nexport const sortable = function list_sortable_decorator(target, {kind}) {\n    if (kind == \"class\") {\n        return class sortableTarget extends target {\n            render(...args) {//{{{\n                const retv = super.render(...args);\n                const me = this;\n\n                me.sortable = !! me.options.sortable;\n                me.itemTpl.setAttribute(\"draggable\", me.sortable);\n                me.children.forEach(c=>c.target.setAttribute(\"dragable\", me.sortable));\n                if (me.sortable) {\n                    let dragSource = null;\n                    let dragDest = null;\n                    me.target.addEventListener(\"dragstart\", e => {\n                        if (dragSource === null) {\n                            dragSource = e.target\n                        } else {\n                            // Single dragging at a time.\n                            e.preventDefault();\n                        };\n                    });\n                    me.target.addEventListener(\"dragover\", e => e.preventDefault());\n                    me.target.addEventListener(\"drop\", e => {\n                        let target = e.target;\n                        while (\n                            target.parentElement\n                            && target.parentElement != dragSource.parentElement\n                        ) target = target.parentElement;\n                        dragDest = target;\n                    });\n                    me.target.addEventListener(\"dragend\", async () => {\n                        if (dragDest)  await me.move({\n                            from: me.getComponent(dragSource),\n                            to: me.getComponent(dragDest),\n                        });\n                        dragSource = null;\n                        dragDest = null;\n                    });\n                };\n\n                return retv;\n            };//}}}\n            @mutex(\"list_mutating\")\n            async move(options = {}) {//{{{\n                const me = this;\n                let {\n                    from,\n                    to,\n                } = options;\n                //\n                // TODO: Convert to action!!!\n                //\n                if (\n                    to === null // Dropped outside\n                    || from === null // (Shouldn't happen)\n                ) return;\n                const fromi = Number(from?.name);\n                const toi = Number(to?.name);\n                if (fromi == toi) {\n                    return;\n                } else if (fromi < toi) {\n                    const newChunk = [\n                        ...me.children.slice(fromi + 1, toi + 1),\n                        me.children[fromi],\n                    ].map((c, i)=>{\n                        c.name = i+fromi;\n                        c.updateId();\n                        return c;\n                    });\n                    me.children.splice(fromi, toi - fromi + 1, ...newChunk);\n                } else if (fromi > toi) {\n                    const newChunk = [\n                        me.children[fromi],\n                        ...me.children.slice(toi, fromi),\n                    ].map((c, i)=>{\n                        c.name = i+toi;\n                        c.updateId();\n                        return c;\n                    });\n                    me.children.splice(toi, fromi - toi + 1, ...newChunk);\n                };\n                const inc = fromi < toi ? 1 : -1;\n                const moveMethod = inc > 0 ? \"after\" : \"before\";\n                to.target[moveMethod](from.target);\n            };//}}}\n        };\n    };\n};\n","// types/input.type.js\n// ===================\nimport {form} from \"./form.type.js\";\nimport {action} from \"./trigger.type.js\";\nexport class input extends form {\n    async render() {//{{{\n        const me = this;\n        me.isSingleton = ! (\n            me.target.tagName === \"INPUT\"\n            || me.target.tagName === \"SELECT\"\n            || me.target.tagName === \"TEXTAREA\"\n        );\n        me.isCheckbox = (\n            ! me.isSingleton\n            && String(me.target.type).toLowerCase() == \"checkbox\"\n        );\n        if (me.isSingleton) {\n            await super.render();\n            const numFields = Object.keys(me.children).length;\n            if (numFields != 1) throw me.renderError(\n                'NOT_A_SINGLETON'\n                , `Singleton forms are only allowed to contain exactly one`\n                + ` data field but ${numFields} found.`\n            );\n        }\n        me.targetField = (\n            me.isSingleton ? me.children[0]\n            : me.target\n        );\n        // console.log(\"New input!!!!\", {\n        //     target: me.target,\n        //     parent: me.parent,\n        //     options: me.options,\n        //     inputField: me.inputField,\n        // });\n        return;\n    };//}}}\n    @action\n    async export() {//{{{\n        const me = this;\n        return (\n            me.isSingleton ? Object.values(await super.export())[0]\n            : me.isCheckbox ? !!me.target.checked\n            : me.target.value\n        );\n    };//}}}\n    @action\n    async import({data = \"\"}) {//{{{\n        const me = this;\n        if (me.isSingleton) {\n            return await super.import({data: Object.fromEntries(\n                [[Object.keys(me.children)[0], data]]\n            )});\n        } else if (me.isCheckbox) {\n            me.target.checked = !! data;\n        } else {\n            me.target.value = data;\n        };\n        // me.target.dispatchEvent(\n        //     new customEvent(\"change\", {})\n        // );\n        return me.target.value;\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = (\n            me.isCheckbox ? \"\" // Do not consider checkboxes.\n            : await me.export()\n        );\n        return ! value.trim().length;\n            // Native input's value type is always a string.\n    };//}}}\n    @action\n    async empty() {//{{{\n        const me = this;\n        await me.import({data: \"\"});\n    };//}}}\n};\n","// types/number.type.js\n// ====================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nexport class number extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetField.tagName;\n        const targetType = me.targetField.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"number\").toLowerCase() != \"number\"\n        ) throw me.renderError(\n            'NOT_A_NUMBER_FIELD'\n            , `Number inputs require an INPUT tag of type \"number\".`\n        );\n        if (! targetType) me.targetField.type = \"number\"; // Autofill\n    };//}}}\n    @action\n    async export() {//{{{\n        const data = await super.export();\n        return (\n            data.length && ! isNaN(data) ? Number(data)\n            : null\n        );\n    };//}}}\n    @action\n    async import({data = null}) {//{{{\n        const typename = typeof data;\n        return await super.import({data:(\n            typename == \"number\" ? data\n            : typename == \"string\"\n                && data.length\n                && ! isNaN(data)\n                ? Number(data)\n            : null\n        )});\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n","// types/date.type.js\n// ==================\nimport {input} from \"./input.type.js\";\nimport {action} from \"./trigger.type.js\";\nconst re_timePart = /T.*/;\nfunction parseDateStr(str) {//{{{\n    // Accept \"YYYYMMDD\":\n    if (str.length == 8) return new Date([\n        str.substring(0, 4),\n        str.substring(4, 6),\n        str.substring(6, 8),\n    ].join(\"-\"));\n\n    // Accept \"YYYY-MM-DD\" (like date inputs)\n    // > new Date(\"2023-11-30\")\n    // 2023-11-30T00:00:00.000Z\n    // ...but don't accept if not zero-padded:\n    // > new Date(\"2023-11-3\")\n    // 2023-11-02T23:00:00.000Z\n    if (\n        str.length == 10\n        && str[4] == \"-\"\n        && str[7] == \"-\"\n    ) return new Date(str);\n\n    // Also don't accept other locale dependant formats:\n    // > new Date(\"11/30/2023\")\n    // 2023-11-29T23:00:00.000Z\n\n    return NaN;\n};//}}}\nfunction ISODate(value) {//{{{\n    return value.toISOString().replace(re_timePart, \"\");\n};//}}}\nexport class date extends input {\n    async render() {//{{{\n        await super.render();\n        const me = this;\n        const targetTag = me.targetField.tagName;\n        const targetType = me.targetField.getAttribute(\"type\");\n        if (\n            targetTag != \"INPUT\"\n            || (targetType || \"date\").toLowerCase() != \"date\"\n        ) throw me.renderError(\n            'NOT_A_DATE_FIELD'\n            , `Date inputs require an INPUT tag of type \"date\".`\n        );\n        if (! targetType) me.targetField.type = \"date\"; // Autofill\n    };//}}}\n    @action\n    async export() {//{{{\n        const data = await super.export();\n        if (! data.length) return null;\n        const value = parseDateStr(data);\n        return (\n            isNaN(value) ? null\n            : ISODate(value)\n        );\n    };//}}}\n    @action\n    async import({data = null}) {//{{{\n        const value = (\n            data instanceof Date ? data // Accept Date instance\n            : typeof data == \"number\" ? new Date(data) // Accept epoch\n            : ! data || (typeof data != \"string\") ? NaN // Reject nullish\n            : parseDateStr(data) // Handle strings\n        );\n        return await super.import({data:(\n            isNaN(value) ? null\n            : ISODate(value)\n        )});\n    };//}}}\n    async isEmpty() {//{{{\n        const me = this;\n        const value = await me.export();\n        return value === null;\n    };//}}}\n};\n","// SmarkForm.js\n// ============\n\nimport {createType} from \"./lib/component.js\";\n\n// Import core component types and event handlers:\nimport {trigger, onTriggerClick} from \"./types/trigger.type.js\";\nimport {form} from \"./types/form.type.js\";\nimport {list} from \"./types/list.type.js\";\nimport {input} from \"./types/input.type.js\";\nimport {number} from \"./types/number.type.js\";\nimport {date} from \"./types/date.type.js\";\n\n// Load core component types:\nfor (const [name, controller] of Object.entries({\n    trigger,\n    form,\n    list,\n    input,\n    number,\n    date,\n})) createType(name,controller);\n\n\n\nclass SmarkForm extends form {\n    constructor(\n        target\n        , {\n            customActions = {},\n            ...formOptions\n        } = {}\n    ) {\n        const options = {\n            ...formOptions,\n            name: \"\",\n            type: \"form\",\n        };\n        super(\n            target\n            , options\n            , null // (Root has no parent)\n        );\n        const me = this;\n        me.setNodeOptions(me.target, options);\n        me.actions = {\n            ...me.actions,\n            ...Object.fromEntries(\n                Object.entries(customActions)\n                    .map(([name, ctrl])=>[name, ctrl.bind(me)])\n            ),\n        };\n        me.target.addEventListener(\n            \"click\"\n            , onTriggerClick.bind(me)\n            , true\n        );\n    };\n};\n\nSmarkForm.createType = createType;\n\nexport default SmarkForm;\n\n"],"names":["sym_local_events","Symbol","sym_all_events","re_actionEvHandler","re_localEvHandler","re_allEvHandler","registerEvHandler","evList","evType","evHandler","has","set","get","push","bind","this","legacy","disEnhance","me","target","tagName","toLowerCase","addEventListener","event","preventDefault","componentTypes","sym_smart","re_valid_typename_chars","re_has_wildcards","errors","Error","constructor","code","message","path","super","concat","stack","split","slice","join","_SmarkComponent","createType","name","controller","undefined","prototype","SmarkComponent","_class","property_name","options","arguments","length","parent","validName","counter","_len","names","Array","_key","n0","trim","actions","selector","types","setNodeOptions","renderError","root","parents","iterator","current","autoId","inherittedOption","setRendered","genId","p","replace","onRenderedTasks","rendered","Promise","resolve","children","render","task","onRendered","cbk","getNodeOptions","node","defaultOptions","optionsSrc","dataset","opt","JSON","parse","err","match","type","action","parentComponent","String","getAttribute","inferType","stringify","enhance","ctrl","getComponent","_target$parentElement","parentElement","closest","getPath","map","reverse","find","base","parts","filter","x","firstWildcardPos","findIndex","re_pattern","wname","RegExp","pivotPath","restPath","pivot","Object","entries","_ref","child","_ref2","flat","Infinity","reduce","optName","defaultValue","moveTo","id","document","location","hash","window","history","pushState","pathname","getTriggers","actionNames","myCurrentActions","acc","querySelectorAll","getTriggerArgs","is","context","n","updateId","newId","values","_initClass","_applyDecs","kind","onOptionCallbacks","key","value","substring","args","ImRoot","Map","onLocal","onAll","on","evt","handler","listenLevel","emit","evData","handlers","defaultPrevented","propagationStopped","stopPropagation","c","beforeEvent","afterEvent","targetMtd","addInitializer","trigger","_triggerArgs$context","triggerArgs","onTriggerRender","disable","disabled","enable","actionSpec","contextPath","targetPath","otherOptions","actionName","targetType","_p$parent","isSameNode","origin","async","onTriggerClick","ev","mtd","data","makeRoom","element","pixels","parentNode","direction","scrollHeight","clientHeight","maxScroll","scrollTop","foldable","_initProto","retv","fold","operation","folded","wasFolded","style","display","isFolded","originalDisplayProp","forEach","foldedClass","unfoldedClass","classList","e","_form","isTop","getRoots","newItem","export","fromEntries","all","import","dataConstructor","_ref3","isEmpty","empty","sym_mux","Mutex","mtx","lock","nextResolve","nextMtx","currMtx","then","mutex","muxName","unlock","call","error","_list","_dec","_dec2","_dec3","min_items","Math","max","max_items","numChilds","itemTpl","querySelector","tplOptions","of","i","addItem","innerText","remove","setAttribute","list","stripEmpties","min","removeItem","position","autoscroll","newItemTarget","cloneNode","onRenderedCbks","after","before","appendChild","offsetHeight","moveTarget","keep_non_empty","failback","t","targets","currentTarget","oldItem","newChildren","onRemovedCbks","oldItemTarget","onRemoved","count","sortable","dragSource","dragDest","move","from","to","fromi","Number","toi","newChunk","splice","moveMethod","input","form","isSingleton","isCheckbox","numFields","keys","targetField","checked","number","targetTag","isNaN","typename","re_timePart","parseDateStr","str","Date","NaN","ISODate","toISOString","date","SmarkForm","customActions","formOptions"],"mappings":"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"}